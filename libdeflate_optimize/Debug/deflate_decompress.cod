; Listing generated by Microsoft (R) Optimizing Compiler Version 19.25.28612.0 

	TITLE	C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__367CC694_corecrt_memcpy_s@h DB 01H
__DC9673E3_corecrt_wstring@h DB 01H
__A29A7DFB_string@h DB 01H
__561309A6_compiler_msc@h DB 01H
__7CC618A3_common_defs@h DB 01H
__7DFAB971_unaligned@h DB 01H
__120D4932_decompress_template@h DB 01H
__0DD5400E_deflate_decompress@c DB 01H
msvcjmc	ENDS
CONST	SEGMENT
_precode_decode_results DD 00H
	DD	0100H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0500H
	DD	0600H
	DD	0700H
	DD	0800H
	DD	0900H
	DD	0a00H
	DD	0b00H
	DD	0c00H
	DD	0d00H
	DD	0e00H
	DD	0f00H
	DD	01000H
	DD	01100H
	DD	01200H
?deflate_precode_lens_permutation@?5??deflate_decompress_default@@9@9 DB 010H ; `deflate_decompress_default'::`6'::deflate_precode_lens_permutation
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+1
_litlen_decode_results DD 040000000H
	DD	040000100H
	DD	040000200H
	DD	040000300H
	DD	040000400H
	DD	040000500H
	DD	040000600H
	DD	040000700H
	DD	040000800H
	DD	040000900H
	DD	040000a00H
	DD	040000b00H
	DD	040000c00H
	DD	040000d00H
	DD	040000e00H
	DD	040000f00H
	DD	040001000H
	DD	040001100H
	DD	040001200H
	DD	040001300H
	DD	040001400H
	DD	040001500H
	DD	040001600H
	DD	040001700H
	DD	040001800H
	DD	040001900H
	DD	040001a00H
	DD	040001b00H
	DD	040001c00H
	DD	040001d00H
	DD	040001e00H
	DD	040001f00H
	DD	040002000H
	DD	040002100H
	DD	040002200H
	DD	040002300H
	DD	040002400H
	DD	040002500H
	DD	040002600H
	DD	040002700H
	DD	040002800H
	DD	040002900H
	DD	040002a00H
	DD	040002b00H
	DD	040002c00H
	DD	040002d00H
	DD	040002e00H
	DD	040002f00H
	DD	040003000H
	DD	040003100H
	DD	040003200H
	DD	040003300H
	DD	040003400H
	DD	040003500H
	DD	040003600H
	DD	040003700H
	DD	040003800H
	DD	040003900H
	DD	040003a00H
	DD	040003b00H
	DD	040003c00H
	DD	040003d00H
	DD	040003e00H
	DD	040003f00H
	DD	040004000H
	DD	040004100H
	DD	040004200H
	DD	040004300H
	DD	040004400H
	DD	040004500H
	DD	040004600H
	DD	040004700H
	DD	040004800H
	DD	040004900H
	DD	040004a00H
	DD	040004b00H
	DD	040004c00H
	DD	040004d00H
	DD	040004e00H
	DD	040004f00H
	DD	040005000H
	DD	040005100H
	DD	040005200H
	DD	040005300H
	DD	040005400H
	DD	040005500H
	DD	040005600H
	DD	040005700H
	DD	040005800H
	DD	040005900H
	DD	040005a00H
	DD	040005b00H
	DD	040005c00H
	DD	040005d00H
	DD	040005e00H
	DD	040005f00H
	DD	040006000H
	DD	040006100H
	DD	040006200H
	DD	040006300H
	DD	040006400H
	DD	040006500H
	DD	040006600H
	DD	040006700H
	DD	040006800H
	DD	040006900H
	DD	040006a00H
	DD	040006b00H
	DD	040006c00H
	DD	040006d00H
	DD	040006e00H
	DD	040006f00H
	DD	040007000H
	DD	040007100H
	DD	040007200H
	DD	040007300H
	DD	040007400H
	DD	040007500H
	DD	040007600H
	DD	040007700H
	DD	040007800H
	DD	040007900H
	DD	040007a00H
	DD	040007b00H
	DD	040007c00H
	DD	040007d00H
	DD	040007e00H
	DD	040007f00H
	DD	040008000H
	DD	040008100H
	DD	040008200H
	DD	040008300H
	DD	040008400H
	DD	040008500H
	DD	040008600H
	DD	040008700H
	DD	040008800H
	DD	040008900H
	DD	040008a00H
	DD	040008b00H
	DD	040008c00H
	DD	040008d00H
	DD	040008e00H
	DD	040008f00H
	DD	040009000H
	DD	040009100H
	DD	040009200H
	DD	040009300H
	DD	040009400H
	DD	040009500H
	DD	040009600H
	DD	040009700H
	DD	040009800H
	DD	040009900H
	DD	040009a00H
	DD	040009b00H
	DD	040009c00H
	DD	040009d00H
	DD	040009e00H
	DD	040009f00H
	DD	04000a000H
	DD	04000a100H
	DD	04000a200H
	DD	04000a300H
	DD	04000a400H
	DD	04000a500H
	DD	04000a600H
	DD	04000a700H
	DD	04000a800H
	DD	04000a900H
	DD	04000aa00H
	DD	04000ab00H
	DD	04000ac00H
	DD	04000ad00H
	DD	04000ae00H
	DD	04000af00H
	DD	04000b000H
	DD	04000b100H
	DD	04000b200H
	DD	04000b300H
	DD	04000b400H
	DD	04000b500H
	DD	04000b600H
	DD	04000b700H
	DD	04000b800H
	DD	04000b900H
	DD	04000ba00H
	DD	04000bb00H
	DD	04000bc00H
	DD	04000bd00H
	DD	04000be00H
	DD	04000bf00H
	DD	04000c000H
	DD	04000c100H
	DD	04000c200H
	DD	04000c300H
	DD	04000c400H
	DD	04000c500H
	DD	04000c600H
	DD	04000c700H
	DD	04000c800H
	DD	04000c900H
	DD	04000ca00H
	DD	04000cb00H
	DD	04000cc00H
	DD	04000cd00H
	DD	04000ce00H
	DD	04000cf00H
	DD	04000d000H
	DD	04000d100H
	DD	04000d200H
	DD	04000d300H
	DD	04000d400H
	DD	04000d500H
	DD	04000d600H
	DD	04000d700H
	DD	04000d800H
	DD	04000d900H
	DD	04000da00H
	DD	04000db00H
	DD	04000dc00H
	DD	04000dd00H
	DD	04000de00H
	DD	04000df00H
	DD	04000e000H
	DD	04000e100H
	DD	04000e200H
	DD	04000e300H
	DD	04000e400H
	DD	04000e500H
	DD	04000e600H
	DD	04000e700H
	DD	04000e800H
	DD	04000e900H
	DD	04000ea00H
	DD	04000eb00H
	DD	04000ec00H
	DD	04000ed00H
	DD	04000ee00H
	DD	04000ef00H
	DD	04000f000H
	DD	04000f100H
	DD	04000f200H
	DD	04000f300H
	DD	04000f400H
	DD	04000f500H
	DD	04000f600H
	DD	04000f700H
	DD	04000f800H
	DD	04000f900H
	DD	04000fa00H
	DD	04000fb00H
	DD	04000fc00H
	DD	04000fd00H
	DD	04000fe00H
	DD	04000ff00H
	DD	00H
	DD	030000H
	DD	040000H
	DD	050000H
	DD	060000H
	DD	070000H
	DD	080000H
	DD	090000H
	DD	0a0000H
	DD	0b0100H
	DD	0d0100H
	DD	0f0100H
	DD	0110100H
	DD	0130200H
	DD	0170200H
	DD	01b0200H
	DD	01f0200H
	DD	0230300H
	DD	02b0300H
	DD	0330300H
	DD	03b0300H
	DD	0430400H
	DD	0530400H
	DD	0630400H
	DD	0730400H
	DD	0830500H
	DD	0a30500H
	DD	0c30500H
	DD	0e30500H
	DD	01020000H
	DD	01020000H
	DD	01020000H
_offset_decode_results DD 0100H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	01000500H
	DD	01000700H
	DD	02000900H
	DD	02000d00H
	DD	03001100H
	DD	03001900H
	DD	04002100H
	DD	04003100H
	DD	05004100H
	DD	05006100H
	DD	06008100H
	DD	0600c100H
	DD	07010100H
	DD	07018100H
	DD	08020100H
	DD	08030100H
	DD	09040100H
	DD	09060100H
	DD	0a080100H
	DD	0a0c0100H
	DD	0b100100H
	DD	0b180100H
	DD	0c200100H
	DD	0c300100H
	DD	0d400100H
	DD	0d600100H
	DD	0e800100H
	DD	0ec00100H
CONST	ENDS
PUBLIC	_load_u16_unaligned
PUBLIC	_load_u32_unaligned
PUBLIC	_load_u64_unaligned
PUBLIC	_load_machine_word_t_unaligned
PUBLIC	_store_machine_word_t_unaligned
PUBLIC	_get_unaligned_le16
PUBLIC	_get_unaligned_le32
PUBLIC	_get_unaligned_le64
PUBLIC	_get_unaligned_leword
PUBLIC	_libdeflate_alloc_decompressor@0
PUBLIC	_libdeflate_deflate_decompress@24
PUBLIC	_libdeflate_deflate_decompress_ex@28
PUBLIC	_libdeflate_free_decompressor@4
PUBLIC	__JustMyCode_Default
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allshl:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\decompress_template.h
;	COMDAT _deflate_decompress_default
_TEXT	SEGMENT
_v$1 = -320						; size = 4
_dst$2 = -308						; size = 4
_src$3 = -296						; size = 4
_offset$4 = -284					; size = 4
_length$5 = -272					; size = 4
_entry$6 = -260						; size = 4
_rep_count$7 = -248					; size = 4
_rep_val$8 = -233					; size = 1
_presym$9 = -224					; size = 4
_entry$10 = -212					; size = 4
_num_explicit_precode_lens$11 = -200			; size = 4
_tmp32$ = -188						; size = 4
_tmp16$ = -176						; size = 2
_num_offset_syms$ = -164				; size = 4
_num_litlen_syms$ = -152				; size = 4
_nlen$ = -140						; size = 2
_len$ = -128						; size = 2
_block_type$ = -116					; size = 4
_is_final_block$ = -104					; size = 4
_i$ = -92						; size = 4
_overrun_count$ = -80					; size = 4
_bitsleft$ = -68					; size = 4
_bitbuf$ = -56						; size = 4
_in_end$ = -44						; size = 4
_in_next$ = -32						; size = 4
_out_end$ = -20						; size = 4
_out_next$ = -8						; size = 4
_d$ = 8							; size = 4
_in$ = 12						; size = 4
_in_nbytes$ = 16					; size = 4
_out$ = 20						; size = 4
_out_nbytes_avail$ = 24					; size = 4
_actual_in_nbytes_ret$ = 28				; size = 4
_actual_out_nbytes_ret$ = 32				; size = 4
_deflate_decompress_default PROC			; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR [ebp-516]
  00012	b9 81 00 00 00	 mov	 ecx, 129		; 00000081H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __120D4932_decompress_template@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 40   : 	u8 *out_next = out;

  00028	8b 45 14	 mov	 eax, DWORD PTR _out$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _out_next$[ebp], eax

; 41   : 	u8 * const out_end = out_next + out_nbytes_avail;

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _out_next$[ebp]
  00031	03 45 18	 add	 eax, DWORD PTR _out_nbytes_avail$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR _out_end$[ebp], eax

; 42   : 	const u8 *in_next = in;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  0003a	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax

; 43   : 	const u8 * const in_end = in_next + in_nbytes;

  0003d	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00040	03 45 10	 add	 eax, DWORD PTR _in_nbytes$[ebp]
  00043	89 45 d4	 mov	 DWORD PTR _in_end$[ebp], eax

; 44   : 	bitbuf_t bitbuf = 0;

  00046	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _bitbuf$[ebp], 0

; 45   : 	unsigned bitsleft = 0;

  0004d	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _bitsleft$[ebp], 0

; 46   : 	size_t overrun_count = 0;

  00054	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _overrun_count$[ebp], 0
$next_block$154:

; 47   : 	unsigned i;
; 48   : 	unsigned is_final_block;
; 49   : 	unsigned block_type;
; 50   : 	u16 len;
; 51   : 	u16 nlen;
; 52   : 	unsigned num_litlen_syms;
; 53   : 	unsigned num_offset_syms;
; 54   : 	u16 tmp16;
; 55   : 	u32 tmp32;
; 56   : 
; 57   : next_block:
; 58   : 	/* Starting to read the next block.  */
; 59   : 	;
; 60   : 
; 61   : 	STATIC_ASSERT(CAN_ENSURE(1 + 2 + 5 + 5 + 4));
; 62   : 	ENSURE_BITS(1 + 2 + 5 + 5 + 4);

  0005b	83 7d bc 11	 cmp	 DWORD PTR _bitsleft$[ebp], 17 ; 00000011H
  0005f	0f 83 85 00 00
	00		 jae	 $LN83@deflate_de
  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	85 c0		 test	 eax, eax
  0006c	74 40		 je	 SHORT $LN7@deflate_de
  0006e	8b 45 d4	 mov	 eax, DWORD PTR _in_end$[ebp]
  00071	2b 45 e0	 sub	 eax, DWORD PTR _in_next$[ebp]
  00074	83 f8 04	 cmp	 eax, 4
  00077	72 35		 jb	 SHORT $LN7@deflate_de
$LN4@deflate_de:
  00079	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _get_unaligned_leword
  00082	83 c4 04	 add	 esp, 4
  00085	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00088	d3 e0		 shl	 eax, cl
  0008a	0b 45 c8	 or	 eax, DWORD PTR _bitbuf$[ebp]
  0008d	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  00090	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00093	83 f0 1f	 xor	 eax, 31			; 0000001fH
  00096	c1 e8 03	 shr	 eax, 3
  00099	03 45 e0	 add	 eax, DWORD PTR _in_next$[ebp]
  0009c	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  0009f	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  000a2	83 c8 18	 or	 eax, 24			; 00000018H
  000a5	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  000a8	33 c0		 xor	 eax, eax
  000aa	75 cd		 jne	 SHORT $LN4@deflate_de
  000ac	eb 3c		 jmp	 SHORT $LN83@deflate_de
$LN7@deflate_de:
  000ae	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  000b1	3b 45 d4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  000b4	74 1c		 je	 SHORT $LN86@deflate_de
  000b6	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  000b9	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000bc	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  000bf	d3 e2		 shl	 edx, cl
  000c1	0b 55 c8	 or	 edx, DWORD PTR _bitbuf$[ebp]
  000c4	89 55 c8	 mov	 DWORD PTR _bitbuf$[ebp], edx
  000c7	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  000ca	83 c0 01	 add	 eax, 1
  000cd	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  000d0	eb 09		 jmp	 SHORT $LN87@deflate_de
$LN86@deflate_de:
  000d2	8b 45 b0	 mov	 eax, DWORD PTR _overrun_count$[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 b0	 mov	 DWORD PTR _overrun_count$[ebp], eax
$LN87@deflate_de:
  000db	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  000de	83 c0 08	 add	 eax, 8
  000e1	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  000e4	83 7d bc 17	 cmp	 DWORD PTR _bitsleft$[ebp], 23 ; 00000017H
  000e8	76 c4		 jbe	 SHORT $LN7@deflate_de
$LN83@deflate_de:

; 63   : 
; 64   : 	/* BFINAL: 1 bit  */
; 65   : 	is_final_block = POP_BITS(1);

  000ea	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  000ed	83 e0 01	 and	 eax, 1
  000f0	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  000f6	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  000f9	d1 e9		 shr	 ecx, 1
  000fb	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  000fe	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  00101	83 ea 01	 sub	 edx, 1
  00104	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  00107	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tmp32$[ebp]
  0010d	89 45 98	 mov	 DWORD PTR _is_final_block$[ebp], eax

; 66   : 
; 67   : 	/* BTYPE: 2 bits  */
; 68   : 	block_type = POP_BITS(2);

  00110	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  00113	83 e0 03	 and	 eax, 3
  00116	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  0011c	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  0011f	c1 e9 02	 shr	 ecx, 2
  00122	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  00125	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  00128	83 ea 02	 sub	 edx, 2
  0012b	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  0012e	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tmp32$[ebp]
  00134	89 45 8c	 mov	 DWORD PTR _block_type$[ebp], eax

; 69   : 
; 70   : 	if (block_type == DEFLATE_BLOCKTYPE_DYNAMIC_HUFFMAN) {

  00137	83 7d 8c 02	 cmp	 DWORD PTR _block_type$[ebp], 2
  0013b	0f 85 a3 04 00
	00		 jne	 $LN88@deflate_de

; 71   : 
; 72   : 		/* Dynamic Huffman block.  */
; 73   : 
; 74   : 		/* The order in which precode lengths are stored.  */
; 75   : 		static const u8 deflate_precode_lens_permutation[DEFLATE_NUM_PRECODE_SYMS] = {
; 76   : 			16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
; 77   : 		};
; 78   : 
; 79   : 		unsigned num_explicit_precode_lens;
; 80   : 
; 81   : 		/* Read the codeword length counts.  */
; 82   : 
; 83   : 		STATIC_ASSERT(DEFLATE_NUM_LITLEN_SYMS == ((1 << 5) - 1) + 257);
; 84   : 		num_litlen_syms = POP_BITS(5) + 257;

  00141	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  00144	83 e0 1f	 and	 eax, 31			; 0000001fH
  00147	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  0014d	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  00150	c1 e9 05	 shr	 ecx, 5
  00153	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  00156	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  00159	83 ea 05	 sub	 edx, 5
  0015c	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  0015f	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tmp32$[ebp]
  00165	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0016a	89 85 68 ff ff
	ff		 mov	 DWORD PTR _num_litlen_syms$[ebp], eax

; 85   : 
; 86   : 		STATIC_ASSERT(DEFLATE_NUM_OFFSET_SYMS == ((1 << 5) - 1) + 1);
; 87   : 		num_offset_syms = POP_BITS(5) + 1;

  00170	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  00173	83 e0 1f	 and	 eax, 31			; 0000001fH
  00176	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  0017c	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  0017f	c1 e9 05	 shr	 ecx, 5
  00182	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  00185	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  00188	83 ea 05	 sub	 edx, 5
  0018b	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  0018e	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tmp32$[ebp]
  00194	83 c0 01	 add	 eax, 1
  00197	89 85 5c ff ff
	ff		 mov	 DWORD PTR _num_offset_syms$[ebp], eax

; 88   : 
; 89   : 		STATIC_ASSERT(DEFLATE_NUM_PRECODE_SYMS == ((1 << 4) - 1) + 4);
; 90   : 		num_explicit_precode_lens = POP_BITS(4) + 4;

  0019d	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  001a0	83 e0 0f	 and	 eax, 15			; 0000000fH
  001a3	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  001a9	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  001ac	c1 e9 04	 shr	 ecx, 4
  001af	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  001b2	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  001b5	83 ea 04	 sub	 edx, 4
  001b8	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  001bb	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tmp32$[ebp]
  001c1	83 c0 04	 add	 eax, 4
  001c4	89 85 38 ff ff
	ff		 mov	 DWORD PTR _num_explicit_precode_lens$11[ebp], eax

; 91   : 
; 92   : 		d->static_codes_loaded = false;

  001ca	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  001cd	c7 80 60 1d 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+7520], 0

; 93   : 
; 94   : 		/* Read the precode codeword lengths.  */
; 95   : 		STATIC_ASSERT(DEFLATE_MAX_PRE_CODEWORD_LEN == (1 << 3) - 1);
; 96   : 		for (i = 0; i < num_explicit_precode_lens; i++) {

  001d7	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001de	eb 09		 jmp	 SHORT $LN10@deflate_de
$LN8@deflate_de:
  001e0	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001e3	83 c0 01	 add	 eax, 1
  001e6	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@deflate_de:
  001e9	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001ec	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _num_explicit_precode_lens$11[ebp]
  001f2	0f 83 c8 00 00
	00		 jae	 $LN9@deflate_de

; 97   : 			ENSURE_BITS(3);

  001f8	83 7d bc 03	 cmp	 DWORD PTR _bitsleft$[ebp], 3
  001fc	0f 83 85 00 00
	00		 jae	 $LN90@deflate_de
  00202	b8 01 00 00 00	 mov	 eax, 1
  00207	85 c0		 test	 eax, eax
  00209	74 40		 je	 SHORT $LN16@deflate_de
  0020b	8b 45 d4	 mov	 eax, DWORD PTR _in_end$[ebp]
  0020e	2b 45 e0	 sub	 eax, DWORD PTR _in_next$[ebp]
  00211	83 f8 04	 cmp	 eax, 4
  00214	72 35		 jb	 SHORT $LN16@deflate_de
$LN13@deflate_de:
  00216	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 _get_unaligned_leword
  0021f	83 c4 04	 add	 esp, 4
  00222	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00225	d3 e0		 shl	 eax, cl
  00227	0b 45 c8	 or	 eax, DWORD PTR _bitbuf$[ebp]
  0022a	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  0022d	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00230	83 f0 1f	 xor	 eax, 31			; 0000001fH
  00233	c1 e8 03	 shr	 eax, 3
  00236	03 45 e0	 add	 eax, DWORD PTR _in_next$[ebp]
  00239	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  0023c	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  0023f	83 c8 18	 or	 eax, 24			; 00000018H
  00242	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  00245	33 c0		 xor	 eax, eax
  00247	75 cd		 jne	 SHORT $LN13@deflate_de
  00249	eb 3c		 jmp	 SHORT $LN90@deflate_de
$LN16@deflate_de:
  0024b	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  0024e	3b 45 d4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  00251	74 1c		 je	 SHORT $LN93@deflate_de
  00253	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00256	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00259	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  0025c	d3 e2		 shl	 edx, cl
  0025e	0b 55 c8	 or	 edx, DWORD PTR _bitbuf$[ebp]
  00261	89 55 c8	 mov	 DWORD PTR _bitbuf$[ebp], edx
  00264	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00267	83 c0 01	 add	 eax, 1
  0026a	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  0026d	eb 09		 jmp	 SHORT $LN94@deflate_de
$LN93@deflate_de:
  0026f	8b 45 b0	 mov	 eax, DWORD PTR _overrun_count$[ebp]
  00272	83 c0 01	 add	 eax, 1
  00275	89 45 b0	 mov	 DWORD PTR _overrun_count$[ebp], eax
$LN94@deflate_de:
  00278	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  0027b	83 c0 08	 add	 eax, 8
  0027e	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  00281	83 7d bc 17	 cmp	 DWORD PTR _bitsleft$[ebp], 23 ; 00000017H
  00285	76 c4		 jbe	 SHORT $LN16@deflate_de
$LN90@deflate_de:

; 98   : 			d->u.precode_lens[deflate_precode_lens_permutation[i]] = POP_BITS(3);

  00287	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  0028a	83 e0 07	 and	 eax, 7
  0028d	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  00293	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  00296	c1 e9 03	 shr	 ecx, 3
  00299	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  0029c	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  0029f	83 ea 03	 sub	 edx, 3
  002a2	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  002a5	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  002a8	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?deflate_precode_lens_permutation@?5??deflate_decompress_default@@9@9[eax]
  002af	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  002b2	8a 85 44 ff ff
	ff		 mov	 al, BYTE PTR _tmp32$[ebp]
  002b8	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 99   : 		}

  002bb	e9 20 ff ff ff	 jmp	 $LN8@deflate_de
$LN9@deflate_de:

; 100  : 
; 101  : 		for (; i < DEFLATE_NUM_PRECODE_SYMS; i++)

  002c0	eb 09		 jmp	 SHORT $LN19@deflate_de
$LN17@deflate_de:
  002c2	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  002c5	83 c0 01	 add	 eax, 1
  002c8	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN19@deflate_de:
  002cb	83 7d a4 13	 cmp	 DWORD PTR _i$[ebp], 19	; 00000013H
  002cf	73 13		 jae	 SHORT $LN18@deflate_de

; 102  : 			d->u.precode_lens[deflate_precode_lens_permutation[i]] = 0;

  002d1	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  002d4	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?deflate_precode_lens_permutation@?5??deflate_decompress_default@@9@9[eax]
  002db	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  002de	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  002e2	eb de		 jmp	 SHORT $LN17@deflate_de
$LN18@deflate_de:

; 103  : 
; 104  : 		/* Build the decode table for the precode.  */
; 105  : 		SAFETY_CHECK(build_precode_decode_table(d));

  002e4	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  002e7	50		 push	 eax
  002e8	e8 00 00 00 00	 call	 _build_precode_decode_table
  002ed	83 c4 04	 add	 esp, 4
  002f0	85 c0		 test	 eax, eax
  002f2	75 0a		 jne	 SHORT $LN95@deflate_de
  002f4	b8 01 00 00 00	 mov	 eax, 1
  002f9	e9 c6 0c 00 00	 jmp	 $LN1@deflate_de
$LN95@deflate_de:

; 106  : 
; 107  : 		/* Expand the literal/length and offset codeword lengths.  */
; 108  : 		for (i = 0; i < num_litlen_syms + num_offset_syms; ) {

  002fe	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN22@deflate_de:
  00305	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _num_litlen_syms$[ebp]
  0030b	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _num_offset_syms$[ebp]
  00311	39 45 a4	 cmp	 DWORD PTR _i$[ebp], eax
  00314	0f 83 c5 02 00
	00		 jae	 $LN21@deflate_de

; 109  : 			u32 entry;
; 110  : 			unsigned presym;
; 111  : 			u8 rep_val;
; 112  : 			unsigned rep_count;
; 113  : 
; 114  : 			ENSURE_BITS(DEFLATE_MAX_PRE_CODEWORD_LEN + 7);

  0031a	83 7d bc 0e	 cmp	 DWORD PTR _bitsleft$[ebp], 14 ; 0000000eH
  0031e	0f 83 85 00 00
	00		 jae	 $LN96@deflate_de
  00324	b8 01 00 00 00	 mov	 eax, 1
  00329	85 c0		 test	 eax, eax
  0032b	74 40		 je	 SHORT $LN28@deflate_de
  0032d	8b 45 d4	 mov	 eax, DWORD PTR _in_end$[ebp]
  00330	2b 45 e0	 sub	 eax, DWORD PTR _in_next$[ebp]
  00333	83 f8 04	 cmp	 eax, 4
  00336	72 35		 jb	 SHORT $LN28@deflate_de
$LN25@deflate_de:
  00338	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  0033b	50		 push	 eax
  0033c	e8 00 00 00 00	 call	 _get_unaligned_leword
  00341	83 c4 04	 add	 esp, 4
  00344	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00347	d3 e0		 shl	 eax, cl
  00349	0b 45 c8	 or	 eax, DWORD PTR _bitbuf$[ebp]
  0034c	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  0034f	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00352	83 f0 1f	 xor	 eax, 31			; 0000001fH
  00355	c1 e8 03	 shr	 eax, 3
  00358	03 45 e0	 add	 eax, DWORD PTR _in_next$[ebp]
  0035b	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  0035e	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00361	83 c8 18	 or	 eax, 24			; 00000018H
  00364	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  00367	33 c0		 xor	 eax, eax
  00369	75 cd		 jne	 SHORT $LN25@deflate_de
  0036b	eb 3c		 jmp	 SHORT $LN96@deflate_de
$LN28@deflate_de:
  0036d	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00370	3b 45 d4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  00373	74 1c		 je	 SHORT $LN99@deflate_de
  00375	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00378	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0037b	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  0037e	d3 e2		 shl	 edx, cl
  00380	0b 55 c8	 or	 edx, DWORD PTR _bitbuf$[ebp]
  00383	89 55 c8	 mov	 DWORD PTR _bitbuf$[ebp], edx
  00386	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00389	83 c0 01	 add	 eax, 1
  0038c	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  0038f	eb 09		 jmp	 SHORT $LN100@deflate_de
$LN99@deflate_de:
  00391	8b 45 b0	 mov	 eax, DWORD PTR _overrun_count$[ebp]
  00394	83 c0 01	 add	 eax, 1
  00397	89 45 b0	 mov	 DWORD PTR _overrun_count$[ebp], eax
$LN100@deflate_de:
  0039a	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  0039d	83 c0 08	 add	 eax, 8
  003a0	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  003a3	83 7d bc 17	 cmp	 DWORD PTR _bitsleft$[ebp], 23 ; 00000017H
  003a7	76 c4		 jbe	 SHORT $LN28@deflate_de
$LN96@deflate_de:

; 115  : 
; 116  : 			/* (The code below assumes that the precode decode table
; 117  : 			 * does not have any subtables.)  */
; 118  : 			STATIC_ASSERT(PRECODE_TABLEBITS == DEFLATE_MAX_PRE_CODEWORD_LEN);
; 119  : 
; 120  : 			/* Read the next precode symbol.  */
; 121  : 			entry = d->u.l.precode_decode_table[BITS(DEFLATE_MAX_PRE_CODEWORD_LEN)];

  003a9	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  003ac	83 e0 7f	 and	 eax, 127		; 0000007fH
  003af	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  003b2	8b 94 81 cc 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+460]
  003b9	89 95 2c ff ff
	ff		 mov	 DWORD PTR _entry$10[ebp], edx

; 122  : 			REMOVE_BITS(entry & HUFFDEC_LENGTH_MASK);

  003bf	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _entry$10[ebp]
  003c5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003cb	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  003ce	d3 e8		 shr	 eax, cl
  003d0	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  003d3	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _entry$10[ebp]
  003d9	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003df	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  003e2	2b d1		 sub	 edx, ecx
  003e4	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx

; 123  : 			presym = entry >> HUFFDEC_RESULT_SHIFT;

  003e7	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _entry$10[ebp]
  003ed	c1 e8 08	 shr	 eax, 8
  003f0	89 85 20 ff ff
	ff		 mov	 DWORD PTR _presym$9[ebp], eax

; 124  : 
; 125  : 			if (presym < 16) {

  003f6	83 bd 20 ff ff
	ff 10		 cmp	 DWORD PTR _presym$9[ebp], 16 ; 00000010H
  003fd	73 1c		 jae	 SHORT $LN101@deflate_de

; 126  : 				/* Explicit codeword length  */
; 127  : 				d->u.l.lens[i++] = presym;

  003ff	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00402	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00405	8a 8d 20 ff ff
	ff		 mov	 cl, BYTE PTR _presym$9[ebp]
  0040b	88 08		 mov	 BYTE PTR [eax], cl
  0040d	8b 55 a4	 mov	 edx, DWORD PTR _i$[ebp]
  00410	83 c2 01	 add	 edx, 1
  00413	89 55 a4	 mov	 DWORD PTR _i$[ebp], edx

; 128  : 				continue;

  00416	e9 ea fe ff ff	 jmp	 $LN22@deflate_de
$LN101@deflate_de:

; 129  : 			}
; 130  : 
; 131  : 			/* Run-length encoded codeword lengths  */
; 132  : 
; 133  : 			/* Note: we don't need verify that the repeat count
; 134  : 			 * doesn't overflow the number of elements, since we
; 135  : 			 * have enough extra spaces to allow for the worst-case
; 136  : 			 * overflow (138 zeroes when only 1 length was
; 137  : 			 * remaining).
; 138  : 			 *
; 139  : 			 * In the case of the small repeat counts (presyms 16
; 140  : 			 * and 17), it is fastest to always write the maximum
; 141  : 			 * number of entries.  That gets rid of branches that
; 142  : 			 * would otherwise be required.
; 143  : 			 *
; 144  : 			 * It is not just because of the numerical order that
; 145  : 			 * our checks go in the order 'presym < 16', 'presym ==
; 146  : 			 * 16', and 'presym == 17'.  For typical data this is
; 147  : 			 * ordered from most frequent to least frequent case.
; 148  : 			 */
; 149  : 			STATIC_ASSERT(DEFLATE_MAX_LENS_OVERRUN == 138 - 1);
; 150  : 
; 151  : 			if (presym == 16) {

  0041b	83 bd 20 ff ff
	ff 10		 cmp	 DWORD PTR _presym$9[ebp], 16 ; 00000010H
  00422	0f 85 b6 00 00
	00		 jne	 $LN102@deflate_de

; 152  : 				/* Repeat the previous length 3 - 6 times  */
; 153  : 				SAFETY_CHECK(i != 0);

  00428	83 7d a4 00	 cmp	 DWORD PTR _i$[ebp], 0
  0042c	75 0a		 jne	 SHORT $LN104@deflate_de
  0042e	b8 01 00 00 00	 mov	 eax, 1
  00433	e9 8c 0b 00 00	 jmp	 $LN1@deflate_de
$LN104@deflate_de:

; 154  : 				rep_val = d->u.l.lens[i - 1];

  00438	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0043b	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  0043e	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  00441	88 8d 17 ff ff
	ff		 mov	 BYTE PTR _rep_val$8[ebp], cl

; 155  : 				STATIC_ASSERT(3 + ((1 << 2) - 1) == 6);
; 156  : 				rep_count = 3 + POP_BITS(2);

  00447	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  0044a	83 e0 03	 and	 eax, 3
  0044d	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  00453	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  00456	c1 e9 02	 shr	 ecx, 2
  00459	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  0045c	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  0045f	83 ea 02	 sub	 edx, 2
  00462	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  00465	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tmp32$[ebp]
  0046b	83 c0 03	 add	 eax, 3
  0046e	89 85 08 ff ff
	ff		 mov	 DWORD PTR _rep_count$7[ebp], eax

; 157  : 				d->u.l.lens[i + 0] = rep_val;

  00474	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00477	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  0047a	8a 8d 17 ff ff
	ff		 mov	 cl, BYTE PTR _rep_val$8[ebp]
  00480	88 08		 mov	 BYTE PTR [eax], cl

; 158  : 				d->u.l.lens[i + 1] = rep_val;

  00482	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00485	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00488	8a 8d 17 ff ff
	ff		 mov	 cl, BYTE PTR _rep_val$8[ebp]
  0048e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 159  : 				d->u.l.lens[i + 2] = rep_val;

  00491	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00494	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00497	8a 8d 17 ff ff
	ff		 mov	 cl, BYTE PTR _rep_val$8[ebp]
  0049d	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 160  : 				d->u.l.lens[i + 3] = rep_val;

  004a0	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  004a3	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  004a6	8a 8d 17 ff ff
	ff		 mov	 cl, BYTE PTR _rep_val$8[ebp]
  004ac	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 161  : 				d->u.l.lens[i + 4] = rep_val;

  004af	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  004b2	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  004b5	8a 8d 17 ff ff
	ff		 mov	 cl, BYTE PTR _rep_val$8[ebp]
  004bb	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 162  : 				d->u.l.lens[i + 5] = rep_val;

  004be	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  004c1	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  004c4	8a 8d 17 ff ff
	ff		 mov	 cl, BYTE PTR _rep_val$8[ebp]
  004ca	88 48 05	 mov	 BYTE PTR [eax+5], cl

; 163  : 				i += rep_count;

  004cd	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  004d0	03 85 08 ff ff
	ff		 add	 eax, DWORD PTR _rep_count$7[ebp]
  004d6	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
  004d9	e9 fc 00 00 00	 jmp	 $LN103@deflate_de
$LN102@deflate_de:

; 164  : 			} else if (presym == 17) {

  004de	83 bd 20 ff ff
	ff 11		 cmp	 DWORD PTR _presym$9[ebp], 17 ; 00000011H
  004e5	0f 85 9e 00 00
	00		 jne	 $LN105@deflate_de

; 165  : 				/* Repeat zero 3 - 10 times  */
; 166  : 				STATIC_ASSERT(3 + ((1 << 3) - 1) == 10);
; 167  : 				rep_count = 3 + POP_BITS(3);

  004eb	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  004ee	83 e0 07	 and	 eax, 7
  004f1	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  004f7	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  004fa	c1 e9 03	 shr	 ecx, 3
  004fd	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  00500	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  00503	83 ea 03	 sub	 edx, 3
  00506	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  00509	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tmp32$[ebp]
  0050f	83 c0 03	 add	 eax, 3
  00512	89 85 08 ff ff
	ff		 mov	 DWORD PTR _rep_count$7[ebp], eax

; 168  : 				d->u.l.lens[i + 0] = 0;

  00518	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0051b	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  0051e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 169  : 				d->u.l.lens[i + 1] = 0;

  00521	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00524	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00527	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 170  : 				d->u.l.lens[i + 2] = 0;

  0052b	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0052e	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00531	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 171  : 				d->u.l.lens[i + 3] = 0;

  00535	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00538	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  0053b	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 172  : 				d->u.l.lens[i + 4] = 0;

  0053f	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00542	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00545	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 173  : 				d->u.l.lens[i + 5] = 0;

  00549	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0054c	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  0054f	c6 40 05 00	 mov	 BYTE PTR [eax+5], 0

; 174  : 				d->u.l.lens[i + 6] = 0;

  00553	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00556	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00559	c6 40 06 00	 mov	 BYTE PTR [eax+6], 0

; 175  : 				d->u.l.lens[i + 7] = 0;

  0055d	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00560	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00563	c6 40 07 00	 mov	 BYTE PTR [eax+7], 0

; 176  : 				d->u.l.lens[i + 8] = 0;

  00567	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0056a	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  0056d	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0

; 177  : 				d->u.l.lens[i + 9] = 0;

  00571	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00574	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00577	c6 40 09 00	 mov	 BYTE PTR [eax+9], 0

; 178  : 				i += rep_count;

  0057b	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0057e	03 85 08 ff ff
	ff		 add	 eax, DWORD PTR _rep_count$7[ebp]
  00584	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax

; 179  : 			} else {

  00587	eb 51		 jmp	 SHORT $LN103@deflate_de
$LN105@deflate_de:

; 180  : 				/* Repeat zero 11 - 138 times  */
; 181  : 				STATIC_ASSERT(11 + ((1 << 7) - 1) == 138);
; 182  : 				rep_count = 11 + POP_BITS(7);

  00589	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  0058c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0058f	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  00595	8b 4d c8	 mov	 ecx, DWORD PTR _bitbuf$[ebp]
  00598	c1 e9 07	 shr	 ecx, 7
  0059b	89 4d c8	 mov	 DWORD PTR _bitbuf$[ebp], ecx
  0059e	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  005a1	83 ea 07	 sub	 edx, 7
  005a4	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx
  005a7	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tmp32$[ebp]
  005ad	83 c0 0b	 add	 eax, 11			; 0000000bH
  005b0	89 85 08 ff ff
	ff		 mov	 DWORD PTR _rep_count$7[ebp], eax

; 183  : 				memset(&d->u.l.lens[i], 0,

  005b6	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _rep_count$7[ebp]
  005bc	50		 push	 eax
  005bd	6a 00		 push	 0
  005bf	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  005c2	03 4d a4	 add	 ecx, DWORD PTR _i$[ebp]
  005c5	51		 push	 ecx
  005c6	e8 00 00 00 00	 call	 _memset
  005cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 				       rep_count * sizeof(d->u.l.lens[i]));
; 185  : 				i += rep_count;

  005ce	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  005d1	03 85 08 ff ff
	ff		 add	 eax, DWORD PTR _rep_count$7[ebp]
  005d7	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN103@deflate_de:

; 186  : 			}
; 187  : 		}

  005da	e9 26 fd ff ff	 jmp	 $LN22@deflate_de
$LN21@deflate_de:

; 188  : 	} else if (block_type == DEFLATE_BLOCKTYPE_UNCOMPRESSED) {

  005df	e9 14 02 00 00	 jmp	 $LN89@deflate_de
$LN88@deflate_de:
  005e4	83 7d 8c 00	 cmp	 DWORD PTR _block_type$[ebp], 0
  005e8	0f 85 26 01 00
	00		 jne	 $LN107@deflate_de
$LN31@deflate_de:

; 189  : 
; 190  : 		/* Uncompressed block: copy 'len' bytes literally from the input
; 191  : 		 * buffer to the output buffer.  */
; 192  : 
; 193  : 		ALIGN_INPUT();

  005ee	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  005f1	c1 e8 03	 shr	 eax, 3
  005f4	39 45 b0	 cmp	 DWORD PTR _overrun_count$[ebp], eax
  005f7	76 0a		 jbe	 SHORT $LN109@deflate_de
  005f9	b8 01 00 00 00	 mov	 eax, 1
  005fe	e9 c1 09 00 00	 jmp	 $LN1@deflate_de
$LN109@deflate_de:
  00603	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00606	c1 e8 03	 shr	 eax, 3
  00609	2b 45 b0	 sub	 eax, DWORD PTR _overrun_count$[ebp]
  0060c	8b 4d e0	 mov	 ecx, DWORD PTR _in_next$[ebp]
  0060f	2b c8		 sub	 ecx, eax
  00611	89 4d e0	 mov	 DWORD PTR _in_next$[ebp], ecx
  00614	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _overrun_count$[ebp], 0
  0061b	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _bitbuf$[ebp], 0
  00622	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _bitsleft$[ebp], 0
  00629	33 c0		 xor	 eax, eax
  0062b	75 c1		 jne	 SHORT $LN31@deflate_de

; 194  : 
; 195  : 		SAFETY_CHECK(in_end - in_next >= 4);

  0062d	8b 45 d4	 mov	 eax, DWORD PTR _in_end$[ebp]
  00630	2b 45 e0	 sub	 eax, DWORD PTR _in_next$[ebp]
  00633	83 f8 04	 cmp	 eax, 4
  00636	7d 0a		 jge	 SHORT $LN110@deflate_de
  00638	b8 01 00 00 00	 mov	 eax, 1
  0063d	e9 82 09 00 00	 jmp	 $LN1@deflate_de
$LN110@deflate_de:

; 196  : 
; 197  : 		len = READ_U16();

  00642	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00645	50		 push	 eax
  00646	e8 00 00 00 00	 call	 _get_unaligned_le16
  0064b	83 c4 04	 add	 esp, 4
  0064e	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _tmp16$[ebp], ax
  00655	8b 4d e0	 mov	 ecx, DWORD PTR _in_next$[ebp]
  00658	83 c1 02	 add	 ecx, 2
  0065b	89 4d e0	 mov	 DWORD PTR _in_next$[ebp], ecx
  0065e	66 8b 95 50 ff
	ff ff		 mov	 dx, WORD PTR _tmp16$[ebp]
  00665	66 89 55 80	 mov	 WORD PTR _len$[ebp], dx

; 198  : 		nlen = READ_U16();

  00669	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  0066c	50		 push	 eax
  0066d	e8 00 00 00 00	 call	 _get_unaligned_le16
  00672	83 c4 04	 add	 esp, 4
  00675	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _tmp16$[ebp], ax
  0067c	8b 4d e0	 mov	 ecx, DWORD PTR _in_next$[ebp]
  0067f	83 c1 02	 add	 ecx, 2
  00682	89 4d e0	 mov	 DWORD PTR _in_next$[ebp], ecx
  00685	66 8b 95 50 ff
	ff ff		 mov	 dx, WORD PTR _tmp16$[ebp]
  0068c	66 89 95 74 ff
	ff ff		 mov	 WORD PTR _nlen$[ebp], dx

; 199  : 
; 200  : 		SAFETY_CHECK(len == (u16)~nlen);

  00693	0f b7 45 80	 movzx	 eax, WORD PTR _len$[ebp]
  00697	0f b7 8d 74 ff
	ff ff		 movzx	 ecx, WORD PTR _nlen$[ebp]
  0069e	f7 d1		 not	 ecx
  006a0	0f b7 d1	 movzx	 edx, cx
  006a3	3b c2		 cmp	 eax, edx
  006a5	74 0a		 je	 SHORT $LN111@deflate_de
  006a7	b8 01 00 00 00	 mov	 eax, 1
  006ac	e9 13 09 00 00	 jmp	 $LN1@deflate_de
$LN111@deflate_de:

; 201  : 		if (unlikely(len > out_end - out_next))

  006b1	0f b7 45 80	 movzx	 eax, WORD PTR _len$[ebp]
  006b5	8b 4d ec	 mov	 ecx, DWORD PTR _out_end$[ebp]
  006b8	2b 4d f8	 sub	 ecx, DWORD PTR _out_next$[ebp]
  006bb	3b c1		 cmp	 eax, ecx
  006bd	7e 0a		 jle	 SHORT $LN112@deflate_de

; 202  : 			return LIBDEFLATE_INSUFFICIENT_SPACE;

  006bf	b8 03 00 00 00	 mov	 eax, 3
  006c4	e9 fb 08 00 00	 jmp	 $LN1@deflate_de
$LN112@deflate_de:

; 203  : 		SAFETY_CHECK(len <= in_end - in_next);

  006c9	0f b7 45 80	 movzx	 eax, WORD PTR _len$[ebp]
  006cd	8b 4d d4	 mov	 ecx, DWORD PTR _in_end$[ebp]
  006d0	2b 4d e0	 sub	 ecx, DWORD PTR _in_next$[ebp]
  006d3	3b c1		 cmp	 eax, ecx
  006d5	7e 0a		 jle	 SHORT $LN113@deflate_de
  006d7	b8 01 00 00 00	 mov	 eax, 1
  006dc	e9 e3 08 00 00	 jmp	 $LN1@deflate_de
$LN113@deflate_de:

; 204  : 
; 205  : 		memcpy(out_next, in_next, len);

  006e1	0f b7 45 80	 movzx	 eax, WORD PTR _len$[ebp]
  006e5	50		 push	 eax
  006e6	8b 4d e0	 mov	 ecx, DWORD PTR _in_next$[ebp]
  006e9	51		 push	 ecx
  006ea	8b 55 f8	 mov	 edx, DWORD PTR _out_next$[ebp]
  006ed	52		 push	 edx
  006ee	e8 00 00 00 00	 call	 _memcpy
  006f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 206  : 		in_next += len;

  006f6	0f b7 45 80	 movzx	 eax, WORD PTR _len$[ebp]
  006fa	03 45 e0	 add	 eax, DWORD PTR _in_next$[ebp]
  006fd	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax

; 207  : 		out_next += len;

  00700	0f b7 45 80	 movzx	 eax, WORD PTR _len$[ebp]
  00704	03 45 f8	 add	 eax, DWORD PTR _out_next$[ebp]
  00707	89 45 f8	 mov	 DWORD PTR _out_next$[ebp], eax

; 208  : 
; 209  : 		goto block_done;

  0070a	e9 39 08 00 00	 jmp	 $block_done$155

; 210  : 
; 211  : 	} else {

  0070f	e9 e4 00 00 00	 jmp	 $LN89@deflate_de
$LN107@deflate_de:

; 212  : 		SAFETY_CHECK(block_type == DEFLATE_BLOCKTYPE_STATIC_HUFFMAN);

  00714	83 7d 8c 01	 cmp	 DWORD PTR _block_type$[ebp], 1
  00718	74 0a		 je	 SHORT $LN114@deflate_de
  0071a	b8 01 00 00 00	 mov	 eax, 1
  0071f	e9 a0 08 00 00	 jmp	 $LN1@deflate_de
$LN114@deflate_de:

; 213  : 
; 214  : 		/*
; 215  : 		 * Static Huffman block: build the decode tables for the static
; 216  : 		 * codes.  Skip doing so if the tables are already set up from
; 217  : 		 * an earlier static block; this speeds up decompression of
; 218  : 		 * degenerate input of many empty or very short static blocks.
; 219  : 		 *
; 220  : 		 * Afterwards, the remainder is the same as decompressing a
; 221  : 		 * dynamic Huffman block.
; 222  : 		 */
; 223  : 
; 224  : 		if (d->static_codes_loaded)

  00724	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00727	83 b8 60 1d 00
	00 00		 cmp	 DWORD PTR [eax+7520], 0
  0072e	74 05		 je	 SHORT $LN115@deflate_de

; 225  : 			goto have_decode_tables;

  00730	e9 13 01 00 00	 jmp	 $have_decode_tables$156
$LN115@deflate_de:

; 226  : 
; 227  : 		d->static_codes_loaded = true;

  00735	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00738	c7 80 60 1d 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7520], 1

; 228  : 
; 229  : 		STATIC_ASSERT(DEFLATE_NUM_LITLEN_SYMS == 288);
; 230  : 		STATIC_ASSERT(DEFLATE_NUM_OFFSET_SYMS == 32);
; 231  : 
; 232  : 		for (i = 0; i < 144; i++)

  00742	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00749	eb 09		 jmp	 SHORT $LN34@deflate_de
$LN32@deflate_de:
  0074b	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0074e	83 c0 01	 add	 eax, 1
  00751	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN34@deflate_de:
  00754	81 7d a4 90 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 144	; 00000090H
  0075b	73 0b		 jae	 SHORT $LN33@deflate_de

; 233  : 			d->u.l.lens[i] = 8;

  0075d	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00760	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00763	c6 00 08	 mov	 BYTE PTR [eax], 8
  00766	eb e3		 jmp	 SHORT $LN32@deflate_de
$LN33@deflate_de:

; 234  : 		for (; i < 256; i++)

  00768	eb 09		 jmp	 SHORT $LN37@deflate_de
$LN35@deflate_de:
  0076a	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0076d	83 c0 01	 add	 eax, 1
  00770	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN37@deflate_de:
  00773	81 7d a4 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  0077a	73 0b		 jae	 SHORT $LN36@deflate_de

; 235  : 			d->u.l.lens[i] = 9;

  0077c	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0077f	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  00782	c6 00 09	 mov	 BYTE PTR [eax], 9
  00785	eb e3		 jmp	 SHORT $LN35@deflate_de
$LN36@deflate_de:

; 236  : 		for (; i < 280; i++)

  00787	eb 09		 jmp	 SHORT $LN40@deflate_de
$LN38@deflate_de:
  00789	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0078c	83 c0 01	 add	 eax, 1
  0078f	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN40@deflate_de:
  00792	81 7d a4 18 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 280	; 00000118H
  00799	73 0b		 jae	 SHORT $LN39@deflate_de

; 237  : 			d->u.l.lens[i] = 7;

  0079b	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0079e	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  007a1	c6 00 07	 mov	 BYTE PTR [eax], 7
  007a4	eb e3		 jmp	 SHORT $LN38@deflate_de
$LN39@deflate_de:

; 238  : 		for (; i < 288; i++)

  007a6	eb 09		 jmp	 SHORT $LN43@deflate_de
$LN41@deflate_de:
  007a8	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  007ab	83 c0 01	 add	 eax, 1
  007ae	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN43@deflate_de:
  007b1	81 7d a4 20 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 288	; 00000120H
  007b8	73 0b		 jae	 SHORT $LN42@deflate_de

; 239  : 			d->u.l.lens[i] = 8;

  007ba	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  007bd	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  007c0	c6 00 08	 mov	 BYTE PTR [eax], 8
  007c3	eb e3		 jmp	 SHORT $LN41@deflate_de
$LN42@deflate_de:

; 240  : 
; 241  : 		for (; i < 288 + 32; i++)

  007c5	eb 09		 jmp	 SHORT $LN46@deflate_de
$LN44@deflate_de:
  007c7	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  007ca	83 c0 01	 add	 eax, 1
  007cd	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN46@deflate_de:
  007d0	81 7d a4 40 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 320	; 00000140H
  007d7	73 0b		 jae	 SHORT $LN45@deflate_de

; 242  : 			d->u.l.lens[i] = 5;

  007d9	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  007dc	03 45 a4	 add	 eax, DWORD PTR _i$[ebp]
  007df	c6 00 05	 mov	 BYTE PTR [eax], 5
  007e2	eb e3		 jmp	 SHORT $LN44@deflate_de
$LN45@deflate_de:

; 243  : 
; 244  : 		num_litlen_syms = 288;

  007e4	c7 85 68 ff ff
	ff 20 01 00 00	 mov	 DWORD PTR _num_litlen_syms$[ebp], 288 ; 00000120H

; 245  : 		num_offset_syms = 32;

  007ee	c7 85 5c ff ff
	ff 20 00 00 00	 mov	 DWORD PTR _num_offset_syms$[ebp], 32 ; 00000020H
$LN89@deflate_de:

; 246  : 	}
; 247  : 
; 248  : 	/* Decompressing a Huffman block (either dynamic or static)  */
; 249  : 
; 250  : 	SAFETY_CHECK(build_offset_decode_table(d, num_litlen_syms, num_offset_syms));

  007f8	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _num_offset_syms$[ebp]
  007fe	50		 push	 eax
  007ff	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _num_litlen_syms$[ebp]
  00805	51		 push	 ecx
  00806	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  00809	52		 push	 edx
  0080a	e8 00 00 00 00	 call	 _build_offset_decode_table
  0080f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00812	85 c0		 test	 eax, eax
  00814	75 0a		 jne	 SHORT $LN116@deflate_de
  00816	b8 01 00 00 00	 mov	 eax, 1
  0081b	e9 a4 07 00 00	 jmp	 $LN1@deflate_de
$LN116@deflate_de:

; 251  : 	SAFETY_CHECK(build_litlen_decode_table(d, num_litlen_syms, num_offset_syms));

  00820	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _num_offset_syms$[ebp]
  00826	50		 push	 eax
  00827	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _num_litlen_syms$[ebp]
  0082d	51		 push	 ecx
  0082e	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  00831	52		 push	 edx
  00832	e8 00 00 00 00	 call	 _build_litlen_decode_table
  00837	83 c4 0c	 add	 esp, 12			; 0000000cH
  0083a	85 c0		 test	 eax, eax
  0083c	75 0a		 jne	 SHORT $have_decode_tables$156
  0083e	b8 01 00 00 00	 mov	 eax, 1
  00843	e9 7c 07 00 00	 jmp	 $LN1@deflate_de
$have_decode_tables$156:

; 252  : have_decode_tables:
; 253  : 
; 254  : 	/* The main DEFLATE decode loop  */
; 255  : 	for (;;) {
; 256  : 		u32 entry;
; 257  : 		u32 length;
; 258  : 		u32 offset;
; 259  : 		const u8 *src;
; 260  : 		u8 *dst;
; 261  : 
; 262  : 		/* Decode a litlen symbol.  */
; 263  : 		ENSURE_BITS(DEFLATE_MAX_LITLEN_CODEWORD_LEN);

  00848	83 7d bc 0f	 cmp	 DWORD PTR _bitsleft$[ebp], 15 ; 0000000fH
  0084c	0f 83 85 00 00
	00		 jae	 $LN118@deflate_de
  00852	b8 01 00 00 00	 mov	 eax, 1
  00857	85 c0		 test	 eax, eax
  00859	74 40		 je	 SHORT $LN55@deflate_de
  0085b	8b 45 d4	 mov	 eax, DWORD PTR _in_end$[ebp]
  0085e	2b 45 e0	 sub	 eax, DWORD PTR _in_next$[ebp]
  00861	83 f8 04	 cmp	 eax, 4
  00864	72 35		 jb	 SHORT $LN55@deflate_de
$LN52@deflate_de:
  00866	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00869	50		 push	 eax
  0086a	e8 00 00 00 00	 call	 _get_unaligned_leword
  0086f	83 c4 04	 add	 esp, 4
  00872	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00875	d3 e0		 shl	 eax, cl
  00877	0b 45 c8	 or	 eax, DWORD PTR _bitbuf$[ebp]
  0087a	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  0087d	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00880	83 f0 1f	 xor	 eax, 31			; 0000001fH
  00883	c1 e8 03	 shr	 eax, 3
  00886	03 45 e0	 add	 eax, DWORD PTR _in_next$[ebp]
  00889	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  0088c	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  0088f	83 c8 18	 or	 eax, 24			; 00000018H
  00892	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  00895	33 c0		 xor	 eax, eax
  00897	75 cd		 jne	 SHORT $LN52@deflate_de
  00899	eb 3c		 jmp	 SHORT $LN118@deflate_de
$LN55@deflate_de:
  0089b	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  0089e	3b 45 d4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  008a1	74 1c		 je	 SHORT $LN121@deflate_de
  008a3	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  008a6	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  008a9	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  008ac	d3 e2		 shl	 edx, cl
  008ae	0b 55 c8	 or	 edx, DWORD PTR _bitbuf$[ebp]
  008b1	89 55 c8	 mov	 DWORD PTR _bitbuf$[ebp], edx
  008b4	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  008b7	83 c0 01	 add	 eax, 1
  008ba	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  008bd	eb 09		 jmp	 SHORT $LN122@deflate_de
$LN121@deflate_de:
  008bf	8b 45 b0	 mov	 eax, DWORD PTR _overrun_count$[ebp]
  008c2	83 c0 01	 add	 eax, 1
  008c5	89 45 b0	 mov	 DWORD PTR _overrun_count$[ebp], eax
$LN122@deflate_de:
  008c8	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  008cb	83 c0 08	 add	 eax, 8
  008ce	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  008d1	83 7d bc 17	 cmp	 DWORD PTR _bitsleft$[ebp], 23 ; 00000017H
  008d5	76 c4		 jbe	 SHORT $LN55@deflate_de
$LN118@deflate_de:

; 264  : 		entry = d->u.litlen_decode_table[BITS(LITLEN_TABLEBITS)];

  008d7	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  008da	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  008df	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  008e2	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  008e5	89 95 fc fe ff
	ff		 mov	 DWORD PTR _entry$6[ebp], edx

; 265  : 		if (entry & HUFFDEC_SUBTABLE_POINTER) {

  008eb	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  008f1	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  008f6	74 47		 je	 SHORT $LN123@deflate_de

; 266  : 			/* Litlen subtable required (uncommon case)  */
; 267  : 			REMOVE_BITS(LITLEN_TABLEBITS);

  008f8	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  008fb	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  008fe	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  00901	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00904	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  00907	89 4d bc	 mov	 DWORD PTR _bitsleft$[ebp], ecx

; 268  : 			entry = d->u.litlen_decode_table[

  0090a	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  00910	c1 e8 08	 shr	 eax, 8
  00913	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00918	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  0091e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00924	ba 01 00 00 00	 mov	 edx, 1
  00929	d3 e2		 shl	 edx, cl
  0092b	83 ea 01	 sub	 edx, 1
  0092e	23 55 c8	 and	 edx, DWORD PTR _bitbuf$[ebp]
  00931	03 c2		 add	 eax, edx
  00933	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00936	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00939	89 95 fc fe ff
	ff		 mov	 DWORD PTR _entry$6[ebp], edx
$LN123@deflate_de:

; 269  : 				((entry >> HUFFDEC_RESULT_SHIFT) & 0xFFFF) +
; 270  : 				BITS(entry & HUFFDEC_LENGTH_MASK)];
; 271  : 		}
; 272  : 		REMOVE_BITS(entry & HUFFDEC_LENGTH_MASK);

  0093f	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00945	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0094b	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  0094e	d3 e8		 shr	 eax, cl
  00950	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  00953	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00959	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0095f	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  00962	2b d1		 sub	 edx, ecx
  00964	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx

; 273  : 		if (entry & HUFFDEC_LITERAL) {

  00967	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  0096d	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00972	74 2e		 je	 SHORT $LN124@deflate_de

; 274  : 			/* Literal  */
; 275  : 			if (unlikely(out_next == out_end))

  00974	8b 45 f8	 mov	 eax, DWORD PTR _out_next$[ebp]
  00977	3b 45 ec	 cmp	 eax, DWORD PTR _out_end$[ebp]
  0097a	75 0a		 jne	 SHORT $LN125@deflate_de

; 276  : 				return LIBDEFLATE_INSUFFICIENT_SPACE;

  0097c	b8 03 00 00 00	 mov	 eax, 3
  00981	e9 3e 06 00 00	 jmp	 $LN1@deflate_de
$LN125@deflate_de:

; 277  : 			*out_next++ = (u8)(entry >> HUFFDEC_RESULT_SHIFT);

  00986	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  0098c	c1 e8 08	 shr	 eax, 8
  0098f	8b 4d f8	 mov	 ecx, DWORD PTR _out_next$[ebp]
  00992	88 01		 mov	 BYTE PTR [ecx], al
  00994	8b 55 f8	 mov	 edx, DWORD PTR _out_next$[ebp]
  00997	83 c2 01	 add	 edx, 1
  0099a	89 55 f8	 mov	 DWORD PTR _out_next$[ebp], edx

; 278  : 			continue;

  0099d	e9 a6 fe ff ff	 jmp	 $have_decode_tables$156
$LN124@deflate_de:

; 279  : 		}
; 280  : 
; 281  : 		/* Match or end-of-block  */
; 282  : 
; 283  : 		entry >>= HUFFDEC_RESULT_SHIFT;

  009a2	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  009a8	c1 e8 08	 shr	 eax, 8
  009ab	89 85 fc fe ff
	ff		 mov	 DWORD PTR _entry$6[ebp], eax

; 284  : 		ENSURE_BITS(MAX_ENSURE);

  009b1	83 7d bc 18	 cmp	 DWORD PTR _bitsleft$[ebp], 24 ; 00000018H
  009b5	0f 83 85 00 00
	00		 jae	 $LN126@deflate_de
  009bb	b8 01 00 00 00	 mov	 eax, 1
  009c0	85 c0		 test	 eax, eax
  009c2	74 40		 je	 SHORT $LN61@deflate_de
  009c4	8b 45 d4	 mov	 eax, DWORD PTR _in_end$[ebp]
  009c7	2b 45 e0	 sub	 eax, DWORD PTR _in_next$[ebp]
  009ca	83 f8 04	 cmp	 eax, 4
  009cd	72 35		 jb	 SHORT $LN61@deflate_de
$LN58@deflate_de:
  009cf	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  009d2	50		 push	 eax
  009d3	e8 00 00 00 00	 call	 _get_unaligned_leword
  009d8	83 c4 04	 add	 esp, 4
  009db	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  009de	d3 e0		 shl	 eax, cl
  009e0	0b 45 c8	 or	 eax, DWORD PTR _bitbuf$[ebp]
  009e3	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  009e6	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  009e9	83 f0 1f	 xor	 eax, 31			; 0000001fH
  009ec	c1 e8 03	 shr	 eax, 3
  009ef	03 45 e0	 add	 eax, DWORD PTR _in_next$[ebp]
  009f2	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  009f5	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  009f8	83 c8 18	 or	 eax, 24			; 00000018H
  009fb	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  009fe	33 c0		 xor	 eax, eax
  00a00	75 cd		 jne	 SHORT $LN58@deflate_de
  00a02	eb 3c		 jmp	 SHORT $LN126@deflate_de
$LN61@deflate_de:
  00a04	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00a07	3b 45 d4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  00a0a	74 1c		 je	 SHORT $LN129@deflate_de
  00a0c	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00a0f	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00a12	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00a15	d3 e2		 shl	 edx, cl
  00a17	0b 55 c8	 or	 edx, DWORD PTR _bitbuf$[ebp]
  00a1a	89 55 c8	 mov	 DWORD PTR _bitbuf$[ebp], edx
  00a1d	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00a20	83 c0 01	 add	 eax, 1
  00a23	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  00a26	eb 09		 jmp	 SHORT $LN130@deflate_de
$LN129@deflate_de:
  00a28	8b 45 b0	 mov	 eax, DWORD PTR _overrun_count$[ebp]
  00a2b	83 c0 01	 add	 eax, 1
  00a2e	89 45 b0	 mov	 DWORD PTR _overrun_count$[ebp], eax
$LN130@deflate_de:
  00a31	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00a34	83 c0 08	 add	 eax, 8
  00a37	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  00a3a	83 7d bc 17	 cmp	 DWORD PTR _bitsleft$[ebp], 23 ; 00000017H
  00a3e	76 c4		 jbe	 SHORT $LN61@deflate_de
$LN126@deflate_de:

; 285  : 
; 286  : 		/* Pop the extra length bits and add them to the length base to
; 287  : 		 * produce the full length.  */
; 288  : 		length = (entry >> HUFFDEC_LENGTH_BASE_SHIFT) +

  00a40	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00a46	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a4c	b8 01 00 00 00	 mov	 eax, 1
  00a51	d3 e0		 shl	 eax, cl
  00a53	83 e8 01	 sub	 eax, 1
  00a56	23 45 c8	 and	 eax, DWORD PTR _bitbuf$[ebp]
  00a59	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  00a5f	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00a65	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a6b	8b 55 c8	 mov	 edx, DWORD PTR _bitbuf$[ebp]
  00a6e	d3 ea		 shr	 edx, cl
  00a70	89 55 c8	 mov	 DWORD PTR _bitbuf$[ebp], edx
  00a73	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  00a79	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a7e	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00a81	2b c8		 sub	 ecx, eax
  00a83	89 4d bc	 mov	 DWORD PTR _bitsleft$[ebp], ecx
  00a86	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _entry$6[ebp]
  00a8c	c1 ea 08	 shr	 edx, 8
  00a8f	03 95 44 ff ff
	ff		 add	 edx, DWORD PTR _tmp32$[ebp]
  00a95	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _length$5[ebp], edx

; 289  : 			 POP_BITS(entry & HUFFDEC_EXTRA_LENGTH_BITS_MASK);
; 290  : 
; 291  : 		/* The match destination must not end after the end of the
; 292  : 		 * output buffer.  For efficiency, combine this check with the
; 293  : 		 * end-of-block check.  We're using 0 for the special
; 294  : 		 * end-of-block length, so subtract 1 and it turn it into
; 295  : 		 * SIZE_MAX.  */
; 296  : 		STATIC_ASSERT(HUFFDEC_END_OF_BLOCK_LENGTH == 0);
; 297  : 		if (unlikely((size_t)length - 1 >= out_end - out_next)) {

  00a9b	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _length$5[ebp]
  00aa1	83 e8 01	 sub	 eax, 1
  00aa4	8b 4d ec	 mov	 ecx, DWORD PTR _out_end$[ebp]
  00aa7	2b 4d f8	 sub	 ecx, DWORD PTR _out_next$[ebp]
  00aaa	3b c1		 cmp	 eax, ecx
  00aac	72 18		 jb	 SHORT $LN131@deflate_de

; 298  : 			if (unlikely(length != HUFFDEC_END_OF_BLOCK_LENGTH))

  00aae	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _length$5[ebp], 0
  00ab5	74 0a		 je	 SHORT $LN132@deflate_de

; 299  : 				return LIBDEFLATE_INSUFFICIENT_SPACE;

  00ab7	b8 03 00 00 00	 mov	 eax, 3
  00abc	e9 03 05 00 00	 jmp	 $LN1@deflate_de
$LN132@deflate_de:

; 300  : 			goto block_done;

  00ac1	e9 82 04 00 00	 jmp	 $block_done$155
$LN131@deflate_de:

; 301  : 		}
; 302  : 
; 303  : 		/* Decode the match offset.  */
; 304  : 
; 305  : 		entry = d->offset_decode_table[BITS(OFFSET_TABLEBITS)];

  00ac6	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  00ac9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ace	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00ad1	8b 94 81 d8 14
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+5336]
  00ad8	89 95 fc fe ff
	ff		 mov	 DWORD PTR _entry$6[ebp], edx

; 306  : 		if (entry & HUFFDEC_SUBTABLE_POINTER) {

  00ade	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  00ae4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00ae9	74 4b		 je	 SHORT $LN133@deflate_de

; 307  : 			/* Offset subtable required (uncommon case)  */
; 308  : 			REMOVE_BITS(OFFSET_TABLEBITS);

  00aeb	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  00aee	c1 e8 08	 shr	 eax, 8
  00af1	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  00af4	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00af7	83 e9 08	 sub	 ecx, 8
  00afa	89 4d bc	 mov	 DWORD PTR _bitsleft$[ebp], ecx

; 309  : 			entry = d->offset_decode_table[

  00afd	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  00b03	c1 e8 08	 shr	 eax, 8
  00b06	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00b0b	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00b11	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b17	ba 01 00 00 00	 mov	 edx, 1
  00b1c	d3 e2		 shl	 edx, cl
  00b1e	83 ea 01	 sub	 edx, 1
  00b21	23 55 c8	 and	 edx, DWORD PTR _bitbuf$[ebp]
  00b24	03 c2		 add	 eax, edx
  00b26	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00b29	8b 94 81 d8 14
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+5336]
  00b30	89 95 fc fe ff
	ff		 mov	 DWORD PTR _entry$6[ebp], edx
$LN133@deflate_de:

; 310  : 				((entry >> HUFFDEC_RESULT_SHIFT) & 0xFFFF) +
; 311  : 				BITS(entry & HUFFDEC_LENGTH_MASK)];
; 312  : 		}
; 313  : 		REMOVE_BITS(entry & HUFFDEC_LENGTH_MASK);

  00b36	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00b3c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b42	8b 45 c8	 mov	 eax, DWORD PTR _bitbuf$[ebp]
  00b45	d3 e8		 shr	 eax, cl
  00b47	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  00b4a	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00b50	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b56	8b 55 bc	 mov	 edx, DWORD PTR _bitsleft$[ebp]
  00b59	2b d1		 sub	 edx, ecx
  00b5b	89 55 bc	 mov	 DWORD PTR _bitsleft$[ebp], edx

; 314  : 		entry >>= HUFFDEC_RESULT_SHIFT;

  00b5e	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  00b64	c1 e8 08	 shr	 eax, 8
  00b67	89 85 fc fe ff
	ff		 mov	 DWORD PTR _entry$6[ebp], eax

; 315  : 
; 316  : 		STATIC_ASSERT(CAN_ENSURE(DEFLATE_MAX_EXTRA_LENGTH_BITS +
; 317  : 					 DEFLATE_MAX_OFFSET_CODEWORD_LEN) &&
; 318  : 			      CAN_ENSURE(DEFLATE_MAX_EXTRA_OFFSET_BITS));
; 319  : 		if (!CAN_ENSURE(DEFLATE_MAX_EXTRA_LENGTH_BITS +

  00b6d	b8 01 00 00 00	 mov	 eax, 1
  00b72	85 c0		 test	 eax, eax
  00b74	0f 84 8f 00 00
	00		 je	 $LN134@deflate_de

; 320  : 				DEFLATE_MAX_OFFSET_CODEWORD_LEN +
; 321  : 				DEFLATE_MAX_EXTRA_OFFSET_BITS))
; 322  : 			ENSURE_BITS(DEFLATE_MAX_EXTRA_OFFSET_BITS);

  00b7a	83 7d bc 0e	 cmp	 DWORD PTR _bitsleft$[ebp], 14 ; 0000000eH
  00b7e	0f 83 85 00 00
	00		 jae	 $LN134@deflate_de
  00b84	b8 01 00 00 00	 mov	 eax, 1
  00b89	85 c0		 test	 eax, eax
  00b8b	74 40		 je	 SHORT $LN67@deflate_de
  00b8d	8b 45 d4	 mov	 eax, DWORD PTR _in_end$[ebp]
  00b90	2b 45 e0	 sub	 eax, DWORD PTR _in_next$[ebp]
  00b93	83 f8 04	 cmp	 eax, 4
  00b96	72 35		 jb	 SHORT $LN67@deflate_de
$LN64@deflate_de:
  00b98	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00b9b	50		 push	 eax
  00b9c	e8 00 00 00 00	 call	 _get_unaligned_leword
  00ba1	83 c4 04	 add	 esp, 4
  00ba4	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00ba7	d3 e0		 shl	 eax, cl
  00ba9	0b 45 c8	 or	 eax, DWORD PTR _bitbuf$[ebp]
  00bac	89 45 c8	 mov	 DWORD PTR _bitbuf$[ebp], eax
  00baf	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00bb2	83 f0 1f	 xor	 eax, 31			; 0000001fH
  00bb5	c1 e8 03	 shr	 eax, 3
  00bb8	03 45 e0	 add	 eax, DWORD PTR _in_next$[ebp]
  00bbb	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  00bbe	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00bc1	83 c8 18	 or	 eax, 24			; 00000018H
  00bc4	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  00bc7	33 c0		 xor	 eax, eax
  00bc9	75 cd		 jne	 SHORT $LN64@deflate_de
  00bcb	eb 3c		 jmp	 SHORT $LN134@deflate_de
$LN67@deflate_de:
  00bcd	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00bd0	3b 45 d4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  00bd3	74 1c		 je	 SHORT $LN138@deflate_de
  00bd5	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00bd8	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00bdb	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00bde	d3 e2		 shl	 edx, cl
  00be0	0b 55 c8	 or	 edx, DWORD PTR _bitbuf$[ebp]
  00be3	89 55 c8	 mov	 DWORD PTR _bitbuf$[ebp], edx
  00be6	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00be9	83 c0 01	 add	 eax, 1
  00bec	89 45 e0	 mov	 DWORD PTR _in_next$[ebp], eax
  00bef	eb 09		 jmp	 SHORT $LN139@deflate_de
$LN138@deflate_de:
  00bf1	8b 45 b0	 mov	 eax, DWORD PTR _overrun_count$[ebp]
  00bf4	83 c0 01	 add	 eax, 1
  00bf7	89 45 b0	 mov	 DWORD PTR _overrun_count$[ebp], eax
$LN139@deflate_de:
  00bfa	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00bfd	83 c0 08	 add	 eax, 8
  00c00	89 45 bc	 mov	 DWORD PTR _bitsleft$[ebp], eax
  00c03	83 7d bc 17	 cmp	 DWORD PTR _bitsleft$[ebp], 23 ; 00000017H
  00c07	76 c4		 jbe	 SHORT $LN67@deflate_de
$LN134@deflate_de:

; 323  : 
; 324  : 		/* Pop the extra offset bits and add them to the offset base to
; 325  : 		 * produce the full offset.  */
; 326  : 		offset = (entry & HUFFDEC_OFFSET_BASE_MASK) +

  00c09	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00c0f	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00c12	b8 01 00 00 00	 mov	 eax, 1
  00c17	d3 e0		 shl	 eax, cl
  00c19	83 e8 01	 sub	 eax, 1
  00c1c	23 45 c8	 and	 eax, DWORD PTR _bitbuf$[ebp]
  00c1f	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tmp32$[ebp], eax
  00c25	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _entry$6[ebp]
  00c2b	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00c2e	8b 55 c8	 mov	 edx, DWORD PTR _bitbuf$[ebp]
  00c31	d3 ea		 shr	 edx, cl
  00c33	89 55 c8	 mov	 DWORD PTR _bitbuf$[ebp], edx
  00c36	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _entry$6[ebp]
  00c3c	c1 e8 10	 shr	 eax, 16			; 00000010H
  00c3f	8b 4d bc	 mov	 ecx, DWORD PTR _bitsleft$[ebp]
  00c42	2b c8		 sub	 ecx, eax
  00c44	89 4d bc	 mov	 DWORD PTR _bitsleft$[ebp], ecx
  00c47	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _entry$6[ebp]
  00c4d	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00c53	03 95 44 ff ff
	ff		 add	 edx, DWORD PTR _tmp32$[ebp]
  00c59	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _offset$4[ebp], edx

; 327  : 			 POP_BITS(entry >> HUFFDEC_EXTRA_OFFSET_BITS_SHIFT);
; 328  : 
; 329  : 		/* The match source must not begin before the beginning of the
; 330  : 		 * output buffer.  */
; 331  : 		SAFETY_CHECK(offset <= out_next - (const u8 *)out);

  00c5f	8b 45 f8	 mov	 eax, DWORD PTR _out_next$[ebp]
  00c62	2b 45 14	 sub	 eax, DWORD PTR _out$[ebp]
  00c65	39 85 e4 fe ff
	ff		 cmp	 DWORD PTR _offset$4[ebp], eax
  00c6b	76 0a		 jbe	 SHORT $LN140@deflate_de
  00c6d	b8 01 00 00 00	 mov	 eax, 1
  00c72	e9 4d 03 00 00	 jmp	 $LN1@deflate_de
$LN140@deflate_de:

; 332  : 
; 333  : 		/*
; 334  : 		 * Copy the match: 'length' bytes at 'out_next - offset' to
; 335  : 		 * 'out_next', possibly overlapping.  If the match doesn't end
; 336  : 		 * too close to the end of the buffer and offset >= WORDBYTES ||
; 337  : 		 * offset == 1, take a fast path which copies a word at a time
; 338  : 		 * -- potentially more than the length of the match, but that's
; 339  : 		 * fine as long as we check for enough extra space.
; 340  : 		 *
; 341  : 		 * The remaining cases are not performance-critical so are
; 342  : 		 * handled by a simple byte-by-byte copy.
; 343  : 		 */
; 344  : 
; 345  : 		src = out_next - offset;

  00c77	8b 45 f8	 mov	 eax, DWORD PTR _out_next$[ebp]
  00c7a	2b 85 e4 fe ff
	ff		 sub	 eax, DWORD PTR _offset$4[ebp]
  00c80	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], eax

; 346  : 		dst = out_next;

  00c86	8b 45 f8	 mov	 eax, DWORD PTR _out_next$[ebp]
  00c89	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax

; 347  : 		out_next += length;

  00c8f	8b 45 f8	 mov	 eax, DWORD PTR _out_next$[ebp]
  00c92	03 85 f0 fe ff
	ff		 add	 eax, DWORD PTR _length$5[ebp]
  00c98	89 45 f8	 mov	 DWORD PTR _out_next$[ebp], eax

; 348  : 
; 349  : 		if (UNALIGNED_ACCESS_IS_FAST &&

  00c9b	b8 01 00 00 00	 mov	 eax, 1
  00ca0	85 c0		 test	 eax, eax
  00ca2	0f 84 06 02 00
	00		 je	 $LN141@deflate_de
  00ca8	8b 45 ec	 mov	 eax, DWORD PTR _out_end$[ebp]
  00cab	2b 45 f8	 sub	 eax, DWORD PTR _out_next$[ebp]
  00cae	83 f8 09	 cmp	 eax, 9
  00cb1	0f 8c f7 01 00
	00		 jl	 $LN141@deflate_de

; 350  : 		    /* max overrun is writing 3 words for a min length match */
; 351  : 		    likely(out_end - out_next >=
; 352  : 			   3 * WORDBYTES - DEFLATE_MIN_MATCH_LEN)) {
; 353  : 			if (offset >= WORDBYTES) { /* words don't overlap? */

  00cb7	83 bd e4 fe ff
	ff 04		 cmp	 DWORD PTR _offset$4[ebp], 4
  00cbe	0f 82 ac 00 00
	00		 jb	 $LN143@deflate_de

; 354  : 				copy_word_unaligned(src, dst);

  00cc4	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00cca	50		 push	 eax
  00ccb	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00cd1	51		 push	 ecx
  00cd2	e8 00 00 00 00	 call	 _copy_word_unaligned
  00cd7	83 c4 08	 add	 esp, 8

; 355  : 				src += WORDBYTES;

  00cda	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _src$3[ebp]
  00ce0	83 c0 04	 add	 eax, 4
  00ce3	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], eax

; 356  : 				dst += WORDBYTES;

  00ce9	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00cef	83 c0 04	 add	 eax, 4
  00cf2	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax

; 357  : 				copy_word_unaligned(src, dst);

  00cf8	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00cfe	50		 push	 eax
  00cff	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00d05	51		 push	 ecx
  00d06	e8 00 00 00 00	 call	 _copy_word_unaligned
  00d0b	83 c4 08	 add	 esp, 8

; 358  : 				src += WORDBYTES;

  00d0e	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _src$3[ebp]
  00d14	83 c0 04	 add	 eax, 4
  00d17	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], eax

; 359  : 				dst += WORDBYTES;

  00d1d	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00d23	83 c0 04	 add	 eax, 4
  00d26	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax
$LN70@deflate_de:

; 360  : 				do {
; 361  : 					copy_word_unaligned(src, dst);

  00d2c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00d32	50		 push	 eax
  00d33	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00d39	51		 push	 ecx
  00d3a	e8 00 00 00 00	 call	 _copy_word_unaligned
  00d3f	83 c4 08	 add	 esp, 8

; 362  : 					src += WORDBYTES;

  00d42	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _src$3[ebp]
  00d48	83 c0 04	 add	 eax, 4
  00d4b	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], eax

; 363  : 					dst += WORDBYTES;

  00d51	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00d57	83 c0 04	 add	 eax, 4
  00d5a	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax

; 364  : 				} while (dst < out_next);

  00d60	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00d66	3b 45 f8	 cmp	 eax, DWORD PTR _out_next$[ebp]
  00d69	72 c1		 jb	 SHORT $LN70@deflate_de

; 365  : 			} else if (offset == 1) {

  00d6b	e9 39 01 00 00	 jmp	 $LN144@deflate_de
$LN143@deflate_de:
  00d70	83 bd e4 fe ff
	ff 01		 cmp	 DWORD PTR _offset$4[ebp], 1
  00d77	0f 85 97 00 00
	00		 jne	 $LN145@deflate_de

; 366  : 				/* RLE encoding of previous byte, common if the
; 367  : 				 * data contains many repeated bytes */
; 368  : 				machine_word_t v = repeat_byte(*src);

  00d7d	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _src$3[ebp]
  00d83	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00d86	51		 push	 ecx
  00d87	e8 00 00 00 00	 call	 _repeat_byte
  00d8c	83 c4 04	 add	 esp, 4
  00d8f	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _v$1[ebp], eax

; 369  : 
; 370  : 				store_word_unaligned(v, dst);

  00d95	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00d9b	50		 push	 eax
  00d9c	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _v$1[ebp]
  00da2	51		 push	 ecx
  00da3	e8 00 00 00 00	 call	 _store_machine_word_t_unaligned
  00da8	83 c4 08	 add	 esp, 8

; 371  : 				dst += WORDBYTES;

  00dab	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00db1	83 c0 04	 add	 eax, 4
  00db4	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax

; 372  : 				store_word_unaligned(v, dst);

  00dba	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00dc0	50		 push	 eax
  00dc1	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _v$1[ebp]
  00dc7	51		 push	 ecx
  00dc8	e8 00 00 00 00	 call	 _store_machine_word_t_unaligned
  00dcd	83 c4 08	 add	 esp, 8

; 373  : 				dst += WORDBYTES;

  00dd0	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00dd6	83 c0 04	 add	 eax, 4
  00dd9	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax
$LN73@deflate_de:

; 374  : 				do {
; 375  : 					store_word_unaligned(v, dst);

  00ddf	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00de5	50		 push	 eax
  00de6	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _v$1[ebp]
  00dec	51		 push	 ecx
  00ded	e8 00 00 00 00	 call	 _store_machine_word_t_unaligned
  00df2	83 c4 08	 add	 esp, 8

; 376  : 					dst += WORDBYTES;

  00df5	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00dfb	83 c0 04	 add	 eax, 4
  00dfe	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax

; 377  : 				} while (dst < out_next);

  00e04	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00e0a	3b 45 f8	 cmp	 eax, DWORD PTR _out_next$[ebp]
  00e0d	72 d0		 jb	 SHORT $LN73@deflate_de

; 378  : 			} else {

  00e0f	e9 95 00 00 00	 jmp	 $LN144@deflate_de
$LN145@deflate_de:

; 379  : 				*dst++ = *src++;

  00e14	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00e1a	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00e20	8a 11		 mov	 dl, BYTE PTR [ecx]
  00e22	88 10		 mov	 BYTE PTR [eax], dl
  00e24	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00e2a	83 c0 01	 add	 eax, 1
  00e2d	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax
  00e33	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00e39	83 c1 01	 add	 ecx, 1
  00e3c	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], ecx

; 380  : 				*dst++ = *src++;

  00e42	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00e48	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00e4e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00e50	88 10		 mov	 BYTE PTR [eax], dl
  00e52	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00e58	83 c0 01	 add	 eax, 1
  00e5b	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax
  00e61	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00e67	83 c1 01	 add	 ecx, 1
  00e6a	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], ecx
$LN76@deflate_de:

; 381  : 				do {
; 382  : 					*dst++ = *src++;

  00e70	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00e76	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00e7c	8a 11		 mov	 dl, BYTE PTR [ecx]
  00e7e	88 10		 mov	 BYTE PTR [eax], dl
  00e80	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00e86	83 c0 01	 add	 eax, 1
  00e89	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax
  00e8f	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00e95	83 c1 01	 add	 ecx, 1
  00e98	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], ecx

; 383  : 				} while (dst < out_next);

  00e9e	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00ea4	3b 45 f8	 cmp	 eax, DWORD PTR _out_next$[ebp]
  00ea7	72 c7		 jb	 SHORT $LN76@deflate_de
$LN144@deflate_de:

; 384  : 			}
; 385  : 		} else {

  00ea9	e9 95 00 00 00	 jmp	 $LN142@deflate_de
$LN141@deflate_de:

; 386  : 			STATIC_ASSERT(DEFLATE_MIN_MATCH_LEN == 3);
; 387  : 			*dst++ = *src++;

  00eae	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00eb4	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00eba	8a 11		 mov	 dl, BYTE PTR [ecx]
  00ebc	88 10		 mov	 BYTE PTR [eax], dl
  00ebe	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00ec4	83 c0 01	 add	 eax, 1
  00ec7	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax
  00ecd	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00ed3	83 c1 01	 add	 ecx, 1
  00ed6	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], ecx

; 388  : 			*dst++ = *src++;

  00edc	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00ee2	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00ee8	8a 11		 mov	 dl, BYTE PTR [ecx]
  00eea	88 10		 mov	 BYTE PTR [eax], dl
  00eec	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00ef2	83 c0 01	 add	 eax, 1
  00ef5	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax
  00efb	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00f01	83 c1 01	 add	 ecx, 1
  00f04	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], ecx
$LN79@deflate_de:

; 389  : 			do {
; 390  : 				*dst++ = *src++;

  00f0a	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00f10	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00f16	8a 11		 mov	 dl, BYTE PTR [ecx]
  00f18	88 10		 mov	 BYTE PTR [eax], dl
  00f1a	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00f20	83 c0 01	 add	 eax, 1
  00f23	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dst$2[ebp], eax
  00f29	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _src$3[ebp]
  00f2f	83 c1 01	 add	 ecx, 1
  00f32	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _src$3[ebp], ecx

; 391  : 			} while (dst < out_next);

  00f38	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _dst$2[ebp]
  00f3e	3b 45 f8	 cmp	 eax, DWORD PTR _out_next$[ebp]
  00f41	72 c7		 jb	 SHORT $LN79@deflate_de
$LN142@deflate_de:

; 392  : 		}
; 393  : 	}

  00f43	e9 00 f9 ff ff	 jmp	 $have_decode_tables$156
$block_done$155:

; 394  : 
; 395  : block_done:
; 396  : 	/* Finished decoding a block.  */
; 397  : 
; 398  : 	if (!is_final_block)

  00f48	83 7d 98 00	 cmp	 DWORD PTR _is_final_block$[ebp], 0
  00f4c	75 05		 jne	 SHORT $LN82@deflate_de

; 399  : 		goto next_block;

  00f4e	e9 08 f1 ff ff	 jmp	 $next_block$154
$LN82@deflate_de:

; 400  : 
; 401  : 	/* That was the last block.  */
; 402  : 
; 403  : 	/* Discard any readahead bits and check for excessive overread */
; 404  : 	ALIGN_INPUT();

  00f53	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00f56	c1 e8 03	 shr	 eax, 3
  00f59	39 45 b0	 cmp	 DWORD PTR _overrun_count$[ebp], eax
  00f5c	76 07		 jbe	 SHORT $LN148@deflate_de
  00f5e	b8 01 00 00 00	 mov	 eax, 1
  00f63	eb 5f		 jmp	 SHORT $LN1@deflate_de
$LN148@deflate_de:
  00f65	8b 45 bc	 mov	 eax, DWORD PTR _bitsleft$[ebp]
  00f68	c1 e8 03	 shr	 eax, 3
  00f6b	2b 45 b0	 sub	 eax, DWORD PTR _overrun_count$[ebp]
  00f6e	8b 4d e0	 mov	 ecx, DWORD PTR _in_next$[ebp]
  00f71	2b c8		 sub	 ecx, eax
  00f73	89 4d e0	 mov	 DWORD PTR _in_next$[ebp], ecx
  00f76	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _overrun_count$[ebp], 0
  00f7d	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _bitbuf$[ebp], 0
  00f84	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _bitsleft$[ebp], 0
  00f8b	33 c0		 xor	 eax, eax
  00f8d	75 c4		 jne	 SHORT $LN82@deflate_de

; 405  : 
; 406  : 	/* Optionally return the actual number of bytes read */
; 407  : 	if (actual_in_nbytes_ret)

  00f8f	83 7d 1c 00	 cmp	 DWORD PTR _actual_in_nbytes_ret$[ebp], 0
  00f93	74 0b		 je	 SHORT $LN149@deflate_de

; 408  : 		*actual_in_nbytes_ret = in_next - (u8 *)in;

  00f95	8b 45 e0	 mov	 eax, DWORD PTR _in_next$[ebp]
  00f98	2b 45 0c	 sub	 eax, DWORD PTR _in$[ebp]
  00f9b	8b 4d 1c	 mov	 ecx, DWORD PTR _actual_in_nbytes_ret$[ebp]
  00f9e	89 01		 mov	 DWORD PTR [ecx], eax
$LN149@deflate_de:

; 409  : 
; 410  : 	/* Optionally return the actual number of bytes written */
; 411  : 	if (actual_out_nbytes_ret) {

  00fa0	83 7d 20 00	 cmp	 DWORD PTR _actual_out_nbytes_ret$[ebp], 0
  00fa4	74 0d		 je	 SHORT $LN150@deflate_de

; 412  : 		*actual_out_nbytes_ret = out_next - (u8 *)out;

  00fa6	8b 45 f8	 mov	 eax, DWORD PTR _out_next$[ebp]
  00fa9	2b 45 14	 sub	 eax, DWORD PTR _out$[ebp]
  00fac	8b 4d 20	 mov	 ecx, DWORD PTR _actual_out_nbytes_ret$[ebp]
  00faf	89 01		 mov	 DWORD PTR [ecx], eax

; 413  : 	} else {

  00fb1	eb 0f		 jmp	 SHORT $LN151@deflate_de
$LN150@deflate_de:

; 414  : 		if (out_next != out_end)

  00fb3	8b 45 f8	 mov	 eax, DWORD PTR _out_next$[ebp]
  00fb6	3b 45 ec	 cmp	 eax, DWORD PTR _out_end$[ebp]
  00fb9	74 07		 je	 SHORT $LN151@deflate_de

; 415  : 			return LIBDEFLATE_SHORT_OUTPUT;

  00fbb	b8 02 00 00 00	 mov	 eax, 2
  00fc0	eb 02		 jmp	 SHORT $LN1@deflate_de
$LN151@deflate_de:

; 416  : 	}
; 417  : 	return LIBDEFLATE_SUCCESS;

  00fc2	33 c0		 xor	 eax, eax
$LN1@deflate_de:

; 418  : }

  00fc4	5f		 pop	 edi
  00fc5	5e		 pop	 esi
  00fc6	5b		 pop	 ebx
  00fc7	81 c4 04 02 00
	00		 add	 esp, 516		; 00000204H
  00fcd	3b ec		 cmp	 ebp, esp
  00fcf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00fd4	8b e5		 mov	 esp, ebp
  00fd6	5d		 pop	 ebp
  00fd7	c3		 ret	 0
_deflate_decompress_default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _copy_word_unaligned
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_copy_word_unaligned PROC				; COMDAT

; 885  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 886  : 	store_word_unaligned(load_word_unaligned(src), dst);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dst$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  00035	83 c4 04	 add	 esp, 4
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _store_machine_word_t_unaligned
  0003e	83 c4 08	 add	 esp, 8

; 887  : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_copy_word_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _repeat_byte
_TEXT	SEGMENT
_v$ = -8						; size = 4
_b$ = 8							; size = 1
_repeat_byte PROC					; COMDAT

; 871  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 872  : 	machine_word_t v;
; 873  : 
; 874  : 	STATIC_ASSERT(WORDBITS == 32 || WORDBITS == 64);
; 875  : 
; 876  : 	v = b;

  00028	0f b6 45 08	 movzx	 eax, BYTE PTR _b$[ebp]
  0002c	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax

; 877  : 	v |= v << 8;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  00032	c1 e0 08	 shl	 eax, 8
  00035	0b 45 f8	 or	 eax, DWORD PTR _v$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax

; 878  : 	v |= v << 16;

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0003e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00041	0b 45 f8	 or	 eax, DWORD PTR _v$[ebp]
  00044	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax

; 879  : 	v |= v << ((WORDBITS == 64) ? 32 : 0);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0004a	0b 45 f8	 or	 eax, DWORD PTR _v$[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax

; 880  : 	return v;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]

; 881  : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_repeat_byte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _build_offset_decode_table
_TEXT	SEGMENT
_d$ = 8							; size = 4
_num_litlen_syms$ = 12					; size = 4
_num_offset_syms$ = 16					; size = 4
_build_offset_decode_table PROC				; COMDAT

; 856  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 857  : 	/* When you change TABLEBITS, you must change ENOUGH, and vice versa! */
; 858  : 	STATIC_ASSERT(OFFSET_TABLEBITS == 8 && OFFSET_ENOUGH == 402);
; 859  : 
; 860  : 	return build_decode_table(d->offset_decode_table,

  00028	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0002b	05 20 1b 00 00	 add	 eax, 6944		; 00001b20H
  00030	50		 push	 eax
  00031	6a 0f		 push	 15			; 0000000fH
  00033	6a 08		 push	 8
  00035	68 00 00 00 00	 push	 OFFSET _offset_decode_results
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _num_offset_syms$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  00041	03 55 0c	 add	 edx, DWORD PTR _num_litlen_syms$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00048	05 d8 14 00 00	 add	 eax, 5336		; 000014d8H
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _build_decode_table
  00053	83 c4 1c	 add	 esp, 28			; 0000001cH

; 861  : 				  d->u.l.lens + num_litlen_syms,
; 862  : 				  num_offset_syms,
; 863  : 				  offset_decode_results,
; 864  : 				  OFFSET_TABLEBITS,
; 865  : 				  DEFLATE_MAX_OFFSET_CODEWORD_LEN,
; 866  : 				  d->sorted_syms);
; 867  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_build_offset_decode_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _build_litlen_decode_table
_TEXT	SEGMENT
_d$ = 8							; size = 4
_num_litlen_syms$ = 12					; size = 4
_num_offset_syms$ = 16					; size = 4
_build_litlen_decode_table PROC				; COMDAT

; 839  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 840  : 	/* When you change TABLEBITS, you must change ENOUGH, and vice versa! */
; 841  : 	STATIC_ASSERT(LITLEN_TABLEBITS == 10 && LITLEN_ENOUGH == 1334);
; 842  : 
; 843  : 	return build_decode_table(d->u.litlen_decode_table,

  00028	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0002b	05 20 1b 00 00	 add	 eax, 6944		; 00001b20H
  00030	50		 push	 eax
  00031	6a 0f		 push	 15			; 0000000fH
  00033	6a 0a		 push	 10			; 0000000aH
  00035	68 00 00 00 00	 push	 OFFSET _litlen_decode_results
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _num_litlen_syms$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _build_decode_table
  0004b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 844  : 				  d->u.l.lens,
; 845  : 				  num_litlen_syms,
; 846  : 				  litlen_decode_results,
; 847  : 				  LITLEN_TABLEBITS,
; 848  : 				  DEFLATE_MAX_LITLEN_CODEWORD_LEN,
; 849  : 				  d->sorted_syms);
; 850  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_build_litlen_decode_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _build_precode_decode_table
_TEXT	SEGMENT
_d$ = 8							; size = 4
_build_precode_decode_table PROC			; COMDAT

; 822  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 823  : 	/* When you change TABLEBITS, you must change ENOUGH, and vice versa! */
; 824  : 	STATIC_ASSERT(PRECODE_TABLEBITS == 7 && PRECODE_ENOUGH == 128);
; 825  : 
; 826  : 	return build_decode_table(d->u.l.precode_decode_table,

  00028	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0002b	05 20 1b 00 00	 add	 eax, 6944		; 00001b20H
  00030	50		 push	 eax
  00031	6a 07		 push	 7
  00033	6a 07		 push	 7
  00035	68 00 00 00 00	 push	 OFFSET _precode_decode_results
  0003a	6a 13		 push	 19			; 00000013H
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  00043	81 c2 cc 01 00
	00		 add	 edx, 460		; 000001ccH
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _build_decode_table
  0004f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 827  : 				  d->u.precode_lens,
; 828  : 				  DEFLATE_NUM_PRECODE_SYMS,
; 829  : 				  precode_decode_results,
; 830  : 				  PRECODE_TABLEBITS,
; 831  : 				  DEFLATE_MAX_PRE_CODEWORD_LEN,
; 832  : 				  d->sorted_syms);
; 833  : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_build_precode_decode_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _build_decode_table
_TEXT	SEGMENT
_bit$1 = -332						; size = 4
_stride$2 = -320					; size = 4
_i$3 = -308						; size = 4
_entry$4 = -296						; size = 4
_bit$5 = -284						; size = 4
_i$6 = -272						; size = 4
_entry$7 = -260						; size = 4
_subtable_bits$ = -248					; size = 4
_subtable_start$ = -236					; size = 4
_subtable_prefix$ = -224				; size = 4
_cur_table_end$ = -212					; size = 4
_codespace_used$ = -200					; size = 4
_count$ = -188						; size = 4
_len$ = -176						; size = 4
_codeword$ = -164					; size = 4
_sym$ = -152						; size = 4
_offsets$ = -140					; size = 64
_len_counts$ = -68					; size = 64
_decode_table$ = 8					; size = 4
_lens$ = 12						; size = 4
_num_syms$ = 16						; size = 4
_decode_results$ = 20					; size = 4
_table_bits$ = 24					; size = 4
_max_codeword_len$ = 28					; size = 4
_sorted_syms$ = 32					; size = 4
_build_decode_table PROC				; COMDAT

; 565  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-528]
  00012	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 566  : 	unsigned len_counts[DEFLATE_MAX_CODEWORD_LEN + 1];
; 567  : 	unsigned offsets[DEFLATE_MAX_CODEWORD_LEN + 1];
; 568  : 	unsigned sym;		/* current symbol */
; 569  : 	unsigned codeword;	/* current codeword, bit-reversed */
; 570  : 	unsigned len;		/* current codeword length in bits */
; 571  : 	unsigned count;		/* num codewords remaining with this length */
; 572  : 	u32 codespace_used;	/* codespace used out of '2^max_codeword_len' */
; 573  : 	unsigned cur_table_end; /* end index of current table */
; 574  : 	unsigned subtable_prefix; /* codeword prefix of current subtable */
; 575  : 	unsigned subtable_start;  /* start index of current subtable */
; 576  : 	unsigned subtable_bits;   /* log2 of current subtable length */
; 577  : 
; 578  : 	/* Count how many codewords have each length, including 0. */
; 579  : 	for (len = 0; len <= max_codeword_len; len++)

  00028	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _len$[ebp], 0
  00032	eb 0f		 jmp	 SHORT $LN4@build_deco
$LN2@build_deco:
  00034	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  0003a	83 c0 01	 add	 eax, 1
  0003d	89 85 50 ff ff
	ff		 mov	 DWORD PTR _len$[ebp], eax
$LN4@build_deco:
  00043	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00049	3b 45 1c	 cmp	 eax, DWORD PTR _max_codeword_len$[ebp]
  0004c	77 10		 ja	 SHORT $LN3@build_deco

; 580  : 		len_counts[len] = 0;

  0004e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00054	c7 44 85 bc 00
	00 00 00	 mov	 DWORD PTR _len_counts$[ebp+eax*4], 0
  0005c	eb d6		 jmp	 SHORT $LN2@build_deco
$LN3@build_deco:

; 581  : 	for (sym = 0; sym < num_syms; sym++)

  0005e	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _sym$[ebp], 0
  00068	eb 0f		 jmp	 SHORT $LN7@build_deco
$LN5@build_deco:
  0006a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _sym$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 85 68 ff ff
	ff		 mov	 DWORD PTR _sym$[ebp], eax
$LN7@build_deco:
  00079	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _sym$[ebp]
  0007f	3b 45 10	 cmp	 eax, DWORD PTR _num_syms$[ebp]
  00082	73 25		 jae	 SHORT $LN6@build_deco

; 582  : 		len_counts[lens[sym]]++;

  00084	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00087	03 85 68 ff ff
	ff		 add	 eax, DWORD PTR _sym$[ebp]
  0008d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00090	8b 54 8d bc	 mov	 edx, DWORD PTR _len_counts$[ebp+ecx*4]
  00094	83 c2 01	 add	 edx, 1
  00097	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  0009a	03 85 68 ff ff
	ff		 add	 eax, DWORD PTR _sym$[ebp]
  000a0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000a3	89 54 8d bc	 mov	 DWORD PTR _len_counts$[ebp+ecx*4], edx
  000a7	eb c1		 jmp	 SHORT $LN5@build_deco
$LN6@build_deco:

; 583  : 
; 584  : 	/*
; 585  : 	 * Sort the symbols primarily by increasing codeword length and
; 586  : 	 * secondarily by increasing symbol value; or equivalently by their
; 587  : 	 * codewords in lexicographic order, since a canonical code is assumed.
; 588  : 	 *
; 589  : 	 * For efficiency, also compute 'codespace_used' in the same pass over
; 590  : 	 * 'len_counts[]' used to build 'offsets[]' for sorting.
; 591  : 	 */
; 592  : 
; 593  : 	/* Ensure that 'codespace_used' cannot overflow. */
; 594  : 	STATIC_ASSERT(sizeof(codespace_used) == 4);
; 595  : 	STATIC_ASSERT(UINT32_MAX / (1U << (DEFLATE_MAX_CODEWORD_LEN - 1)) >=
; 596  : 		      DEFLATE_MAX_NUM_SYMS);
; 597  : 
; 598  : 	offsets[0] = 0;

  000a9	b8 04 00 00 00	 mov	 eax, 4
  000ae	6b c8 00	 imul	 ecx, eax, 0
  000b1	c7 84 0d 74 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _offsets$[ebp+ecx], 0

; 599  : 	offsets[1] = len_counts[0];

  000bc	b8 04 00 00 00	 mov	 eax, 4
  000c1	6b c8 00	 imul	 ecx, eax, 0
  000c4	ba 04 00 00 00	 mov	 edx, 4
  000c9	c1 e2 00	 shl	 edx, 0
  000cc	8b 44 0d bc	 mov	 eax, DWORD PTR _len_counts$[ebp+ecx]
  000d0	89 84 15 74 ff
	ff ff		 mov	 DWORD PTR _offsets$[ebp+edx], eax

; 600  : 	codespace_used = 0;

  000d7	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _codespace_used$[ebp], 0

; 601  : 	for (len = 1; len < max_codeword_len; len++) {

  000e1	c7 85 50 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _len$[ebp], 1
  000eb	eb 0f		 jmp	 SHORT $LN10@build_deco
$LN8@build_deco:
  000ed	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  000f3	83 c0 01	 add	 eax, 1
  000f6	89 85 50 ff ff
	ff		 mov	 DWORD PTR _len$[ebp], eax
$LN10@build_deco:
  000fc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00102	3b 45 1c	 cmp	 eax, DWORD PTR _max_codeword_len$[ebp]
  00105	73 3f		 jae	 SHORT $LN9@build_deco

; 602  : 		offsets[len + 1] = offsets[len] + len_counts[len];

  00107	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  0010d	8b 8c 85 74 ff
	ff ff		 mov	 ecx, DWORD PTR _offsets$[ebp+eax*4]
  00114	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _len$[ebp]
  0011a	03 4c 95 bc	 add	 ecx, DWORD PTR _len_counts$[ebp+edx*4]
  0011e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00124	89 8c 85 78 ff
	ff ff		 mov	 DWORD PTR _offsets$[ebp+eax*4+4], ecx

; 603  : 		codespace_used = (codespace_used << 1) + len_counts[len];

  0012b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00131	8b 4c 85 bc	 mov	 ecx, DWORD PTR _len_counts$[ebp+eax*4]
  00135	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _codespace_used$[ebp]
  0013b	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  0013e	89 85 38 ff ff
	ff		 mov	 DWORD PTR _codespace_used$[ebp], eax

; 604  : 	}

  00144	eb a7		 jmp	 SHORT $LN8@build_deco
$LN9@build_deco:

; 605  : 	codespace_used = (codespace_used << 1) + len_counts[len];

  00146	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  0014c	8b 4c 85 bc	 mov	 ecx, DWORD PTR _len_counts$[ebp+eax*4]
  00150	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _codespace_used$[ebp]
  00156	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00159	89 85 38 ff ff
	ff		 mov	 DWORD PTR _codespace_used$[ebp], eax

; 606  : 
; 607  : 	for (sym = 0; sym < num_syms; sym++)

  0015f	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _sym$[ebp], 0
  00169	eb 0f		 jmp	 SHORT $LN13@build_deco
$LN11@build_deco:
  0016b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _sym$[ebp]
  00171	83 c0 01	 add	 eax, 1
  00174	89 85 68 ff ff
	ff		 mov	 DWORD PTR _sym$[ebp], eax
$LN13@build_deco:
  0017a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _sym$[ebp]
  00180	3b 45 10	 cmp	 eax, DWORD PTR _num_syms$[ebp]
  00183	73 4c		 jae	 SHORT $LN12@build_deco

; 608  : 		sorted_syms[offsets[lens[sym]]++] = sym;

  00185	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00188	03 85 68 ff ff
	ff		 add	 eax, DWORD PTR _sym$[ebp]
  0018e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00191	8b 94 8d 74 ff
	ff ff		 mov	 edx, DWORD PTR _offsets$[ebp+ecx*4]
  00198	8b 45 20	 mov	 eax, DWORD PTR _sorted_syms$[ebp]
  0019b	66 8b 8d 68 ff
	ff ff		 mov	 cx, WORD PTR _sym$[ebp]
  001a2	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  001a6	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  001a9	03 95 68 ff ff
	ff		 add	 edx, DWORD PTR _sym$[ebp]
  001af	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001b2	8b 8c 85 74 ff
	ff ff		 mov	 ecx, DWORD PTR _offsets$[ebp+eax*4]
  001b9	83 c1 01	 add	 ecx, 1
  001bc	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  001bf	03 95 68 ff ff
	ff		 add	 edx, DWORD PTR _sym$[ebp]
  001c5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001c8	89 8c 85 74 ff
	ff ff		 mov	 DWORD PTR _offsets$[ebp+eax*4], ecx
  001cf	eb 9a		 jmp	 SHORT $LN11@build_deco
$LN12@build_deco:

; 609  : 
; 610  : 	sorted_syms += offsets[0]; /* Skip unused symbols */

  001d1	b8 04 00 00 00	 mov	 eax, 4
  001d6	6b c8 00	 imul	 ecx, eax, 0
  001d9	8b 94 0d 74 ff
	ff ff		 mov	 edx, DWORD PTR _offsets$[ebp+ecx]
  001e0	8b 45 20	 mov	 eax, DWORD PTR _sorted_syms$[ebp]
  001e3	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  001e6	89 4d 20	 mov	 DWORD PTR _sorted_syms$[ebp], ecx

; 611  : 
; 612  : 	/* lens[] is done being used, so we can write to decode_table[] now. */
; 613  : 
; 614  : 	/*
; 615  : 	 * Check whether the lengths form a complete code (exactly fills the
; 616  : 	 * codespace), an incomplete code (doesn't fill the codespace), or an
; 617  : 	 * overfull code (overflows the codespace).  A codeword of length 'n'
; 618  : 	 * uses proportion '1/(2^n)' of the codespace.  An overfull code is
; 619  : 	 * nonsensical, so is considered invalid.  An incomplete code is
; 620  : 	 * considered valid only in two specific cases; see below.
; 621  : 	 */
; 622  : 
; 623  : 	/* overfull code? */
; 624  : 	if (unlikely(codespace_used > (1U << max_codeword_len)))

  001e9	b8 01 00 00 00	 mov	 eax, 1
  001ee	8b 4d 1c	 mov	 ecx, DWORD PTR _max_codeword_len$[ebp]
  001f1	d3 e0		 shl	 eax, cl
  001f3	39 85 38 ff ff
	ff		 cmp	 DWORD PTR _codespace_used$[ebp], eax
  001f9	76 07		 jbe	 SHORT $LN40@build_deco

; 625  : 		return false;

  001fb	33 c0		 xor	 eax, eax
  001fd	e9 b6 04 00 00	 jmp	 $LN1@build_deco
$LN40@build_deco:

; 626  : 
; 627  : 	/* incomplete code? */
; 628  : 	if (unlikely(codespace_used < (1U << max_codeword_len))) {

  00202	b8 01 00 00 00	 mov	 eax, 1
  00207	8b 4d 1c	 mov	 ecx, DWORD PTR _max_codeword_len$[ebp]
  0020a	d3 e0		 shl	 eax, cl
  0020c	39 85 38 ff ff
	ff		 cmp	 DWORD PTR _codespace_used$[ebp], eax
  00212	0f 83 ad 00 00
	00		 jae	 $LN41@build_deco

; 629  : 		u32 entry;
; 630  : 		unsigned i;
; 631  : 
; 632  : 		if (codespace_used == 0) {

  00218	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _codespace_used$[ebp], 0
  0021f	75 19		 jne	 SHORT $LN42@build_deco

; 633  : 			/*
; 634  : 			 * An empty code is allowed.  This can happen for the
; 635  : 			 * offset code in DEFLATE, since a dynamic Huffman block
; 636  : 			 * need not contain any matches.
; 637  : 			 */
; 638  : 
; 639  : 			/* sym=0, len=1 (arbitrary) */
; 640  : 			entry = decode_results[0] | 1;

  00221	b8 04 00 00 00	 mov	 eax, 4
  00226	6b c8 00	 imul	 ecx, eax, 0
  00229	8b 55 14	 mov	 edx, DWORD PTR _decode_results$[ebp]
  0022c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0022f	83 c8 01	 or	 eax, 1
  00232	89 85 fc fe ff
	ff		 mov	 DWORD PTR _entry$7[ebp], eax

; 641  : 		} else {

  00238	eb 40		 jmp	 SHORT $LN43@build_deco
$LN42@build_deco:

; 642  : 			/*
; 643  : 			 * Allow codes with a single used symbol, with codeword
; 644  : 			 * length 1.  The DEFLATE RFC is unclear regarding this
; 645  : 			 * case.  What zlib's decompressor does is permit this
; 646  : 			 * for the litlen and offset codes and assume the
; 647  : 			 * codeword is '0' rather than '1'.  We do the same
; 648  : 			 * except we allow this for precodes too, since there's
; 649  : 			 * no convincing reason to treat the codes differently.
; 650  : 			 * We also assign both codewords '0' and '1' to the
; 651  : 			 * symbol to avoid having to handle '1' specially.
; 652  : 			 */
; 653  : 			if (codespace_used != (1U << (max_codeword_len - 1)) ||

  0023a	8b 4d 1c	 mov	 ecx, DWORD PTR _max_codeword_len$[ebp]
  0023d	83 e9 01	 sub	 ecx, 1
  00240	b8 01 00 00 00	 mov	 eax, 1
  00245	d3 e0		 shl	 eax, cl
  00247	39 85 38 ff ff
	ff		 cmp	 DWORD PTR _codespace_used$[ebp], eax
  0024d	75 0f		 jne	 SHORT $LN45@build_deco
  0024f	b8 04 00 00 00	 mov	 eax, 4
  00254	c1 e0 00	 shl	 eax, 0
  00257	83 7c 05 bc 01	 cmp	 DWORD PTR _len_counts$[ebp+eax], 1
  0025c	74 07		 je	 SHORT $LN44@build_deco
$LN45@build_deco:

; 654  : 			    len_counts[1] != 1)
; 655  : 				return false;

  0025e	33 c0		 xor	 eax, eax
  00260	e9 53 04 00 00	 jmp	 $LN1@build_deco
$LN44@build_deco:

; 656  : 			entry = decode_results[*sorted_syms] | 1;

  00265	8b 45 20	 mov	 eax, DWORD PTR _sorted_syms$[ebp]
  00268	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0026b	8b 55 14	 mov	 edx, DWORD PTR _decode_results$[ebp]
  0026e	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00271	83 c8 01	 or	 eax, 1
  00274	89 85 fc fe ff
	ff		 mov	 DWORD PTR _entry$7[ebp], eax
$LN43@build_deco:

; 657  : 		}
; 658  : 		/*
; 659  : 		 * Note: the decode table still must be fully initialized, in
; 660  : 		 * case the stream is malformed and contains bits from the part
; 661  : 		 * of the codespace the incomplete code doesn't use.
; 662  : 		 */
; 663  : 		for (i = 0; i < (1U << table_bits); i++)

  0027a	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$6[ebp], 0
  00284	eb 0f		 jmp	 SHORT $LN16@build_deco
$LN14@build_deco:
  00286	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _i$6[ebp]
  0028c	83 c0 01	 add	 eax, 1
  0028f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _i$6[ebp], eax
$LN16@build_deco:
  00295	b8 01 00 00 00	 mov	 eax, 1
  0029a	8b 4d 18	 mov	 ecx, DWORD PTR _table_bits$[ebp]
  0029d	d3 e0		 shl	 eax, cl
  0029f	39 85 f0 fe ff
	ff		 cmp	 DWORD PTR _i$6[ebp], eax
  002a5	73 14		 jae	 SHORT $LN15@build_deco

; 664  : 			decode_table[i] = entry;

  002a7	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _i$6[ebp]
  002ad	8b 4d 08	 mov	 ecx, DWORD PTR _decode_table$[ebp]
  002b0	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _entry$7[ebp]
  002b6	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  002b9	eb cb		 jmp	 SHORT $LN14@build_deco
$LN15@build_deco:

; 665  : 		return true;

  002bb	b8 01 00 00 00	 mov	 eax, 1
  002c0	e9 f3 03 00 00	 jmp	 $LN1@build_deco
$LN41@build_deco:

; 666  : 	}
; 667  : 
; 668  : 	/*
; 669  : 	 * The lengths form a complete code.  Now, enumerate the codewords in
; 670  : 	 * lexicographic order and fill the decode table entries for each one.
; 671  : 	 *
; 672  : 	 * First, process all codewords with len <= table_bits.  Each one gets
; 673  : 	 * '2^(table_bits-len)' direct entries in the table.
; 674  : 	 *
; 675  : 	 * Since DEFLATE uses bit-reversed codewords, these entries aren't
; 676  : 	 * consecutive but rather are spaced '2^len' entries apart.  This makes
; 677  : 	 * filling them naively somewhat awkward and inefficient, since strided
; 678  : 	 * stores are less cache-friendly and preclude the use of word or
; 679  : 	 * vector-at-a-time stores to fill multiple entries per instruction.
; 680  : 	 *
; 681  : 	 * To optimize this, we incrementally double the table size.  When
; 682  : 	 * processing codewords with length 'len', the table is treated as
; 683  : 	 * having only '2^len' entries, so each codeword uses just one entry.
; 684  : 	 * Then, each time 'len' is incremented, the table size is doubled and
; 685  : 	 * the first half is copied to the second half.  This significantly
; 686  : 	 * improves performance over naively doing strided stores.
; 687  : 	 *
; 688  : 	 * Note that some entries copied for each table doubling may not have
; 689  : 	 * been initialized yet, but it doesn't matter since they're guaranteed
; 690  : 	 * to be initialized later (because the Huffman code is complete).
; 691  : 	 */
; 692  : 	codeword = 0;

  002c5	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _codeword$[ebp], 0

; 693  : 	len = 1;

  002cf	c7 85 50 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _len$[ebp], 1
$LN17@build_deco:

; 694  : 	while ((count = len_counts[len]) == 0)

  002d9	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  002df	8b 4c 85 bc	 mov	 ecx, DWORD PTR _len_counts$[ebp+eax*4]
  002e3	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _count$[ebp], ecx
  002e9	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  002f0	75 11		 jne	 SHORT $LN18@build_deco

; 695  : 		len++;

  002f2	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  002f8	83 c0 01	 add	 eax, 1
  002fb	89 85 50 ff ff
	ff		 mov	 DWORD PTR _len$[ebp], eax
  00301	eb d6		 jmp	 SHORT $LN17@build_deco
$LN18@build_deco:

; 696  : 	cur_table_end = 1U << len;

  00303	b8 01 00 00 00	 mov	 eax, 1
  00308	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _len$[ebp]
  0030e	d3 e0		 shl	 eax, cl
  00310	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cur_table_end$[ebp], eax
$LN19@build_deco:

; 697  : 	while (len <= table_bits) {

  00316	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  0031c	3b 45 18	 cmp	 eax, DWORD PTR _table_bits$[ebp]
  0031f	0f 87 5d 01 00
	00		 ja	 $LN20@build_deco
$LN23@build_deco:

; 698  : 		/* Process all 'count' codewords with length 'len' bits. */
; 699  : 		do {
; 700  : 			unsigned bit;
; 701  : 
; 702  : 			/* Fill the first entry for the current codeword. */
; 703  : 			decode_table[codeword] =

  00325	8b 45 20	 mov	 eax, DWORD PTR _sorted_syms$[ebp]
  00328	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0032b	8b 55 14	 mov	 edx, DWORD PTR _decode_results$[ebp]
  0032e	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00331	0b 85 50 ff ff
	ff		 or	 eax, DWORD PTR _len$[ebp]
  00337	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _codeword$[ebp]
  0033d	8b 55 08	 mov	 edx, DWORD PTR _decode_table$[ebp]
  00340	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00343	8b 45 20	 mov	 eax, DWORD PTR _sorted_syms$[ebp]
  00346	83 c0 02	 add	 eax, 2
  00349	89 45 20	 mov	 DWORD PTR _sorted_syms$[ebp], eax

; 704  : 				decode_results[*sorted_syms++] | len;
; 705  : 
; 706  : 			if (codeword == cur_table_end - 1) {

  0034c	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cur_table_end$[ebp]
  00352	83 e8 01	 sub	 eax, 1
  00355	39 85 5c ff ff
	ff		 cmp	 DWORD PTR _codeword$[ebp], eax
  0035b	75 59		 jne	 SHORT $LN46@build_deco

; 707  : 				/* Last codeword (all 1's) */
; 708  : 				for (; len < table_bits; len++) {

  0035d	eb 0f		 jmp	 SHORT $LN26@build_deco
$LN24@build_deco:
  0035f	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00365	83 c0 01	 add	 eax, 1
  00368	89 85 50 ff ff
	ff		 mov	 DWORD PTR _len$[ebp], eax
$LN26@build_deco:
  0036e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00374	3b 45 18	 cmp	 eax, DWORD PTR _table_bits$[ebp]
  00377	73 33		 jae	 SHORT $LN25@build_deco

; 709  : 					memcpy(&decode_table[cur_table_end],

  00379	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cur_table_end$[ebp]
  0037f	c1 e0 02	 shl	 eax, 2
  00382	50		 push	 eax
  00383	8b 4d 08	 mov	 ecx, DWORD PTR _decode_table$[ebp]
  00386	51		 push	 ecx
  00387	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cur_table_end$[ebp]
  0038d	8b 45 08	 mov	 eax, DWORD PTR _decode_table$[ebp]
  00390	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00393	51		 push	 ecx
  00394	e8 00 00 00 00	 call	 _memcpy
  00399	83 c4 0c	 add	 esp, 12			; 0000000cH

; 710  : 					       decode_table,
; 711  : 					       cur_table_end *
; 712  : 						sizeof(decode_table[0]));
; 713  : 					cur_table_end <<= 1;

  0039c	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cur_table_end$[ebp]
  003a2	d1 e0		 shl	 eax, 1
  003a4	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cur_table_end$[ebp], eax

; 714  : 				}

  003aa	eb b3		 jmp	 SHORT $LN24@build_deco
$LN25@build_deco:

; 715  : 				return true;

  003ac	b8 01 00 00 00	 mov	 eax, 1
  003b1	e9 02 03 00 00	 jmp	 $LN1@build_deco
$LN46@build_deco:

; 716  : 			}
; 717  : 			/*
; 718  : 			 * To advance to the lexicographically next codeword in
; 719  : 			 * the canonical code, the codeword must be incremented,
; 720  : 			 * then 0's must be appended to the codeword as needed
; 721  : 			 * to match the next codeword's length.
; 722  : 			 *
; 723  : 			 * Since the codeword is bit-reversed, appending 0's is
; 724  : 			 * a no-op.  However, incrementing it is nontrivial.  To
; 725  : 			 * do so efficiently, use the 'bsr' instruction to find
; 726  : 			 * the last (highest order) 0 bit in the codeword, set
; 727  : 			 * it, and clear any later (higher order) 1 bits.  But
; 728  : 			 * 'bsr' actually finds the highest order 1 bit, so to
; 729  : 			 * use it first flip all bits in the codeword by XOR'ing
; 730  : 			 * it with (1U << len) - 1 == cur_table_end - 1.
; 731  : 			 */
; 732  : 			bit = 1U << bsr32(codeword ^ (cur_table_end - 1));

  003b6	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cur_table_end$[ebp]
  003bc	83 e8 01	 sub	 eax, 1
  003bf	33 85 5c ff ff
	ff		 xor	 eax, DWORD PTR _codeword$[ebp]
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 _bsr32
  003cb	83 c4 04	 add	 esp, 4
  003ce	ba 01 00 00 00	 mov	 edx, 1
  003d3	8b c8		 mov	 ecx, eax
  003d5	d3 e2		 shl	 edx, cl
  003d7	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _bit$5[ebp], edx

; 733  : 			codeword &= bit - 1;

  003dd	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _bit$5[ebp]
  003e3	83 e8 01	 sub	 eax, 1
  003e6	23 85 5c ff ff
	ff		 and	 eax, DWORD PTR _codeword$[ebp]
  003ec	89 85 5c ff ff
	ff		 mov	 DWORD PTR _codeword$[ebp], eax

; 734  : 			codeword |= bit;

  003f2	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _codeword$[ebp]
  003f8	0b 85 e4 fe ff
	ff		 or	 eax, DWORD PTR _bit$5[ebp]
  003fe	89 85 5c ff ff
	ff		 mov	 DWORD PTR _codeword$[ebp], eax

; 735  : 		} while (--count);

  00404	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  0040a	83 e8 01	 sub	 eax, 1
  0040d	89 85 44 ff ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
  00413	0f 85 0c ff ff
	ff		 jne	 $LN23@build_deco
$LN29@build_deco:

; 736  : 
; 737  : 		/* Advance to the next codeword length. */
; 738  : 		do {
; 739  : 			if (++len <= table_bits) {

  00419	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  0041f	83 c0 01	 add	 eax, 1
  00422	89 85 50 ff ff
	ff		 mov	 DWORD PTR _len$[ebp], eax
  00428	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _len$[ebp]
  0042e	3b 4d 18	 cmp	 ecx, DWORD PTR _table_bits$[ebp]
  00431	77 31		 ja	 SHORT $LN27@build_deco

; 740  : 				memcpy(&decode_table[cur_table_end],

  00433	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cur_table_end$[ebp]
  00439	c1 e0 02	 shl	 eax, 2
  0043c	50		 push	 eax
  0043d	8b 4d 08	 mov	 ecx, DWORD PTR _decode_table$[ebp]
  00440	51		 push	 ecx
  00441	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _cur_table_end$[ebp]
  00447	8b 45 08	 mov	 eax, DWORD PTR _decode_table$[ebp]
  0044a	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0044d	51		 push	 ecx
  0044e	e8 00 00 00 00	 call	 _memcpy
  00453	83 c4 0c	 add	 esp, 12			; 0000000cH

; 741  : 				       decode_table,
; 742  : 				       cur_table_end * sizeof(decode_table[0]));
; 743  : 				cur_table_end <<= 1;

  00456	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cur_table_end$[ebp]
  0045c	d1 e0		 shl	 eax, 1
  0045e	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cur_table_end$[ebp], eax
$LN27@build_deco:

; 744  : 			}
; 745  : 		} while ((count = len_counts[len]) == 0);

  00464	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  0046a	8b 4c 85 bc	 mov	 ecx, DWORD PTR _len_counts$[ebp+eax*4]
  0046e	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _count$[ebp], ecx
  00474	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  0047b	74 9c		 je	 SHORT $LN29@build_deco

; 746  : 	}

  0047d	e9 94 fe ff ff	 jmp	 $LN19@build_deco
$LN20@build_deco:

; 747  : 
; 748  : 	/* Process codewords with len > table_bits.  These require subtables. */
; 749  : 	cur_table_end = 1U << table_bits;

  00482	b8 01 00 00 00	 mov	 eax, 1
  00487	8b 4d 18	 mov	 ecx, DWORD PTR _table_bits$[ebp]
  0048a	d3 e0		 shl	 eax, cl
  0048c	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cur_table_end$[ebp], eax

; 750  : 	subtable_prefix = -1;

  00492	c7 85 20 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _subtable_prefix$[ebp], -1

; 751  : 	subtable_start = 0;

  0049c	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _subtable_start$[ebp], 0
$LN32@build_deco:

; 752  : 	for (;;) {
; 753  : 		u32 entry;
; 754  : 		unsigned i;
; 755  : 		unsigned stride;
; 756  : 		unsigned bit;
; 757  : 
; 758  : 		/*
; 759  : 		 * Start a new subtable if the first 'table_bits' bits of the
; 760  : 		 * codeword don't match the prefix of the current subtable.
; 761  : 		 */
; 762  : 		if ((codeword & ((1U << table_bits) - 1)) != subtable_prefix) {

  004a6	b8 01 00 00 00	 mov	 eax, 1
  004ab	8b 4d 18	 mov	 ecx, DWORD PTR _table_bits$[ebp]
  004ae	d3 e0		 shl	 eax, cl
  004b0	83 e8 01	 sub	 eax, 1
  004b3	23 85 5c ff ff
	ff		 and	 eax, DWORD PTR _codeword$[ebp]
  004b9	3b 85 20 ff ff
	ff		 cmp	 eax, DWORD PTR _subtable_prefix$[ebp]
  004bf	0f 84 bb 00 00
	00		 je	 $LN48@build_deco

; 763  : 			subtable_prefix = (codeword & ((1U << table_bits) - 1));

  004c5	b8 01 00 00 00	 mov	 eax, 1
  004ca	8b 4d 18	 mov	 ecx, DWORD PTR _table_bits$[ebp]
  004cd	d3 e0		 shl	 eax, cl
  004cf	83 e8 01	 sub	 eax, 1
  004d2	23 85 5c ff ff
	ff		 and	 eax, DWORD PTR _codeword$[ebp]
  004d8	89 85 20 ff ff
	ff		 mov	 DWORD PTR _subtable_prefix$[ebp], eax

; 764  : 			subtable_start = cur_table_end;

  004de	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _cur_table_end$[ebp]
  004e4	89 85 14 ff ff
	ff		 mov	 DWORD PTR _subtable_start$[ebp], eax

; 765  : 			/*
; 766  : 			 * Calculate the subtable length.  If the codeword has
; 767  : 			 * length 'table_bits + n', then the subtable needs
; 768  : 			 * '2^n' entries.  But it may need more; if fewer than
; 769  : 			 * '2^n' codewords of length 'table_bits + n' remain,
; 770  : 			 * then the length will need to be incremented to bring
; 771  : 			 * in longer codewords until the subtable can be
; 772  : 			 * completely filled.  Note that because the Huffman
; 773  : 			 * code is complete, it will always be possible to fill
; 774  : 			 * the subtable eventually.
; 775  : 			 */
; 776  : 			subtable_bits = len - table_bits;

  004ea	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  004f0	2b 45 18	 sub	 eax, DWORD PTR _table_bits$[ebp]
  004f3	89 85 08 ff ff
	ff		 mov	 DWORD PTR _subtable_bits$[ebp], eax

; 777  : 			codespace_used = count;

  004f9	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  004ff	89 85 38 ff ff
	ff		 mov	 DWORD PTR _codespace_used$[ebp], eax
$LN33@build_deco:

; 778  : 			while (codespace_used < (1U << subtable_bits)) {

  00505	b8 01 00 00 00	 mov	 eax, 1
  0050a	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _subtable_bits$[ebp]
  00510	d3 e0		 shl	 eax, cl
  00512	39 85 38 ff ff
	ff		 cmp	 DWORD PTR _codespace_used$[ebp], eax
  00518	73 2d		 jae	 SHORT $LN34@build_deco

; 779  : 				subtable_bits++;

  0051a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _subtable_bits$[ebp]
  00520	83 c0 01	 add	 eax, 1
  00523	89 85 08 ff ff
	ff		 mov	 DWORD PTR _subtable_bits$[ebp], eax

; 780  : 				codespace_used = (codespace_used << 1) +

  00529	8b 45 18	 mov	 eax, DWORD PTR _table_bits$[ebp]
  0052c	03 85 08 ff ff
	ff		 add	 eax, DWORD PTR _subtable_bits$[ebp]
  00532	8b 4c 85 bc	 mov	 ecx, DWORD PTR _len_counts$[ebp+eax*4]
  00536	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _codespace_used$[ebp]
  0053c	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  0053f	89 85 38 ff ff
	ff		 mov	 DWORD PTR _codespace_used$[ebp], eax

; 781  : 					len_counts[table_bits + subtable_bits];
; 782  : 			}

  00545	eb be		 jmp	 SHORT $LN33@build_deco
$LN34@build_deco:

; 783  : 			cur_table_end = subtable_start + (1U << subtable_bits);

  00547	b8 01 00 00 00	 mov	 eax, 1
  0054c	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _subtable_bits$[ebp]
  00552	d3 e0		 shl	 eax, cl
  00554	03 85 14 ff ff
	ff		 add	 eax, DWORD PTR _subtable_start$[ebp]
  0055a	89 85 2c ff ff
	ff		 mov	 DWORD PTR _cur_table_end$[ebp], eax

; 784  : 
; 785  : 			/*
; 786  : 			 * Create the entry that points from the main table to
; 787  : 			 * the subtable.  This entry contains the index of the
; 788  : 			 * start of the subtable and the number of bits with
; 789  : 			 * which the subtable is indexed (the log base 2 of the
; 790  : 			 * number of entries it contains).
; 791  : 			 */
; 792  : 			decode_table[subtable_prefix] =

  00560	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _subtable_start$[ebp]
  00566	c1 e0 08	 shl	 eax, 8
  00569	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  0056e	0b 85 08 ff ff
	ff		 or	 eax, DWORD PTR _subtable_bits$[ebp]
  00574	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _subtable_prefix$[ebp]
  0057a	8b 55 08	 mov	 edx, DWORD PTR _decode_table$[ebp]
  0057d	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN48@build_deco:

; 793  : 				HUFFDEC_SUBTABLE_POINTER |
; 794  : 				HUFFDEC_RESULT_ENTRY(subtable_start) |
; 795  : 				subtable_bits;
; 796  : 		}
; 797  : 
; 798  : 		/* Fill the subtable entries for the current codeword. */
; 799  : 		entry = decode_results[*sorted_syms++] | (len - table_bits);

  00580	8b 45 20	 mov	 eax, DWORD PTR _sorted_syms$[ebp]
  00583	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00586	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _len$[ebp]
  0058c	2b 55 18	 sub	 edx, DWORD PTR _table_bits$[ebp]
  0058f	8b 45 14	 mov	 eax, DWORD PTR _decode_results$[ebp]
  00592	0b 14 88	 or	 edx, DWORD PTR [eax+ecx*4]
  00595	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _entry$4[ebp], edx
  0059b	8b 4d 20	 mov	 ecx, DWORD PTR _sorted_syms$[ebp]
  0059e	83 c1 02	 add	 ecx, 2
  005a1	89 4d 20	 mov	 DWORD PTR _sorted_syms$[ebp], ecx

; 800  : 		i = subtable_start + (codeword >> table_bits);

  005a4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _codeword$[ebp]
  005aa	8b 4d 18	 mov	 ecx, DWORD PTR _table_bits$[ebp]
  005ad	d3 e8		 shr	 eax, cl
  005af	03 85 14 ff ff
	ff		 add	 eax, DWORD PTR _subtable_start$[ebp]
  005b5	89 85 cc fe ff
	ff		 mov	 DWORD PTR _i$3[ebp], eax

; 801  : 		stride = 1U << (len - table_bits);

  005bb	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _len$[ebp]
  005c1	2b 4d 18	 sub	 ecx, DWORD PTR _table_bits$[ebp]
  005c4	b8 01 00 00 00	 mov	 eax, 1
  005c9	d3 e0		 shl	 eax, cl
  005cb	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _stride$2[ebp], eax
$LN37@build_deco:

; 802  : 		do {
; 803  : 			decode_table[i] = entry;

  005d1	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  005d7	8b 4d 08	 mov	 ecx, DWORD PTR _decode_table$[ebp]
  005da	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _entry$4[ebp]
  005e0	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 804  : 			i += stride;

  005e3	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  005e9	03 85 c0 fe ff
	ff		 add	 eax, DWORD PTR _stride$2[ebp]
  005ef	89 85 cc fe ff
	ff		 mov	 DWORD PTR _i$3[ebp], eax

; 805  : 		} while (i < cur_table_end);

  005f5	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  005fb	3b 85 2c ff ff
	ff		 cmp	 eax, DWORD PTR _cur_table_end$[ebp]
  00601	72 ce		 jb	 SHORT $LN37@build_deco

; 806  : 
; 807  : 		/* Advance to the next codeword. */
; 808  : 		if (codeword == (1U << len) - 1) /* last codeword (all 1's)? */

  00603	b8 01 00 00 00	 mov	 eax, 1
  00608	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _len$[ebp]
  0060e	d3 e0		 shl	 eax, cl
  00610	83 e8 01	 sub	 eax, 1
  00613	39 85 5c ff ff
	ff		 cmp	 DWORD PTR _codeword$[ebp], eax
  00619	75 0a		 jne	 SHORT $LN49@build_deco

; 809  : 			return true;

  0061b	b8 01 00 00 00	 mov	 eax, 1
  00620	e9 93 00 00 00	 jmp	 $LN1@build_deco
$LN49@build_deco:

; 810  : 		bit = 1U << bsr32(codeword ^ ((1U << len) - 1));

  00625	b8 01 00 00 00	 mov	 eax, 1
  0062a	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _len$[ebp]
  00630	d3 e0		 shl	 eax, cl
  00632	83 e8 01	 sub	 eax, 1
  00635	33 85 5c ff ff
	ff		 xor	 eax, DWORD PTR _codeword$[ebp]
  0063b	50		 push	 eax
  0063c	e8 00 00 00 00	 call	 _bsr32
  00641	83 c4 04	 add	 esp, 4
  00644	ba 01 00 00 00	 mov	 edx, 1
  00649	8b c8		 mov	 ecx, eax
  0064b	d3 e2		 shl	 edx, cl
  0064d	89 95 b4 fe ff
	ff		 mov	 DWORD PTR _bit$1[ebp], edx

; 811  : 		codeword &= bit - 1;

  00653	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _bit$1[ebp]
  00659	83 e8 01	 sub	 eax, 1
  0065c	23 85 5c ff ff
	ff		 and	 eax, DWORD PTR _codeword$[ebp]
  00662	89 85 5c ff ff
	ff		 mov	 DWORD PTR _codeword$[ebp], eax

; 812  : 		codeword |= bit;

  00668	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _codeword$[ebp]
  0066e	0b 85 b4 fe ff
	ff		 or	 eax, DWORD PTR _bit$1[ebp]
  00674	89 85 5c ff ff
	ff		 mov	 DWORD PTR _codeword$[ebp], eax

; 813  : 		count--;

  0067a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00680	83 e8 01	 sub	 eax, 1
  00683	89 85 44 ff ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$LN38@build_deco:

; 814  : 		while (count == 0)

  00689	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00690	75 21		 jne	 SHORT $LN39@build_deco

; 815  : 			count = len_counts[++len];

  00692	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00698	83 c0 01	 add	 eax, 1
  0069b	89 85 50 ff ff
	ff		 mov	 DWORD PTR _len$[ebp], eax
  006a1	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _len$[ebp]
  006a7	8b 54 8d bc	 mov	 edx, DWORD PTR _len_counts$[ebp+ecx*4]
  006ab	89 95 44 ff ff
	ff		 mov	 DWORD PTR _count$[ebp], edx
  006b1	eb d6		 jmp	 SHORT $LN38@build_deco
$LN39@build_deco:

; 816  : 	}

  006b3	e9 ee fd ff ff	 jmp	 $LN32@build_deco
$LN1@build_deco:

; 817  : }

  006b8	52		 push	 edx
  006b9	8b cd		 mov	 ecx, ebp
  006bb	50		 push	 eax
  006bc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN54@build_deco
  006c2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006c7	58		 pop	 eax
  006c8	5a		 pop	 edx
  006c9	5f		 pop	 edi
  006ca	5e		 pop	 esi
  006cb	5b		 pop	 ebx
  006cc	81 c4 10 02 00
	00		 add	 esp, 528		; 00000210H
  006d2	3b ec		 cmp	 ebp, esp
  006d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006d9	8b e5		 mov	 esp, ebp
  006db	5d		 pop	 ebp
  006dc	c3		 ret	 0
  006dd	0f 1f 00	 npad	 3
$LN54@build_deco:
  006e0	02 00 00 00	 DD	 2
  006e4	00 00 00 00	 DD	 $LN53@build_deco
$LN53@build_deco:
  006e8	bc ff ff ff	 DD	 -68			; ffffffbcH
  006ec	40 00 00 00	 DD	 64			; 00000040H
  006f0	00 00 00 00	 DD	 $LN51@build_deco
  006f4	74 ff ff ff	 DD	 -140			; ffffff74H
  006f8	40 00 00 00	 DD	 64			; 00000040H
  006fc	00 00 00 00	 DD	 $LN52@build_deco
$LN52@build_deco:
  00700	6f		 DB	 111			; 0000006fH
  00701	66		 DB	 102			; 00000066H
  00702	66		 DB	 102			; 00000066H
  00703	73		 DB	 115			; 00000073H
  00704	65		 DB	 101			; 00000065H
  00705	74		 DB	 116			; 00000074H
  00706	73		 DB	 115			; 00000073H
  00707	00		 DB	 0
$LN51@build_deco:
  00708	6c		 DB	 108			; 0000006cH
  00709	65		 DB	 101			; 00000065H
  0070a	6e		 DB	 110			; 0000006eH
  0070b	5f		 DB	 95			; 0000005fH
  0070c	63		 DB	 99			; 00000063H
  0070d	6f		 DB	 111			; 0000006fH
  0070e	75		 DB	 117			; 00000075H
  0070f	6e		 DB	 110			; 0000006eH
  00710	74		 DB	 116			; 00000074H
  00711	73		 DB	 115			; 00000073H
  00712	00		 DB	 0
_build_decode_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _libdeflate_free_decompressor@4
_TEXT	SEGMENT
_d$ = 8							; size = 4
_libdeflate_free_decompressor@4 PROC			; COMDAT

; 995  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 996  : 	free(d);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 997  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
_libdeflate_free_decompressor@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _libdeflate_deflate_decompress_ex@28
_TEXT	SEGMENT
_d$ = 8							; size = 4
_in$ = 12						; size = 4
_in_nbytes$ = 16					; size = 4
_out$ = 20						; size = 4
_out_nbytes_avail$ = 24					; size = 4
_actual_in_nbytes_ret$ = 28				; size = 4
_actual_out_nbytes_ret$ = 32				; size = 4
_libdeflate_deflate_decompress_ex@28 PROC		; COMDAT

; 956  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 957  : 	return decompress_impl(d, in, in_nbytes, out, out_nbytes_avail,

  00028	8b 45 20	 mov	 eax, DWORD PTR _actual_out_nbytes_ret$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 1c	 mov	 ecx, DWORD PTR _actual_in_nbytes_ret$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 18	 mov	 edx, DWORD PTR _out_nbytes_avail$[ebp]
  00033	52		 push	 edx
  00034	8b 45 14	 mov	 eax, DWORD PTR _out$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 10	 mov	 ecx, DWORD PTR _in_nbytes$[ebp]
  0003b	51		 push	 ecx
  0003c	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  0003f	52		 push	 edx
  00040	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _deflate_decompress_default
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH

; 958  : 			       actual_in_nbytes_ret, actual_out_nbytes_ret);
; 959  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 1c 00	 ret	 28			; 0000001cH
_libdeflate_deflate_decompress_ex@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _libdeflate_deflate_decompress@24
_TEXT	SEGMENT
_d$ = 8							; size = 4
_in$ = 12						; size = 4
_in_nbytes$ = 16					; size = 4
_out$ = 20						; size = 4
_out_nbytes_avail$ = 24					; size = 4
_actual_out_nbytes_ret$ = 28				; size = 4
_libdeflate_deflate_decompress@24 PROC			; COMDAT

; 966  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 967  : 	return libdeflate_deflate_decompress_ex(d, in, in_nbytes,

  00028	8b 45 1c	 mov	 eax, DWORD PTR _actual_out_nbytes_ret$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	8b 4d 18	 mov	 ecx, DWORD PTR _out_nbytes_avail$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 14	 mov	 edx, DWORD PTR _out$[ebp]
  00035	52		 push	 edx
  00036	8b 45 10	 mov	 eax, DWORD PTR _in_nbytes$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 _libdeflate_deflate_decompress_ex@28

; 968  : 						out, out_nbytes_avail,
; 969  : 						NULL, actual_out_nbytes_ret);
; 970  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 18 00	 ret	 24			; 00000018H
_libdeflate_deflate_decompress@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_decompress.c
;	COMDAT _libdeflate_alloc_decompressor@0
_TEXT	SEGMENT
_libdeflate_alloc_decompressor@0 PROC			; COMDAT

; 974  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0DD5400E_deflate_decompress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 975  : 	/*
; 976  : 	 * Note that only certain parts of the decompressor actually must be
; 977  : 	 * initialized here:
; 978  : 	 *
; 979  : 	 * - 'static_codes_loaded' must be initialized to false.
; 980  : 	 *
; 981  : 	 * - The first half of the main portion of each decode table must be
; 982  : 	 *   initialized to any value, to avoid reading from uninitialized
; 983  : 	 *   memory during table expansion in build_decode_table().  (Although,
; 984  : 	 *   this is really just to avoid warnings with dynamic tools like
; 985  : 	 *   valgrind, since build_decode_table() is guaranteed to initialize
; 986  : 	 *   all entries eventually anyway.)
; 987  : 	 *
; 988  : 	 * But for simplicity, we currently just zero the whole decompressor.
; 989  : 	 */
; 990  : 	return calloc(1, sizeof(struct libdeflate_decompressor));

  00028	8b f4		 mov	 esi, esp
  0002a	68 64 1d 00 00	 push	 7524			; 00001d64H
  0002f	6a 01		 push	 1
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00037	83 c4 08	 add	 esp, 8
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 991  : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_libdeflate_alloc_decompressor@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _get_unaligned_leword
_TEXT	SEGMENT
_p$ = 8							; size = 4
_get_unaligned_leword PROC				; COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 80   : 	STATIC_ASSERT(WORDBITS == 32 || WORDBITS == 64);
; 81   : 	if (WORDBITS == 32)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 10		 je	 SHORT $LN2@get_unalig

; 82   : 		return get_unaligned_le32(p);

  00031	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _get_unaligned_le32
  0003a	83 c4 04	 add	 esp, 4
  0003d	eb 0e		 jmp	 SHORT $LN1@get_unalig
  0003f	eb 0c		 jmp	 SHORT $LN1@get_unalig
$LN2@get_unalig:

; 83   : 	else
; 84   : 		return get_unaligned_le64(p);

  00041	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _get_unaligned_le64
  0004a	83 c4 04	 add	 esp, 4
$LN1@get_unalig:

; 85   : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_get_unaligned_leword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _get_unaligned_le64
_TEXT	SEGMENT
_p$ = 8							; size = 4
_get_unaligned_le64 PROC				; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 68   : 	if (UNALIGNED_ACCESS_IS_FAST)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 16		 je	 SHORT $LN2@get_unalig

; 69   : 		return le64_bswap(load_u64_unaligned(p));

  00031	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _load_u64_unaligned
  0003a	83 c4 04	 add	 esp, 4
  0003d	e9 d9 00 00 00	 jmp	 $LN1@get_unalig
  00042	e9 d4 00 00 00	 jmp	 $LN1@get_unalig
$LN2@get_unalig:

; 70   : 	else
; 71   : 		return ((u64)p[7] << 56) | ((u64)p[6] << 48) |

  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	6b c8 07	 imul	 ecx, eax, 7
  0004f	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00052	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00056	99		 cdq
  00057	b1 38		 mov	 cl, 56			; 00000038H
  00059	e8 00 00 00 00	 call	 __allshl
  0005e	8b f0		 mov	 esi, eax
  00060	8b fa		 mov	 edi, edx
  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	6b c8 06	 imul	 ecx, eax, 6
  0006a	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0006d	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00071	99		 cdq
  00072	b1 30		 mov	 cl, 48			; 00000030H
  00074	e8 00 00 00 00	 call	 __allshl
  00079	0b f0		 or	 esi, eax
  0007b	0b fa		 or	 edi, edx
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	6b c8 05	 imul	 ecx, eax, 5
  00085	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00088	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0008c	99		 cdq
  0008d	b1 28		 mov	 cl, 40			; 00000028H
  0008f	e8 00 00 00 00	 call	 __allshl
  00094	0b f0		 or	 esi, eax
  00096	0b fa		 or	 edi, edx
  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	c1 e0 02	 shl	 eax, 2
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000a3	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  000a7	99		 cdq
  000a8	b1 20		 mov	 cl, 32			; 00000020H
  000aa	e8 00 00 00 00	 call	 __allshl
  000af	0b f0		 or	 esi, eax
  000b1	0b fa		 or	 edi, edx
  000b3	ba 01 00 00 00	 mov	 edx, 1
  000b8	6b c2 03	 imul	 eax, edx, 3
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000be	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  000c2	99		 cdq
  000c3	b1 18		 mov	 cl, 24			; 00000018H
  000c5	e8 00 00 00 00	 call	 __allshl
  000ca	0b f0		 or	 esi, eax
  000cc	0b fa		 or	 edi, edx
  000ce	ba 01 00 00 00	 mov	 edx, 1
  000d3	d1 e2		 shl	 edx, 1
  000d5	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000d8	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000dc	99		 cdq
  000dd	b1 10		 mov	 cl, 16			; 00000010H
  000df	e8 00 00 00 00	 call	 __allshl
  000e4	0b f0		 or	 esi, eax
  000e6	0b fa		 or	 edi, edx
  000e8	b9 01 00 00 00	 mov	 ecx, 1
  000ed	c1 e1 00	 shl	 ecx, 0
  000f0	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000f3	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000f7	99		 cdq
  000f8	b1 08		 mov	 cl, 8
  000fa	e8 00 00 00 00	 call	 __allshl
  000ff	0b f0		 or	 esi, eax
  00101	0b fa		 or	 edi, edx
  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	6b c8 00	 imul	 ecx, eax, 0
  0010b	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0010e	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00112	99		 cdq
  00113	0b f0		 or	 esi, eax
  00115	0b fa		 or	 edi, edx
  00117	8b c6		 mov	 eax, esi
  00119	8b d7		 mov	 edx, edi
$LN1@get_unalig:

; 72   : 			((u64)p[5] << 40) | ((u64)p[4] << 32) |
; 73   : 			((u64)p[3] << 24) | ((u64)p[2] << 16) |
; 74   : 			((u64)p[1] << 8) | p[0];
; 75   : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00124	3b ec		 cmp	 ebp, esp
  00126	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
_get_unaligned_le64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _get_unaligned_le32
_TEXT	SEGMENT
_p$ = 8							; size = 4
_get_unaligned_le32 PROC				; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 48   : 	if (UNALIGNED_ACCESS_IS_FAST)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 10		 je	 SHORT $LN2@get_unalig

; 49   : 		return le32_bswap(load_u32_unaligned(p));

  00031	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _load_u32_unaligned
  0003a	83 c4 04	 add	 esp, 4
  0003d	eb 4c		 jmp	 SHORT $LN1@get_unalig
  0003f	eb 4a		 jmp	 SHORT $LN1@get_unalig
$LN2@get_unalig:

; 50   : 	else
; 51   : 		return ((u32)p[3] << 24) | ((u32)p[2] << 16) |

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 03	 imul	 ecx, eax, 3
  00049	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0004c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00050	c1 e0 18	 shl	 eax, 24			; 00000018H
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	d1 e1		 shl	 ecx, 1
  0005a	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0005d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00061	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00064	0b c1		 or	 eax, ecx
  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	c1 e2 00	 shl	 edx, 0
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00071	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00075	c1 e2 08	 shl	 edx, 8
  00078	0b c2		 or	 eax, edx
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	6b d1 00	 imul	 edx, ecx, 0
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00085	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00089	0b c2		 or	 eax, edx
$LN1@get_unalig:

; 52   : 			((u32)p[1] << 8) | p[0];
; 53   : }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_get_unaligned_le32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _get_unaligned_le16
_TEXT	SEGMENT
_p$ = 8							; size = 4
_get_unaligned_le16 PROC				; COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 30   : 	if (UNALIGNED_ACCESS_IS_FAST)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 10		 je	 SHORT $LN2@get_unalig

; 31   : 		return le16_bswap(load_u16_unaligned(p));

  00031	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _load_u16_unaligned
  0003a	83 c4 04	 add	 esp, 4
  0003d	eb 25		 jmp	 SHORT $LN1@get_unalig
  0003f	eb 23		 jmp	 SHORT $LN1@get_unalig
$LN2@get_unalig:

; 32   : 	else
; 33   : 		return ((u16)p[1] << 8) | p[0];

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	c1 e0 00	 shl	 eax, 0
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00050	c1 e0 08	 shl	 eax, 8
  00053	ba 01 00 00 00	 mov	 edx, 1
  00058	6b ca 00	 imul	 ecx, edx, 0
  0005b	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0005e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00062	0b c1		 or	 eax, ecx
$LN1@get_unalig:

; 34   : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_get_unaligned_le16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _store_machine_word_t_unaligned
_TEXT	SEGMENT
_v$ = 8							; size = 4
_p$ = 12						; size = 4
_store_machine_word_t_unaligned PROC			; COMDAT

; 20   : DEFINE_UNALIGNED_TYPE(machine_word_t)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	6a 04		 push	 4
  0002a	8d 45 08	 lea	 eax, DWORD PTR _v$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_store_machine_word_t_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _load_machine_word_t_unaligned
_TEXT	SEGMENT
_v$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_load_machine_word_t_unaligned PROC			; COMDAT

; 20   : DEFINE_UNALIGNED_TYPE(machine_word_t)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	6a 04		 push	 4
  00034	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00037	50		 push	 eax
  00038	8d 4d f4	 lea	 ecx, DWORD PTR _v$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _memcpy
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  00047	52		 push	 edx
  00048	8b cd		 mov	 ecx, ebp
  0004a	50		 push	 eax
  0004b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@load_machi
  00051	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00056	58		 pop	 eax
  00057	5a		 pop	 edx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	33 cd		 xor	 ecx, ebp
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
  00076	66 90		 npad	 2
$LN5@load_machi:
  00078	01 00 00 00	 DD	 1
  0007c	00 00 00 00	 DD	 $LN4@load_machi
$LN4@load_machi:
  00080	f4 ff ff ff	 DD	 -12			; fffffff4H
  00084	04 00 00 00	 DD	 4
  00088	00 00 00 00	 DD	 $LN3@load_machi
$LN3@load_machi:
  0008c	76		 DB	 118			; 00000076H
  0008d	00		 DB	 0
_load_machine_word_t_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _load_u64_unaligned
_TEXT	SEGMENT
_v$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_load_u64_unaligned PROC				; COMDAT

; 19   : DEFINE_UNALIGNED_TYPE(u64)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	6a 08		 push	 8
  00034	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00037	50		 push	 eax
  00038	8d 4d f0	 lea	 ecx, DWORD PTR _v$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _memcpy
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	8b 45 f0	 mov	 eax, DWORD PTR _v$[ebp]
  00047	8b 55 f4	 mov	 edx, DWORD PTR _v$[ebp+4]
  0004a	52		 push	 edx
  0004b	8b cd		 mov	 ecx, ebp
  0004d	50		 push	 eax
  0004e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@load_u64_u
  00054	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00059	58		 pop	 eax
  0005a	5a		 pop	 edx
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
  00079	0f 1f 00	 npad	 3
$LN5@load_u64_u:
  0007c	01 00 00 00	 DD	 1
  00080	00 00 00 00	 DD	 $LN4@load_u64_u
$LN4@load_u64_u:
  00084	f0 ff ff ff	 DD	 -16			; fffffff0H
  00088	08 00 00 00	 DD	 8
  0008c	00 00 00 00	 DD	 $LN3@load_u64_u
$LN3@load_u64_u:
  00090	76		 DB	 118			; 00000076H
  00091	00		 DB	 0
_load_u64_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _load_u32_unaligned
_TEXT	SEGMENT
_v$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_load_u32_unaligned PROC				; COMDAT

; 18   : DEFINE_UNALIGNED_TYPE(u32)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	6a 04		 push	 4
  00034	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00037	50		 push	 eax
  00038	8d 4d f4	 lea	 ecx, DWORD PTR _v$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _memcpy
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  00047	52		 push	 edx
  00048	8b cd		 mov	 ecx, ebp
  0004a	50		 push	 eax
  0004b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@load_u32_u
  00051	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00056	58		 pop	 eax
  00057	5a		 pop	 edx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	33 cd		 xor	 ecx, ebp
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
  00076	66 90		 npad	 2
$LN5@load_u32_u:
  00078	01 00 00 00	 DD	 1
  0007c	00 00 00 00	 DD	 $LN4@load_u32_u
$LN4@load_u32_u:
  00080	f4 ff ff ff	 DD	 -12			; fffffff4H
  00084	04 00 00 00	 DD	 4
  00088	00 00 00 00	 DD	 $LN3@load_u32_u
$LN3@load_u32_u:
  0008c	76		 DB	 118			; 00000076H
  0008d	00		 DB	 0
_load_u32_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _load_u16_unaligned
_TEXT	SEGMENT
_v$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_load_u16_unaligned PROC				; COMDAT

; 17   : DEFINE_UNALIGNED_TYPE(u16)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	6a 02		 push	 2
  00034	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00037	50		 push	 eax
  00038	8d 4d f4	 lea	 ecx, DWORD PTR _v$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _memcpy
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	66 8b 45 f4	 mov	 ax, WORD PTR _v$[ebp]
  00048	52		 push	 edx
  00049	8b cd		 mov	 ecx, ebp
  0004b	50		 push	 eax
  0004c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@load_u16_u
  00052	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00057	58		 pop	 eax
  00058	5a		 pop	 edx
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
  00077	90		 npad	 1
$LN5@load_u16_u:
  00078	01 00 00 00	 DD	 1
  0007c	00 00 00 00	 DD	 $LN4@load_u16_u
$LN4@load_u16_u:
  00080	f4 ff ff ff	 DD	 -12			; fffffff4H
  00084	02 00 00 00	 DD	 2
  00088	00 00 00 00	 DD	 $LN3@load_u16_u
$LN3@load_u16_u:
  0008c	76		 DB	 118			; 00000076H
  0008d	00		 DB	 0
_load_u16_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\compiler_msc.h
;	COMDAT _bsr32
_TEXT	SEGMENT
_n$ = 8							; size = 4
_bsr32	PROC						; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __561309A6_compiler_msc@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 65   : 	_BitScanReverse(&n, n);

  00028	0f bd 45 08	 bsr	 eax, DWORD PTR _n$[ebp]
  0002c	89 45 08	 mov	 DWORD PTR _n$[ebp], eax

; 66   : 	return n;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]

; 67   : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_bsr32	ENDP
_TEXT	ENDS
END
