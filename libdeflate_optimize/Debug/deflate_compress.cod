; Listing generated by Microsoft (R) Optimizing Compiler Version 19.25.28612.0 

	TITLE	C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_deflate_length_slot_base
PUBLIC	_deflate_extra_length_bits
PUBLIC	_deflate_offset_slot_base
PUBLIC	_deflate_extra_offset_bits
PUBLIC	_deflate_length_slot
PUBLIC	_deflate_precode_lens_permutation
msvcjmc	SEGMENT
__367CC694_corecrt_memcpy_s@h DB 01H
__DC9673E3_corecrt_wstring@h DB 01H
__A29A7DFB_string@h DB 01H
__561309A6_compiler_msc@h DB 01H
__7CC618A3_common_defs@h DB 01H
__7DFAB971_unaligned@h DB 01H
__09230FC3_matchfinder_common@h DB 01H
__779A6228_hc_matchfinder@h DB 01H
__8C4EAA8D_deflate_compress@c DB 01H
msvcjmc	ENDS
CONST	SEGMENT
_deflate_length_slot_base DD 03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
_deflate_extra_length_bits DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	00H
	ORG $+7
_deflate_offset_slot_base DD 01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
_deflate_extra_offset_bits DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	ORG $+2
_deflate_length_slot DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	ORG $+1
_deflate_precode_lens_permutation DB 010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+1
?deflate_extra_precode_bits@?1??deflate_flush_block@@9@9 DB 00H ; `deflate_flush_block'::`2'::deflate_extra_precode_bits
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	03H
	DB	07H
CONST	ENDS
PUBLIC	_bsr64
PUBLIC	_bsrw
PUBLIC	_bsf64
PUBLIC	_bsfw
PUBLIC	__libdeflate_deflate_get_compression_level
PUBLIC	_store_u16_unaligned
PUBLIC	_load_u32_unaligned
PUBLIC	_store_u32_unaligned
PUBLIC	_store_u64_unaligned
PUBLIC	_load_machine_word_t_unaligned
PUBLIC	_get_unaligned_le32
PUBLIC	_put_unaligned_le16
PUBLIC	_put_unaligned_le32
PUBLIC	_put_unaligned_le64
PUBLIC	_put_unaligned_leword
PUBLIC	_loaded_u32_to_u24
PUBLIC	_load_u24_unaligned
PUBLIC	_libdeflate_alloc_compressor@4
PUBLIC	_libdeflate_deflate_compress@20
PUBLIC	_libdeflate_deflate_compress_bound@8
PUBLIC	_libdeflate_free_compressor@4
PUBLIC	_matchfinder_init
PUBLIC	_matchfinder_rebase
PUBLIC	_lz_hash
PUBLIC	_lz_extend
PUBLIC	_hc_matchfinder_init
PUBLIC	_hc_matchfinder_slide_window
PUBLIC	_hc_matchfinder_longest_match
PUBLIC	_hc_matchfinder_skip_positions
PUBLIC	_deflate_init_output
PUBLIC	_deflate_add_bits
PUBLIC	_deflate_flush_bits
PUBLIC	_deflate_align_bitstream
PUBLIC	_deflate_flush_output
PUBLIC	_heapify_subtree
PUBLIC	_heapify_array
PUBLIC	_heap_sort
PUBLIC	_sort_symbols
PUBLIC	_build_tree
PUBLIC	_compute_length_counts
PUBLIC	_gen_codewords
PUBLIC	_make_canonical_huffman_code
PUBLIC	_deflate_reset_symbol_frequencies
PUBLIC	_deflate_reverse_codeword
PUBLIC	_deflate_make_huffman_code
PUBLIC	_deflate_make_huffman_codes
PUBLIC	_deflate_init_static_codes
PUBLIC	_deflate_get_offset_slot
PUBLIC	_deflate_write_block_header
PUBLIC	_deflate_compute_precode_items
PUBLIC	_deflate_precompute_huffman_header
PUBLIC	_deflate_write_huffman_header
PUBLIC	_deflate_write_sequences
PUBLIC	_deflate_write_end_of_block
PUBLIC	_deflate_write_uncompressed_block
PUBLIC	_deflate_write_uncompressed_blocks
PUBLIC	_deflate_flush_block
PUBLIC	_deflate_choose_literal
PUBLIC	_deflate_choose_match
PUBLIC	_deflate_finish_sequence
PUBLIC	_init_block_split_stats
PUBLIC	_observe_literal
PUBLIC	_observe_match
PUBLIC	_do_end_block_check
PUBLIC	_should_end_block
PUBLIC	_deflate_compress_greedy
PUBLIC	_deflate_compress_lazy
PUBLIC	_deflate_init_offset_slot_fast
PUBLIC	__JustMyCode_Default
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__libdeflate_aligned_malloc:PROC
EXTRN	__libdeflate_aligned_free:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__aullshr:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_init_offset_slot_fast
_TEXT	SEGMENT
_offset_slot$1 = -32					; size = 4
_offset_end$ = -20					; size = 4
_offset$ = -8						; size = 4
_c$ = 8							; size = 4
_deflate_init_offset_slot_fast PROC			; COMDAT

; 2194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2195 : 	unsigned offset;
; 2196 : 	unsigned offset_end;
; 2197 : 
; 2198 : 	for (unsigned offset_slot = 0; offset_slot < ARRAY_LEN(deflate_offset_slot_base); offset_slot++)

  00028	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _offset_slot$1[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@deflate_in
$LN2@deflate_in:
  00031	8b 45 e0	 mov	 eax, DWORD PTR _offset_slot$1[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 e0	 mov	 DWORD PTR _offset_slot$1[ebp], eax
$LN4@deflate_in:
  0003a	83 7d e0 1e	 cmp	 DWORD PTR _offset_slot$1[ebp], 30 ; 0000001eH
  0003e	0f 83 94 00 00
	00		 jae	 $LN1@deflate_in

; 2199 : 	{
; 2200 : 		offset = deflate_offset_slot_base[offset_slot];

  00044	8b 45 e0	 mov	 eax, DWORD PTR _offset_slot$1[ebp]
  00047	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _deflate_offset_slot_base[eax*4]
  0004e	89 4d f8	 mov	 DWORD PTR _offset$[ebp], ecx

; 2201 : 	#if USE_FULL_OFFSET_SLOT_FAST
; 2202 : 		offset_end = offset + (1 << deflate_extra_offset_bits[offset_slot]);
; 2203 : 		do {
; 2204 : 			c->offset_slot_fast[offset] = offset_slot;
; 2205 : 		} while (++offset != offset_end);
; 2206 : 	#else
; 2207 : 		if (offset <= 256) {

  00051	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _offset$[ebp], 256 ; 00000100H
  00058	77 39		 ja	 SHORT $LN11@deflate_in

; 2208 : 			offset_end = offset + (1 << deflate_extra_offset_bits[offset_slot]);

  0005a	8b 45 e0	 mov	 eax, DWORD PTR _offset_slot$1[ebp]
  0005d	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _deflate_extra_offset_bits[eax]
  00064	ba 01 00 00 00	 mov	 edx, 1
  00069	d3 e2		 shl	 edx, cl
  0006b	03 55 f8	 add	 edx, DWORD PTR _offset$[ebp]
  0006e	89 55 ec	 mov	 DWORD PTR _offset_end$[ebp], edx
$LN7@deflate_in:

; 2209 : 			do {
; 2210 : 				c->offset_slot_fast[offset - 1] = offset_slot;

  00071	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00074	03 45 f8	 add	 eax, DWORD PTR _offset$[ebp]
  00077	8a 4d e0	 mov	 cl, BYTE PTR _offset_slot$1[ebp]
  0007a	88 88 db 11 00
	00		 mov	 BYTE PTR [eax+4571], cl

; 2211 : 			} while (++offset != offset_end);

  00080	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  00083	83 c0 01	 add	 eax, 1
  00086	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  0008c	3b 4d ec	 cmp	 ecx, DWORD PTR _offset_end$[ebp]
  0008f	75 e0		 jne	 SHORT $LN7@deflate_in

; 2212 : 		} else {

  00091	eb 40		 jmp	 SHORT $LN12@deflate_in
$LN11@deflate_in:

; 2213 : 			offset_end = offset + (1 << deflate_extra_offset_bits[offset_slot]);

  00093	8b 45 e0	 mov	 eax, DWORD PTR _offset_slot$1[ebp]
  00096	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _deflate_extra_offset_bits[eax]
  0009d	ba 01 00 00 00	 mov	 edx, 1
  000a2	d3 e2		 shl	 edx, cl
  000a4	03 55 f8	 add	 edx, DWORD PTR _offset$[ebp]
  000a7	89 55 ec	 mov	 DWORD PTR _offset_end$[ebp], edx
$LN10@deflate_in:

; 2214 : 			do {
; 2215 : 				c->offset_slot_fast[256 + ((offset - 1) >> 7)] = offset_slot;

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  000ad	83 e8 01	 sub	 eax, 1
  000b0	c1 e8 07	 shr	 eax, 7
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  000b6	8a 55 e0	 mov	 dl, BYTE PTR _offset_slot$1[ebp]
  000b9	88 94 01 dc 12
	00 00		 mov	 BYTE PTR [ecx+eax+4828], dl

; 2216 : 			} while ((offset += (1 << 7)) != offset_end);

  000c0	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  000c3	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000c8	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  000ce	3b 4d ec	 cmp	 ecx, DWORD PTR _offset_end$[ebp]
  000d1	75 d7		 jne	 SHORT $LN10@deflate_in
$LN12@deflate_in:

; 2217 : 		}
; 2218 : 	#endif
; 2219 : 	}

  000d3	e9 59 ff ff ff	 jmp	 $LN2@deflate_in
$LN1@deflate_in:

; 2220 : }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000e1	3b ec		 cmp	 ebp, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_deflate_init_offset_slot_fast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_compress_lazy
_TEXT	SEGMENT
tv212 = -400						; size = 4
tv165 = -400						; size = 4
tv87 = -400						; size = 4
tv77 = -400						; size = 4
tv68 = -400						; size = 4
_next_offset$1 = -200					; size = 4
_next_len$2 = -188					; size = 4
_cur_offset$3 = -176					; size = 4
_cur_len$4 = -164					; size = 4
_next_seq$5 = -152					; size = 4
_litrunlen$6 = -140					; size = 4
_in_max_block_end$7 = -128				; size = 4
_in_block_begin$8 = -116				; size = 4
_next_hashes$ = -104					; size = 8
_nice_len$ = -88					; size = 4
_max_len$ = -76						; size = 4
_in_cur_base$ = -64					; size = 4
_os$ = -52						; size = 20
_in_end$ = -24						; size = 4
_in_next$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_in$ = 12						; size = 4
_in_nbytes$ = 16					; size = 4
_out$ = 20						; size = 4
_out_nbytes_avail$ = 24					; size = 4
_deflate_compress_lazy PROC				; COMDAT

; 2053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 70 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-400]
  00012	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2054 : 	const u8 *in_next = in;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  00035	89 45 f4	 mov	 DWORD PTR _in_next$[ebp], eax

; 2055 : 	const u8 *in_end = in_next + in_nbytes;

  00038	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  0003b	03 45 10	 add	 eax, DWORD PTR _in_nbytes$[ebp]
  0003e	89 45 e8	 mov	 DWORD PTR _in_end$[ebp], eax

; 2056 : 	struct deflate_output_bitstream os;
; 2057 : 	const u8 *in_cur_base = in_next;

  00041	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00044	89 45 c0	 mov	 DWORD PTR _in_cur_base$[ebp], eax

; 2058 : 	unsigned max_len = DEFLATE_MAX_MATCH_LEN;

  00047	c7 45 b4 02 01
	00 00		 mov	 DWORD PTR _max_len$[ebp], 258 ; 00000102H

; 2059 : 	unsigned nice_len = MIN(c->nice_match_length, max_len);

  0004e	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00051	8b 88 dc 13 00
	00		 mov	 ecx, DWORD PTR [eax+5084]
  00057	3b 4d b4	 cmp	 ecx, DWORD PTR _max_len$[ebp]
  0005a	77 11		 ja	 SHORT $LN15@deflate_co
  0005c	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0005f	8b 82 dc 13 00
	00		 mov	 eax, DWORD PTR [edx+5084]
  00065	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  0006b	eb 09		 jmp	 SHORT $LN16@deflate_co
$LN15@deflate_co:
  0006d	8b 4d b4	 mov	 ecx, DWORD PTR _max_len$[ebp]
  00070	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv68[ebp], ecx
$LN16@deflate_co:
  00076	8b 95 70 fe ff
	ff		 mov	 edx, DWORD PTR tv68[ebp]
  0007c	89 55 a8	 mov	 DWORD PTR _nice_len$[ebp], edx

; 2060 : 	u32 next_hashes[2] = {0, 0};

  0007f	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _next_hashes$[ebp], 0
  00086	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _next_hashes$[ebp+4], 0

; 2061 : 
; 2062 : 	deflate_init_output(&os, out, out_nbytes_avail);

  0008d	8b 45 18	 mov	 eax, DWORD PTR _out_nbytes_avail$[ebp]
  00090	50		 push	 eax
  00091	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  00094	51		 push	 ecx
  00095	8d 55 cc	 lea	 edx, DWORD PTR _os$[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 _deflate_init_output
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2063 : 	hc_matchfinder_init(&c->p.g.hc_mf);

  000a1	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000a4	05 a4 19 00 00	 add	 eax, 6564		; 000019a4H
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _hc_matchfinder_init
  000af	83 c4 04	 add	 esp, 4
$LN4@deflate_co:

; 2064 : 
; 2065 : 	do {
; 2066 : 		/* Starting a new DEFLATE block.  */
; 2067 : 
; 2068 : 		const u8 * const in_block_begin = in_next;

  000b2	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  000b5	89 45 8c	 mov	 DWORD PTR _in_block_begin$8[ebp], eax

; 2069 : 		const u8 * const in_max_block_end =

  000b8	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  000bb	2b 45 f4	 sub	 eax, DWORD PTR _in_next$[ebp]
  000be	3d e0 93 04 00	 cmp	 eax, 300000		; 000493e0H
  000c3	7f 0e		 jg	 SHORT $LN17@deflate_co
  000c5	8b 4d e8	 mov	 ecx, DWORD PTR _in_end$[ebp]
  000c8	2b 4d f4	 sub	 ecx, DWORD PTR _in_next$[ebp]
  000cb	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
  000d1	eb 0a		 jmp	 SHORT $LN18@deflate_co
$LN17@deflate_co:
  000d3	c7 85 70 fe ff
	ff e0 93 04 00	 mov	 DWORD PTR tv77[ebp], 300000 ; 000493e0H
$LN18@deflate_co:
  000dd	8b 55 f4	 mov	 edx, DWORD PTR _in_next$[ebp]
  000e0	03 95 70 fe ff
	ff		 add	 edx, DWORD PTR tv77[ebp]
  000e6	89 55 80	 mov	 DWORD PTR _in_max_block_end$7[ebp], edx

; 2070 : 			in_next + MIN(in_end - in_next, SOFT_MAX_BLOCK_LENGTH);
; 2071 : 		u32 litrunlen = 0;

  000e9	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _litrunlen$6[ebp], 0

; 2072 : 		struct deflate_sequence *next_seq = c->p.g.sequences;

  000f3	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000f6	05 a4 19 04 00	 add	 eax, 268708		; 000419a4H
  000fb	89 85 68 ff ff
	ff		 mov	 DWORD PTR _next_seq$5[ebp], eax

; 2073 : 
; 2074 : 		init_block_split_stats(&c->split_stats);

  00101	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00104	05 84 11 00 00	 add	 eax, 4484		; 00001184H
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _init_block_split_stats
  0010f	83 c4 04	 add	 esp, 4

; 2075 : 		deflate_reset_symbol_frequencies(c);

  00112	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _deflate_reset_symbol_frequencies
  0011b	83 c4 04	 add	 esp, 4
$LN7@deflate_co:

; 2076 : 
; 2077 : 		do {
; 2078 : 			unsigned cur_len;
; 2079 : 			unsigned cur_offset;
; 2080 : 			unsigned next_len;
; 2081 : 			unsigned next_offset;
; 2082 : 
; 2083 : 			if (unlikely(in_end - in_next < DEFLATE_MAX_MATCH_LEN)) {

  0011e	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  00121	2b 45 f4	 sub	 eax, DWORD PTR _in_next$[ebp]
  00124	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00129	7d 2e		 jge	 SHORT $LN8@deflate_co

; 2084 : 				max_len = in_end - in_next;

  0012b	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  0012e	2b 45 f4	 sub	 eax, DWORD PTR _in_next$[ebp]
  00131	89 45 b4	 mov	 DWORD PTR _max_len$[ebp], eax

; 2085 : 				nice_len = MIN(nice_len, max_len);

  00134	8b 45 a8	 mov	 eax, DWORD PTR _nice_len$[ebp]
  00137	3b 45 b4	 cmp	 eax, DWORD PTR _max_len$[ebp]
  0013a	77 0b		 ja	 SHORT $LN19@deflate_co
  0013c	8b 4d a8	 mov	 ecx, DWORD PTR _nice_len$[ebp]
  0013f	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv87[ebp], ecx
  00145	eb 09		 jmp	 SHORT $LN20@deflate_co
$LN19@deflate_co:
  00147	8b 55 b4	 mov	 edx, DWORD PTR _max_len$[ebp]
  0014a	89 95 70 fe ff
	ff		 mov	 DWORD PTR tv87[ebp], edx
$LN20@deflate_co:
  00150	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR tv87[ebp]
  00156	89 45 a8	 mov	 DWORD PTR _nice_len$[ebp], eax
$LN8@deflate_co:

; 2086 : 			}
; 2087 : 
; 2088 : 			/* Find the longest match at the current position.  */
; 2089 : 			cur_len = hc_matchfinder_longest_match(&c->p.g.hc_mf,

  00159	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _cur_offset$3[ebp]
  0015f	50		 push	 eax
  00160	8d 4d 98	 lea	 ecx, DWORD PTR _next_hashes$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00167	8b 82 e0 13 00
	00		 mov	 eax, DWORD PTR [edx+5088]
  0016d	50		 push	 eax
  0016e	8b 4d a8	 mov	 ecx, DWORD PTR _nice_len$[ebp]
  00171	51		 push	 ecx
  00172	8b 55 b4	 mov	 edx, DWORD PTR _max_len$[ebp]
  00175	52		 push	 edx
  00176	6a 02		 push	 2
  00178	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  0017b	50		 push	 eax
  0017c	8d 4d c0	 lea	 ecx, DWORD PTR _in_cur_base$[ebp]
  0017f	51		 push	 ecx
  00180	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00183	81 c2 a4 19 00
	00		 add	 edx, 6564		; 000019a4H
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 _hc_matchfinder_longest_match
  0018f	83 c4 24	 add	 esp, 36			; 00000024H
  00192	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cur_len$4[ebp], eax

; 2090 : 							       &in_cur_base,
; 2091 : 							       in_next,
; 2092 : 							       DEFLATE_MIN_MATCH_LEN - 1,
; 2093 : 							       max_len,
; 2094 : 							       nice_len,
; 2095 : 							       c->max_search_depth,
; 2096 : 							       next_hashes,
; 2097 : 							       &cur_offset);
; 2098 : 			in_next += 1;

  00198	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  0019b	83 c0 01	 add	 eax, 1
  0019e	89 45 f4	 mov	 DWORD PTR _in_next$[ebp], eax

; 2099 : 
; 2100 : 			if (cur_len < DEFLATE_MIN_MATCH_LEN) {

  001a1	83 bd 5c ff ff
	ff 03		 cmp	 DWORD PTR _cur_len$4[ebp], 3
  001a8	73 3a		 jae	 SHORT $have_cur_match$34

; 2101 : 				/* No match found.  Choose a literal.  */
; 2102 : 				deflate_choose_literal(c, *(in_next - 1), &litrunlen);

  001aa	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _litrunlen$6[ebp]
  001b0	50		 push	 eax
  001b1	8b 4d f4	 mov	 ecx, DWORD PTR _in_next$[ebp]
  001b4	0f b6 51 ff	 movzx	 edx, BYTE PTR [ecx-1]
  001b8	52		 push	 edx
  001b9	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 _deflate_choose_literal
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2103 : 				observe_literal(&c->split_stats, *(in_next - 1));

  001c5	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  001c8	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  001cc	51		 push	 ecx
  001cd	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  001d0	81 c2 84 11 00
	00		 add	 edx, 4484		; 00001184H
  001d6	52		 push	 edx
  001d7	e8 00 00 00 00	 call	 _observe_literal
  001dc	83 c4 08	 add	 esp, 8

; 2104 : 				continue;

  001df	e9 a6 01 00 00	 jmp	 $LN5@deflate_co
$have_cur_match$34:

; 2105 : 			}
; 2106 : 
; 2107 : 		have_cur_match:
; 2108 : 			observe_match(&c->split_stats, cur_len);

  001e4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cur_len$4[ebp]
  001ea	50		 push	 eax
  001eb	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  001ee	81 c1 84 11 00
	00		 add	 ecx, 4484		; 00001184H
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _observe_match
  001fa	83 c4 08	 add	 esp, 8

; 2109 : 
; 2110 : 			/* We have a match at the current position.  */
; 2111 : 
; 2112 : 			/* If the current match is very long, choose it
; 2113 : 			 * immediately.  */
; 2114 : 			if (cur_len >= nice_len) {

  001fd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cur_len$4[ebp]
  00203	3b 45 a8	 cmp	 eax, DWORD PTR _nice_len$[ebp]
  00206	72 5c		 jb	 SHORT $LN10@deflate_co

; 2115 : 				deflate_choose_match(c, cur_len, cur_offset,

  00208	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _next_seq$5[ebp]
  0020e	50		 push	 eax
  0020f	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _litrunlen$6[ebp]
  00215	51		 push	 ecx
  00216	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _cur_offset$3[ebp]
  0021c	52		 push	 edx
  0021d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cur_len$4[ebp]
  00223	50		 push	 eax
  00224	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00227	51		 push	 ecx
  00228	e8 00 00 00 00	 call	 _deflate_choose_match
  0022d	83 c4 14	 add	 esp, 20			; 00000014H

; 2116 : 						     &litrunlen, &next_seq);
; 2117 : 				in_next = hc_matchfinder_skip_positions(&c->p.g.hc_mf,

  00230	8d 45 98	 lea	 eax, DWORD PTR _next_hashes$[ebp]
  00233	50		 push	 eax
  00234	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cur_len$4[ebp]
  0023a	83 e9 01	 sub	 ecx, 1
  0023d	51		 push	 ecx
  0023e	8b 55 e8	 mov	 edx, DWORD PTR _in_end$[ebp]
  00241	52		 push	 edx
  00242	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00245	50		 push	 eax
  00246	8d 4d c0	 lea	 ecx, DWORD PTR _in_cur_base$[ebp]
  00249	51		 push	 ecx
  0024a	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0024d	81 c2 a4 19 00
	00		 add	 edx, 6564		; 000019a4H
  00253	52		 push	 edx
  00254	e8 00 00 00 00	 call	 _hc_matchfinder_skip_positions
  00259	83 c4 18	 add	 esp, 24			; 00000018H
  0025c	89 45 f4	 mov	 DWORD PTR _in_next$[ebp], eax

; 2118 : 									&in_cur_base,
; 2119 : 									in_next,
; 2120 : 									in_end,
; 2121 : 									cur_len - 1,
; 2122 : 									next_hashes);
; 2123 : 				continue;

  0025f	e9 26 01 00 00	 jmp	 $LN5@deflate_co
$LN10@deflate_co:

; 2124 : 			}
; 2125 : 
; 2126 : 			/*
; 2127 : 			 * Try to find a match at the next position.
; 2128 : 			 *
; 2129 : 			 * Note: since we already have a match at the *current*
; 2130 : 			 * position, we use only half the 'max_search_depth'
; 2131 : 			 * when checking the *next* position.  This is a useful
; 2132 : 			 * trade-off because it's more worthwhile to use a
; 2133 : 			 * greater search depth on the initial match.
; 2134 : 			 *
; 2135 : 			 * Note: it's possible to structure the code such that
; 2136 : 			 * there's only one call to longest_match(), which
; 2137 : 			 * handles both the "find the initial match" and "try to
; 2138 : 			 * find a longer match" cases.  However, it is faster to
; 2139 : 			 * have two call sites, with longest_match() inlined at
; 2140 : 			 * each.
; 2141 : 			 */
; 2142 : 			if (unlikely(in_end - in_next < DEFLATE_MAX_MATCH_LEN)) {

  00264	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  00267	2b 45 f4	 sub	 eax, DWORD PTR _in_next$[ebp]
  0026a	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  0026f	7d 2e		 jge	 SHORT $LN11@deflate_co

; 2143 : 				max_len = in_end - in_next;

  00271	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  00274	2b 45 f4	 sub	 eax, DWORD PTR _in_next$[ebp]
  00277	89 45 b4	 mov	 DWORD PTR _max_len$[ebp], eax

; 2144 : 				nice_len = MIN(nice_len, max_len);

  0027a	8b 45 a8	 mov	 eax, DWORD PTR _nice_len$[ebp]
  0027d	3b 45 b4	 cmp	 eax, DWORD PTR _max_len$[ebp]
  00280	77 0b		 ja	 SHORT $LN21@deflate_co
  00282	8b 4d a8	 mov	 ecx, DWORD PTR _nice_len$[ebp]
  00285	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv165[ebp], ecx
  0028b	eb 09		 jmp	 SHORT $LN22@deflate_co
$LN21@deflate_co:
  0028d	8b 55 b4	 mov	 edx, DWORD PTR _max_len$[ebp]
  00290	89 95 70 fe ff
	ff		 mov	 DWORD PTR tv165[ebp], edx
$LN22@deflate_co:
  00296	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR tv165[ebp]
  0029c	89 45 a8	 mov	 DWORD PTR _nice_len$[ebp], eax
$LN11@deflate_co:

; 2145 : 			}
; 2146 : 			next_len = hc_matchfinder_longest_match(&c->p.g.hc_mf,

  0029f	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _next_offset$1[ebp]
  002a5	50		 push	 eax
  002a6	8d 4d 98	 lea	 ecx, DWORD PTR _next_hashes$[ebp]
  002a9	51		 push	 ecx
  002aa	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  002ad	8b 82 e0 13 00
	00		 mov	 eax, DWORD PTR [edx+5088]
  002b3	d1 e8		 shr	 eax, 1
  002b5	50		 push	 eax
  002b6	8b 4d a8	 mov	 ecx, DWORD PTR _nice_len$[ebp]
  002b9	51		 push	 ecx
  002ba	8b 55 b4	 mov	 edx, DWORD PTR _max_len$[ebp]
  002bd	52		 push	 edx
  002be	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cur_len$4[ebp]
  002c4	50		 push	 eax
  002c5	8b 4d f4	 mov	 ecx, DWORD PTR _in_next$[ebp]
  002c8	51		 push	 ecx
  002c9	8d 55 c0	 lea	 edx, DWORD PTR _in_cur_base$[ebp]
  002cc	52		 push	 edx
  002cd	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  002d0	05 a4 19 00 00	 add	 eax, 6564		; 000019a4H
  002d5	50		 push	 eax
  002d6	e8 00 00 00 00	 call	 _hc_matchfinder_longest_match
  002db	83 c4 24	 add	 esp, 36			; 00000024H
  002de	89 85 44 ff ff
	ff		 mov	 DWORD PTR _next_len$2[ebp], eax

; 2147 : 								&in_cur_base,
; 2148 : 								in_next,
; 2149 : 								cur_len,
; 2150 : 								max_len,
; 2151 : 								nice_len,
; 2152 : 								c->max_search_depth / 2,
; 2153 : 								next_hashes,
; 2154 : 								&next_offset);
; 2155 : 			in_next += 1;

  002e4	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  002e7	83 c0 01	 add	 eax, 1
  002ea	89 45 f4	 mov	 DWORD PTR _in_next$[ebp], eax

; 2156 : 
; 2157 : 			if (next_len > cur_len) {

  002ed	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _next_len$2[ebp]
  002f3	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _cur_len$4[ebp]
  002f9	76 38		 jbe	 SHORT $LN12@deflate_co

; 2158 : 				/* Found a longer match at the next position.
; 2159 : 				 * Output a literal.  Then the next match
; 2160 : 				 * becomes the current match.  */
; 2161 : 				deflate_choose_literal(c, *(in_next - 2), &litrunlen);

  002fb	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _litrunlen$6[ebp]
  00301	50		 push	 eax
  00302	8b 4d f4	 mov	 ecx, DWORD PTR _in_next$[ebp]
  00305	0f b6 51 fe	 movzx	 edx, BYTE PTR [ecx-2]
  00309	52		 push	 edx
  0030a	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 _deflate_choose_literal
  00313	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2162 : 				cur_len = next_len;

  00316	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _next_len$2[ebp]
  0031c	89 85 5c ff ff
	ff		 mov	 DWORD PTR _cur_len$4[ebp], eax

; 2163 : 				cur_offset = next_offset;

  00322	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _next_offset$1[ebp]
  00328	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cur_offset$3[ebp], eax

; 2164 : 				goto have_cur_match;

  0032e	e9 b1 fe ff ff	 jmp	 $have_cur_match$34
$LN12@deflate_co:

; 2165 : 			}
; 2166 : 
; 2167 : 			/* No longer match at the next position.
; 2168 : 			 * Output the current match.  */
; 2169 : 			deflate_choose_match(c, cur_len, cur_offset,

  00333	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _next_seq$5[ebp]
  00339	50		 push	 eax
  0033a	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _litrunlen$6[ebp]
  00340	51		 push	 ecx
  00341	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _cur_offset$3[ebp]
  00347	52		 push	 edx
  00348	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cur_len$4[ebp]
  0034e	50		 push	 eax
  0034f	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00352	51		 push	 ecx
  00353	e8 00 00 00 00	 call	 _deflate_choose_match
  00358	83 c4 14	 add	 esp, 20			; 00000014H

; 2170 : 					     &litrunlen, &next_seq);
; 2171 : 			in_next = hc_matchfinder_skip_positions(&c->p.g.hc_mf,

  0035b	8d 45 98	 lea	 eax, DWORD PTR _next_hashes$[ebp]
  0035e	50		 push	 eax
  0035f	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _cur_len$4[ebp]
  00365	83 e9 02	 sub	 ecx, 2
  00368	51		 push	 ecx
  00369	8b 55 e8	 mov	 edx, DWORD PTR _in_end$[ebp]
  0036c	52		 push	 edx
  0036d	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00370	50		 push	 eax
  00371	8d 4d c0	 lea	 ecx, DWORD PTR _in_cur_base$[ebp]
  00374	51		 push	 ecx
  00375	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00378	81 c2 a4 19 00
	00		 add	 edx, 6564		; 000019a4H
  0037e	52		 push	 edx
  0037f	e8 00 00 00 00	 call	 _hc_matchfinder_skip_positions
  00384	83 c4 18	 add	 esp, 24			; 00000018H
  00387	89 45 f4	 mov	 DWORD PTR _in_next$[ebp], eax
$LN5@deflate_co:

; 2172 : 								&in_cur_base,
; 2173 : 								in_next,
; 2174 : 								in_end,
; 2175 : 								cur_len - 2,
; 2176 : 								next_hashes);
; 2177 : 
; 2178 : 			/* Check if it's time to output another block.  */
; 2179 : 		} while (in_next < in_max_block_end &&

  0038a	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  0038d	3b 45 80	 cmp	 eax, DWORD PTR _in_max_block_end$7[ebp]
  00390	73 25		 jae	 SHORT $LN6@deflate_co
  00392	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  00395	50		 push	 eax
  00396	8b 4d f4	 mov	 ecx, DWORD PTR _in_next$[ebp]
  00399	51		 push	 ecx
  0039a	8b 55 8c	 mov	 edx, DWORD PTR _in_block_begin$8[ebp]
  0039d	52		 push	 edx
  0039e	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  003a1	05 84 11 00 00	 add	 eax, 4484		; 00001184H
  003a6	50		 push	 eax
  003a7	e8 00 00 00 00	 call	 _should_end_block
  003ac	83 c4 10	 add	 esp, 16			; 00000010H
  003af	85 c0		 test	 eax, eax
  003b1	0f 84 67 fd ff
	ff		 je	 $LN7@deflate_co
$LN6@deflate_co:

; 2180 : 			 !should_end_block(&c->split_stats, in_block_begin, in_next, in_end));
; 2181 : 
; 2182 : 		deflate_finish_sequence(next_seq, litrunlen);

  003b7	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _litrunlen$6[ebp]
  003bd	50		 push	 eax
  003be	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _next_seq$5[ebp]
  003c4	51		 push	 ecx
  003c5	e8 00 00 00 00	 call	 _deflate_finish_sequence
  003ca	83 c4 08	 add	 esp, 8

; 2183 : 		deflate_flush_block(c, &os, in_block_begin,

  003cd	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  003d0	3b 45 e8	 cmp	 eax, DWORD PTR _in_end$[ebp]
  003d3	75 0c		 jne	 SHORT $LN23@deflate_co
  003d5	c7 85 70 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv212[ebp], 1
  003df	eb 0a		 jmp	 SHORT $LN24@deflate_co
$LN23@deflate_co:
  003e1	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv212[ebp], 0
$LN24@deflate_co:
  003eb	6a 00		 push	 0
  003ed	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv212[ebp]
  003f3	51		 push	 ecx
  003f4	8b 55 f4	 mov	 edx, DWORD PTR _in_next$[ebp]
  003f7	2b 55 8c	 sub	 edx, DWORD PTR _in_block_begin$8[ebp]
  003fa	52		 push	 edx
  003fb	8b 45 8c	 mov	 eax, DWORD PTR _in_block_begin$8[ebp]
  003fe	50		 push	 eax
  003ff	8d 4d cc	 lea	 ecx, DWORD PTR _os$[ebp]
  00402	51		 push	 ecx
  00403	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00406	52		 push	 edx
  00407	e8 00 00 00 00	 call	 _deflate_flush_block
  0040c	83 c4 18	 add	 esp, 24			; 00000018H

; 2184 : 				    in_next - in_block_begin,
; 2185 : 				    in_next == in_end, false);
; 2186 : 	} while (in_next != in_end);

  0040f	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00412	3b 45 e8	 cmp	 eax, DWORD PTR _in_end$[ebp]
  00415	0f 85 97 fc ff
	ff		 jne	 $LN4@deflate_co

; 2187 : 
; 2188 : 	return deflate_flush_output(&os);

  0041b	8d 45 cc	 lea	 eax, DWORD PTR _os$[ebp]
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 _deflate_flush_output
  00424	83 c4 04	 add	 esp, 4

; 2189 : }

  00427	52		 push	 edx
  00428	8b cd		 mov	 ecx, ebp
  0042a	50		 push	 eax
  0042b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN33@deflate_co
  00431	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00436	58		 pop	 eax
  00437	5a		 pop	 edx
  00438	5f		 pop	 edi
  00439	5e		 pop	 esi
  0043a	5b		 pop	 ebx
  0043b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0043e	33 cd		 xor	 ecx, ebp
  00440	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00445	81 c4 90 01 00
	00		 add	 esp, 400		; 00000190H
  0044b	3b ec		 cmp	 ebp, esp
  0044d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00452	8b e5		 mov	 esp, ebp
  00454	5d		 pop	 ebp
  00455	c3		 ret	 0
  00456	66 90		 npad	 2
$LN33@deflate_co:
  00458	07 00 00 00	 DD	 7
  0045c	00 00 00 00	 DD	 $LN32@deflate_co
$LN32@deflate_co:
  00460	cc ff ff ff	 DD	 -52			; ffffffccH
  00464	14 00 00 00	 DD	 20			; 00000014H
  00468	00 00 00 00	 DD	 $LN25@deflate_co
  0046c	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00470	04 00 00 00	 DD	 4
  00474	00 00 00 00	 DD	 $LN26@deflate_co
  00478	98 ff ff ff	 DD	 -104			; ffffff98H
  0047c	08 00 00 00	 DD	 8
  00480	00 00 00 00	 DD	 $LN27@deflate_co
  00484	74 ff ff ff	 DD	 -140			; ffffff74H
  00488	04 00 00 00	 DD	 4
  0048c	00 00 00 00	 DD	 $LN28@deflate_co
  00490	68 ff ff ff	 DD	 -152			; ffffff68H
  00494	04 00 00 00	 DD	 4
  00498	00 00 00 00	 DD	 $LN29@deflate_co
  0049c	50 ff ff ff	 DD	 -176			; ffffff50H
  004a0	04 00 00 00	 DD	 4
  004a4	00 00 00 00	 DD	 $LN30@deflate_co
  004a8	38 ff ff ff	 DD	 -200			; ffffff38H
  004ac	04 00 00 00	 DD	 4
  004b0	00 00 00 00	 DD	 $LN31@deflate_co
$LN31@deflate_co:
  004b4	6e		 DB	 110			; 0000006eH
  004b5	65		 DB	 101			; 00000065H
  004b6	78		 DB	 120			; 00000078H
  004b7	74		 DB	 116			; 00000074H
  004b8	5f		 DB	 95			; 0000005fH
  004b9	6f		 DB	 111			; 0000006fH
  004ba	66		 DB	 102			; 00000066H
  004bb	66		 DB	 102			; 00000066H
  004bc	73		 DB	 115			; 00000073H
  004bd	65		 DB	 101			; 00000065H
  004be	74		 DB	 116			; 00000074H
  004bf	00		 DB	 0
$LN30@deflate_co:
  004c0	63		 DB	 99			; 00000063H
  004c1	75		 DB	 117			; 00000075H
  004c2	72		 DB	 114			; 00000072H
  004c3	5f		 DB	 95			; 0000005fH
  004c4	6f		 DB	 111			; 0000006fH
  004c5	66		 DB	 102			; 00000066H
  004c6	66		 DB	 102			; 00000066H
  004c7	73		 DB	 115			; 00000073H
  004c8	65		 DB	 101			; 00000065H
  004c9	74		 DB	 116			; 00000074H
  004ca	00		 DB	 0
$LN29@deflate_co:
  004cb	6e		 DB	 110			; 0000006eH
  004cc	65		 DB	 101			; 00000065H
  004cd	78		 DB	 120			; 00000078H
  004ce	74		 DB	 116			; 00000074H
  004cf	5f		 DB	 95			; 0000005fH
  004d0	73		 DB	 115			; 00000073H
  004d1	65		 DB	 101			; 00000065H
  004d2	71		 DB	 113			; 00000071H
  004d3	00		 DB	 0
$LN28@deflate_co:
  004d4	6c		 DB	 108			; 0000006cH
  004d5	69		 DB	 105			; 00000069H
  004d6	74		 DB	 116			; 00000074H
  004d7	72		 DB	 114			; 00000072H
  004d8	75		 DB	 117			; 00000075H
  004d9	6e		 DB	 110			; 0000006eH
  004da	6c		 DB	 108			; 0000006cH
  004db	65		 DB	 101			; 00000065H
  004dc	6e		 DB	 110			; 0000006eH
  004dd	00		 DB	 0
$LN27@deflate_co:
  004de	6e		 DB	 110			; 0000006eH
  004df	65		 DB	 101			; 00000065H
  004e0	78		 DB	 120			; 00000078H
  004e1	74		 DB	 116			; 00000074H
  004e2	5f		 DB	 95			; 0000005fH
  004e3	68		 DB	 104			; 00000068H
  004e4	61		 DB	 97			; 00000061H
  004e5	73		 DB	 115			; 00000073H
  004e6	68		 DB	 104			; 00000068H
  004e7	65		 DB	 101			; 00000065H
  004e8	73		 DB	 115			; 00000073H
  004e9	00		 DB	 0
$LN26@deflate_co:
  004ea	69		 DB	 105			; 00000069H
  004eb	6e		 DB	 110			; 0000006eH
  004ec	5f		 DB	 95			; 0000005fH
  004ed	63		 DB	 99			; 00000063H
  004ee	75		 DB	 117			; 00000075H
  004ef	72		 DB	 114			; 00000072H
  004f0	5f		 DB	 95			; 0000005fH
  004f1	62		 DB	 98			; 00000062H
  004f2	61		 DB	 97			; 00000061H
  004f3	73		 DB	 115			; 00000073H
  004f4	65		 DB	 101			; 00000065H
  004f5	00		 DB	 0
$LN25@deflate_co:
  004f6	6f		 DB	 111			; 0000006fH
  004f7	73		 DB	 115			; 00000073H
  004f8	00		 DB	 0
_deflate_compress_lazy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_compress_greedy
_TEXT	SEGMENT
tv171 = -376						; size = 4
tv87 = -376						; size = 4
tv77 = -376						; size = 4
tv68 = -376						; size = 4
_offset$1 = -176					; size = 4
_length$2 = -164					; size = 4
_next_seq$3 = -152					; size = 4
_litrunlen$4 = -140					; size = 4
_in_max_block_end$5 = -128				; size = 4
_in_block_begin$6 = -116				; size = 4
_next_hashes$ = -104					; size = 8
_nice_len$ = -88					; size = 4
_max_len$ = -76						; size = 4
_in_cur_base$ = -64					; size = 4
_os$ = -52						; size = 20
_in_end$ = -24						; size = 4
_in_next$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_in$ = 12						; size = 4
_in_nbytes$ = 16					; size = 4
_out$ = 20						; size = 4
_out_nbytes_avail$ = 24					; size = 4
_deflate_compress_greedy PROC				; COMDAT

; 1969 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 88 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-376]
  00012	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1970 : 	const u8 *in_next = in;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  00035	89 45 f4	 mov	 DWORD PTR _in_next$[ebp], eax

; 1971 : 	const u8 *in_end = in_next + in_nbytes;

  00038	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  0003b	03 45 10	 add	 eax, DWORD PTR _in_nbytes$[ebp]
  0003e	89 45 e8	 mov	 DWORD PTR _in_end$[ebp], eax

; 1972 : 	struct deflate_output_bitstream os;
; 1973 : 	const u8 *in_cur_base = in_next;

  00041	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00044	89 45 c0	 mov	 DWORD PTR _in_cur_base$[ebp], eax

; 1974 : 	unsigned max_len = DEFLATE_MAX_MATCH_LEN;

  00047	c7 45 b4 02 01
	00 00		 mov	 DWORD PTR _max_len$[ebp], 258 ; 00000102H

; 1975 : 	unsigned nice_len = MIN(c->nice_match_length, max_len);

  0004e	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00051	8b 88 dc 13 00
	00		 mov	 ecx, DWORD PTR [eax+5084]
  00057	3b 4d b4	 cmp	 ecx, DWORD PTR _max_len$[ebp]
  0005a	77 11		 ja	 SHORT $LN13@deflate_co
  0005c	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0005f	8b 82 dc 13 00
	00		 mov	 eax, DWORD PTR [edx+5084]
  00065	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  0006b	eb 09		 jmp	 SHORT $LN14@deflate_co
$LN13@deflate_co:
  0006d	8b 4d b4	 mov	 ecx, DWORD PTR _max_len$[ebp]
  00070	89 8d 88 fe ff
	ff		 mov	 DWORD PTR tv68[ebp], ecx
$LN14@deflate_co:
  00076	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv68[ebp]
  0007c	89 55 a8	 mov	 DWORD PTR _nice_len$[ebp], edx

; 1976 : 	u32 next_hashes[2] = {0, 0};

  0007f	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _next_hashes$[ebp], 0
  00086	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _next_hashes$[ebp+4], 0

; 1977 : 
; 1978 : 	deflate_init_output(&os, out, out_nbytes_avail);

  0008d	8b 45 18	 mov	 eax, DWORD PTR _out_nbytes_avail$[ebp]
  00090	50		 push	 eax
  00091	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  00094	51		 push	 ecx
  00095	8d 55 cc	 lea	 edx, DWORD PTR _os$[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 _deflate_init_output
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1979 : 	hc_matchfinder_init(&c->p.g.hc_mf);

  000a1	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000a4	05 a4 19 00 00	 add	 eax, 6564		; 000019a4H
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _hc_matchfinder_init
  000af	83 c4 04	 add	 esp, 4
$LN4@deflate_co:

; 1980 : 
; 1981 : 	do {
; 1982 : 		/* Starting a new DEFLATE block.  */
; 1983 : 
; 1984 : 		const u8 * const in_block_begin = in_next;

  000b2	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  000b5	89 45 8c	 mov	 DWORD PTR _in_block_begin$6[ebp], eax

; 1985 : 		const u8 * const in_max_block_end =

  000b8	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  000bb	2b 45 f4	 sub	 eax, DWORD PTR _in_next$[ebp]
  000be	3d e0 93 04 00	 cmp	 eax, 300000		; 000493e0H
  000c3	7f 0e		 jg	 SHORT $LN15@deflate_co
  000c5	8b 4d e8	 mov	 ecx, DWORD PTR _in_end$[ebp]
  000c8	2b 4d f4	 sub	 ecx, DWORD PTR _in_next$[ebp]
  000cb	89 8d 88 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
  000d1	eb 0a		 jmp	 SHORT $LN16@deflate_co
$LN15@deflate_co:
  000d3	c7 85 88 fe ff
	ff e0 93 04 00	 mov	 DWORD PTR tv77[ebp], 300000 ; 000493e0H
$LN16@deflate_co:
  000dd	8b 55 f4	 mov	 edx, DWORD PTR _in_next$[ebp]
  000e0	03 95 88 fe ff
	ff		 add	 edx, DWORD PTR tv77[ebp]
  000e6	89 55 80	 mov	 DWORD PTR _in_max_block_end$5[ebp], edx

; 1986 : 			in_next + MIN(in_end - in_next, SOFT_MAX_BLOCK_LENGTH);
; 1987 : 		u32 litrunlen = 0;

  000e9	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _litrunlen$4[ebp], 0

; 1988 : 		struct deflate_sequence *next_seq = c->p.g.sequences;

  000f3	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000f6	05 a4 19 04 00	 add	 eax, 268708		; 000419a4H
  000fb	89 85 68 ff ff
	ff		 mov	 DWORD PTR _next_seq$3[ebp], eax

; 1989 : 
; 1990 : 		init_block_split_stats(&c->split_stats);

  00101	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00104	05 84 11 00 00	 add	 eax, 4484		; 00001184H
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _init_block_split_stats
  0010f	83 c4 04	 add	 esp, 4

; 1991 : 		deflate_reset_symbol_frequencies(c);

  00112	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _deflate_reset_symbol_frequencies
  0011b	83 c4 04	 add	 esp, 4
$LN7@deflate_co:

; 1992 : 
; 1993 : 		do {
; 1994 : 			u32 length;
; 1995 : 			u32 offset;
; 1996 : 
; 1997 : 			/* Decrease the maximum and nice match lengths if we're
; 1998 : 			 * approaching the end of the input buffer.  */
; 1999 : 			if (unlikely(max_len > in_end - in_next)) {

  0011e	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  00121	2b 45 f4	 sub	 eax, DWORD PTR _in_next$[ebp]
  00124	39 45 b4	 cmp	 DWORD PTR _max_len$[ebp], eax
  00127	76 2e		 jbe	 SHORT $LN8@deflate_co

; 2000 : 				max_len = in_end - in_next;

  00129	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  0012c	2b 45 f4	 sub	 eax, DWORD PTR _in_next$[ebp]
  0012f	89 45 b4	 mov	 DWORD PTR _max_len$[ebp], eax

; 2001 : 				nice_len = MIN(nice_len, max_len);

  00132	8b 45 a8	 mov	 eax, DWORD PTR _nice_len$[ebp]
  00135	3b 45 b4	 cmp	 eax, DWORD PTR _max_len$[ebp]
  00138	77 0b		 ja	 SHORT $LN17@deflate_co
  0013a	8b 4d a8	 mov	 ecx, DWORD PTR _nice_len$[ebp]
  0013d	89 8d 88 fe ff
	ff		 mov	 DWORD PTR tv87[ebp], ecx
  00143	eb 09		 jmp	 SHORT $LN18@deflate_co
$LN17@deflate_co:
  00145	8b 55 b4	 mov	 edx, DWORD PTR _max_len$[ebp]
  00148	89 95 88 fe ff
	ff		 mov	 DWORD PTR tv87[ebp], edx
$LN18@deflate_co:
  0014e	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR tv87[ebp]
  00154	89 45 a8	 mov	 DWORD PTR _nice_len$[ebp], eax
$LN8@deflate_co:

; 2002 : 			}
; 2003 : 
; 2004 : 			length = hc_matchfinder_longest_match(&c->p.g.hc_mf,

  00157	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _offset$1[ebp]
  0015d	50		 push	 eax
  0015e	8d 4d 98	 lea	 ecx, DWORD PTR _next_hashes$[ebp]
  00161	51		 push	 ecx
  00162	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00165	8b 82 e0 13 00
	00		 mov	 eax, DWORD PTR [edx+5088]
  0016b	50		 push	 eax
  0016c	8b 4d a8	 mov	 ecx, DWORD PTR _nice_len$[ebp]
  0016f	51		 push	 ecx
  00170	8b 55 b4	 mov	 edx, DWORD PTR _max_len$[ebp]
  00173	52		 push	 edx
  00174	6a 02		 push	 2
  00176	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00179	50		 push	 eax
  0017a	8d 4d c0	 lea	 ecx, DWORD PTR _in_cur_base$[ebp]
  0017d	51		 push	 ecx
  0017e	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00181	81 c2 a4 19 00
	00		 add	 edx, 6564		; 000019a4H
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _hc_matchfinder_longest_match
  0018d	83 c4 24	 add	 esp, 36			; 00000024H
  00190	89 85 5c ff ff
	ff		 mov	 DWORD PTR _length$2[ebp], eax

; 2005 : 							      &in_cur_base,
; 2006 : 							      in_next,
; 2007 : 							      DEFLATE_MIN_MATCH_LEN - 1,
; 2008 : 							      max_len,
; 2009 : 							      nice_len,
; 2010 : 							      c->max_search_depth,
; 2011 : 							      next_hashes,
; 2012 : 							      &offset);
; 2013 : 
; 2014 : 			if (length >= DEFLATE_MIN_MATCH_LEN) {

  00196	83 bd 5c ff ff
	ff 03		 cmp	 DWORD PTR _length$2[ebp], 3
  0019d	72 75		 jb	 SHORT $LN9@deflate_co

; 2015 : 				/* Match found.  */
; 2016 : 				deflate_choose_match(c, length, offset,

  0019f	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _next_seq$3[ebp]
  001a5	50		 push	 eax
  001a6	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _litrunlen$4[ebp]
  001ac	51		 push	 ecx
  001ad	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _offset$1[ebp]
  001b3	52		 push	 edx
  001b4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _length$2[ebp]
  001ba	50		 push	 eax
  001bb	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  001be	51		 push	 ecx
  001bf	e8 00 00 00 00	 call	 _deflate_choose_match
  001c4	83 c4 14	 add	 esp, 20			; 00000014H

; 2017 : 						     &litrunlen, &next_seq);
; 2018 : 				observe_match(&c->split_stats, length);

  001c7	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _length$2[ebp]
  001cd	50		 push	 eax
  001ce	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  001d1	81 c1 84 11 00
	00		 add	 ecx, 4484		; 00001184H
  001d7	51		 push	 ecx
  001d8	e8 00 00 00 00	 call	 _observe_match
  001dd	83 c4 08	 add	 esp, 8

; 2019 : 				in_next = hc_matchfinder_skip_positions(&c->p.g.hc_mf,

  001e0	8d 45 98	 lea	 eax, DWORD PTR _next_hashes$[ebp]
  001e3	50		 push	 eax
  001e4	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _length$2[ebp]
  001ea	83 e9 01	 sub	 ecx, 1
  001ed	51		 push	 ecx
  001ee	8b 55 e8	 mov	 edx, DWORD PTR _in_end$[ebp]
  001f1	52		 push	 edx
  001f2	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  001f5	83 c0 01	 add	 eax, 1
  001f8	50		 push	 eax
  001f9	8d 4d c0	 lea	 ecx, DWORD PTR _in_cur_base$[ebp]
  001fc	51		 push	 ecx
  001fd	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00200	81 c2 a4 19 00
	00		 add	 edx, 6564		; 000019a4H
  00206	52		 push	 edx
  00207	e8 00 00 00 00	 call	 _hc_matchfinder_skip_positions
  0020c	83 c4 18	 add	 esp, 24			; 00000018H
  0020f	89 45 f4	 mov	 DWORD PTR _in_next$[ebp], eax

; 2020 : 									&in_cur_base,
; 2021 : 									in_next + 1,
; 2022 : 									in_end,
; 2023 : 									length - 1,
; 2024 : 									next_hashes);
; 2025 : 			} else {

  00212	eb 3c		 jmp	 SHORT $LN5@deflate_co
$LN9@deflate_co:

; 2026 : 				/* No match found.  */
; 2027 : 				deflate_choose_literal(c, *in_next, &litrunlen);

  00214	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _litrunlen$4[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d f4	 mov	 ecx, DWORD PTR _in_next$[ebp]
  0021e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00221	52		 push	 edx
  00222	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00225	50		 push	 eax
  00226	e8 00 00 00 00	 call	 _deflate_choose_literal
  0022b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2028 : 				observe_literal(&c->split_stats, *in_next);

  0022e	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00231	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00234	51		 push	 ecx
  00235	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00238	81 c2 84 11 00
	00		 add	 edx, 4484		; 00001184H
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 _observe_literal
  00244	83 c4 08	 add	 esp, 8

; 2029 : 				in_next++;

  00247	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  0024a	83 c0 01	 add	 eax, 1
  0024d	89 45 f4	 mov	 DWORD PTR _in_next$[ebp], eax
$LN5@deflate_co:

; 2030 : 			}
; 2031 : 
; 2032 : 			/* Check if it's time to output another block.  */
; 2033 : 		} while (in_next < in_max_block_end &&

  00250	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00253	3b 45 80	 cmp	 eax, DWORD PTR _in_max_block_end$5[ebp]
  00256	73 25		 jae	 SHORT $LN6@deflate_co
  00258	8b 45 e8	 mov	 eax, DWORD PTR _in_end$[ebp]
  0025b	50		 push	 eax
  0025c	8b 4d f4	 mov	 ecx, DWORD PTR _in_next$[ebp]
  0025f	51		 push	 ecx
  00260	8b 55 8c	 mov	 edx, DWORD PTR _in_block_begin$6[ebp]
  00263	52		 push	 edx
  00264	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00267	05 84 11 00 00	 add	 eax, 4484		; 00001184H
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _should_end_block
  00272	83 c4 10	 add	 esp, 16			; 00000010H
  00275	85 c0		 test	 eax, eax
  00277	0f 84 a1 fe ff
	ff		 je	 $LN7@deflate_co
$LN6@deflate_co:

; 2034 : 			 !should_end_block(&c->split_stats, in_block_begin, in_next, in_end));
; 2035 : 
; 2036 : 		deflate_finish_sequence(next_seq, litrunlen);

  0027d	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _litrunlen$4[ebp]
  00283	50		 push	 eax
  00284	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _next_seq$3[ebp]
  0028a	51		 push	 ecx
  0028b	e8 00 00 00 00	 call	 _deflate_finish_sequence
  00290	83 c4 08	 add	 esp, 8

; 2037 : 		deflate_flush_block(c, &os, in_block_begin,

  00293	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  00296	3b 45 e8	 cmp	 eax, DWORD PTR _in_end$[ebp]
  00299	75 0c		 jne	 SHORT $LN19@deflate_co
  0029b	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv171[ebp], 1
  002a5	eb 0a		 jmp	 SHORT $LN20@deflate_co
$LN19@deflate_co:
  002a7	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv171[ebp], 0
$LN20@deflate_co:
  002b1	6a 00		 push	 0
  002b3	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv171[ebp]
  002b9	51		 push	 ecx
  002ba	8b 55 f4	 mov	 edx, DWORD PTR _in_next$[ebp]
  002bd	2b 55 8c	 sub	 edx, DWORD PTR _in_block_begin$6[ebp]
  002c0	52		 push	 edx
  002c1	8b 45 8c	 mov	 eax, DWORD PTR _in_block_begin$6[ebp]
  002c4	50		 push	 eax
  002c5	8d 4d cc	 lea	 ecx, DWORD PTR _os$[ebp]
  002c8	51		 push	 ecx
  002c9	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  002cc	52		 push	 edx
  002cd	e8 00 00 00 00	 call	 _deflate_flush_block
  002d2	83 c4 18	 add	 esp, 24			; 00000018H

; 2038 : 				    in_next - in_block_begin,
; 2039 : 				    in_next == in_end, false);
; 2040 : 	} while (in_next != in_end);

  002d5	8b 45 f4	 mov	 eax, DWORD PTR _in_next$[ebp]
  002d8	3b 45 e8	 cmp	 eax, DWORD PTR _in_end$[ebp]
  002db	0f 85 d1 fd ff
	ff		 jne	 $LN4@deflate_co

; 2041 : 	return deflate_flush_output(&os);

  002e1	8d 45 cc	 lea	 eax, DWORD PTR _os$[ebp]
  002e4	50		 push	 eax
  002e5	e8 00 00 00 00	 call	 _deflate_flush_output
  002ea	83 c4 04	 add	 esp, 4

; 2042 : }

  002ed	52		 push	 edx
  002ee	8b cd		 mov	 ecx, ebp
  002f0	50		 push	 eax
  002f1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@deflate_co
  002f7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002fc	58		 pop	 eax
  002fd	5a		 pop	 edx
  002fe	5f		 pop	 edi
  002ff	5e		 pop	 esi
  00300	5b		 pop	 ebx
  00301	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00304	33 cd		 xor	 ecx, ebp
  00306	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030b	81 c4 78 01 00
	00		 add	 esp, 376		; 00000178H
  00311	3b ec		 cmp	 ebp, esp
  00313	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00318	8b e5		 mov	 esp, ebp
  0031a	5d		 pop	 ebp
  0031b	c3		 ret	 0
$LN28@deflate_co:
  0031c	06 00 00 00	 DD	 6
  00320	00 00 00 00	 DD	 $LN27@deflate_co
$LN27@deflate_co:
  00324	cc ff ff ff	 DD	 -52			; ffffffccH
  00328	14 00 00 00	 DD	 20			; 00000014H
  0032c	00 00 00 00	 DD	 $LN21@deflate_co
  00330	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00334	04 00 00 00	 DD	 4
  00338	00 00 00 00	 DD	 $LN22@deflate_co
  0033c	98 ff ff ff	 DD	 -104			; ffffff98H
  00340	08 00 00 00	 DD	 8
  00344	00 00 00 00	 DD	 $LN23@deflate_co
  00348	74 ff ff ff	 DD	 -140			; ffffff74H
  0034c	04 00 00 00	 DD	 4
  00350	00 00 00 00	 DD	 $LN24@deflate_co
  00354	68 ff ff ff	 DD	 -152			; ffffff68H
  00358	04 00 00 00	 DD	 4
  0035c	00 00 00 00	 DD	 $LN25@deflate_co
  00360	50 ff ff ff	 DD	 -176			; ffffff50H
  00364	04 00 00 00	 DD	 4
  00368	00 00 00 00	 DD	 $LN26@deflate_co
$LN26@deflate_co:
  0036c	6f		 DB	 111			; 0000006fH
  0036d	66		 DB	 102			; 00000066H
  0036e	66		 DB	 102			; 00000066H
  0036f	73		 DB	 115			; 00000073H
  00370	65		 DB	 101			; 00000065H
  00371	74		 DB	 116			; 00000074H
  00372	00		 DB	 0
$LN25@deflate_co:
  00373	6e		 DB	 110			; 0000006eH
  00374	65		 DB	 101			; 00000065H
  00375	78		 DB	 120			; 00000078H
  00376	74		 DB	 116			; 00000074H
  00377	5f		 DB	 95			; 0000005fH
  00378	73		 DB	 115			; 00000073H
  00379	65		 DB	 101			; 00000065H
  0037a	71		 DB	 113			; 00000071H
  0037b	00		 DB	 0
$LN24@deflate_co:
  0037c	6c		 DB	 108			; 0000006cH
  0037d	69		 DB	 105			; 00000069H
  0037e	74		 DB	 116			; 00000074H
  0037f	72		 DB	 114			; 00000072H
  00380	75		 DB	 117			; 00000075H
  00381	6e		 DB	 110			; 0000006eH
  00382	6c		 DB	 108			; 0000006cH
  00383	65		 DB	 101			; 00000065H
  00384	6e		 DB	 110			; 0000006eH
  00385	00		 DB	 0
$LN23@deflate_co:
  00386	6e		 DB	 110			; 0000006eH
  00387	65		 DB	 101			; 00000065H
  00388	78		 DB	 120			; 00000078H
  00389	74		 DB	 116			; 00000074H
  0038a	5f		 DB	 95			; 0000005fH
  0038b	68		 DB	 104			; 00000068H
  0038c	61		 DB	 97			; 00000061H
  0038d	73		 DB	 115			; 00000073H
  0038e	68		 DB	 104			; 00000068H
  0038f	65		 DB	 101			; 00000065H
  00390	73		 DB	 115			; 00000073H
  00391	00		 DB	 0
$LN22@deflate_co:
  00392	69		 DB	 105			; 00000069H
  00393	6e		 DB	 110			; 0000006eH
  00394	5f		 DB	 95			; 0000005fH
  00395	63		 DB	 99			; 00000063H
  00396	75		 DB	 117			; 00000075H
  00397	72		 DB	 114			; 00000072H
  00398	5f		 DB	 95			; 0000005fH
  00399	62		 DB	 98			; 00000062H
  0039a	61		 DB	 97			; 00000061H
  0039b	73		 DB	 115			; 00000073H
  0039c	65		 DB	 101			; 00000065H
  0039d	00		 DB	 0
$LN21@deflate_co:
  0039e	6f		 DB	 111			; 0000006fH
  0039f	73		 DB	 115			; 00000073H
  003a0	00		 DB	 0
_deflate_compress_greedy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _should_end_block
_TEXT	SEGMENT
_stats$ = 8						; size = 4
_in_block_begin$ = 12					; size = 4
_in_next$ = 16						; size = 4
_in_end$ = 20						; size = 4
_should_end_block PROC					; COMDAT

; 1951 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1952 : 	/* Ready to check block split statistics? */
; 1953 : 	if (stats->num_new_observations < NUM_OBSERVATIONS_PER_BLOCK_CHECK ||
; 1954 : 	    in_next - in_block_begin < MIN_BLOCK_LENGTH ||

  00028	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  0002b	81 78 50 00 02
	00 00		 cmp	 DWORD PTR [eax+80], 512	; 00000200H
  00032	72 1a		 jb	 SHORT $LN3@should_end
  00034	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  00037	2b 45 0c	 sub	 eax, DWORD PTR _in_block_begin$[ebp]
  0003a	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  0003f	7c 0d		 jl	 SHORT $LN3@should_end
  00041	8b 45 14	 mov	 eax, DWORD PTR _in_end$[ebp]
  00044	2b 45 10	 sub	 eax, DWORD PTR _in_next$[ebp]
  00047	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  0004c	7d 04		 jge	 SHORT $LN2@should_end
$LN3@should_end:

; 1955 : 	    in_end - in_next < MIN_BLOCK_LENGTH)
; 1956 : 		return false;

  0004e	33 c0		 xor	 eax, eax
  00050	eb 13		 jmp	 SHORT $LN1@should_end
$LN2@should_end:

; 1957 : 
; 1958 : 	return do_end_block_check(stats, in_next - in_block_begin);

  00052	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  00055	2b 45 0c	 sub	 eax, DWORD PTR _in_block_begin$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 _do_end_block_check
  00062	83 c4 08	 add	 esp, 8
$LN1@should_end:

; 1959 : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_should_end_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _do_end_block_check
_TEXT	SEGMENT
tv81 = -256						; size = 4
_delta$1 = -56						; size = 4
_actual$2 = -44						; size = 4
_expected$3 = -32					; size = 4
_total_delta$4 = -20					; size = 4
_i$ = -8						; size = 4
_stats$ = 8						; size = 4
_block_length$ = 12					; size = 4
_do_end_block_check PROC				; COMDAT

; 1916 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1917 : 	int i;
; 1918 : 
; 1919 : 	if (stats->num_observations > 0) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  0002b	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  0002f	0f 86 a1 00 00
	00		 jbe	 $LN8@do_end_blo

; 1920 : 
; 1921 : 		/* Note: to avoid slow divisions, we do not divide by
; 1922 : 		 * 'num_observations', but rather do all math with the numbers
; 1923 : 		 * multiplied by 'num_observations'.  */
; 1924 : 		u32 total_delta = 0;

  00035	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _total_delta$4[ebp], 0

; 1925 : 		for (i = 0; i < NUM_OBSERVATION_TYPES; i++) {

  0003c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN4@do_end_blo
$LN2@do_end_blo:
  00045	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@do_end_blo:
  0004e	83 7d f8 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  00052	7d 5d		 jge	 SHORT $LN3@do_end_blo

; 1926 : 			u32 expected = stats->observations[i] * stats->num_new_observations;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  0005a	8b 55 08	 mov	 edx, DWORD PTR _stats$[ebp]
  0005d	8b 44 81 28	 mov	 eax, DWORD PTR [ecx+eax*4+40]
  00061	0f af 42 50	 imul	 eax, DWORD PTR [edx+80]
  00065	89 45 e0	 mov	 DWORD PTR _expected$3[ebp], eax

; 1927 : 			u32 actual = stats->new_observations[i] * stats->num_observations;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  0006e	8b 55 08	 mov	 edx, DWORD PTR _stats$[ebp]
  00071	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00074	0f af 42 54	 imul	 eax, DWORD PTR [edx+84]
  00078	89 45 d4	 mov	 DWORD PTR _actual$2[ebp], eax

; 1928 : 			u32 delta = (actual > expected) ? actual - expected :

  0007b	8b 45 d4	 mov	 eax, DWORD PTR _actual$2[ebp]
  0007e	3b 45 e0	 cmp	 eax, DWORD PTR _expected$3[ebp]
  00081	76 0e		 jbe	 SHORT $LN11@do_end_blo
  00083	8b 4d d4	 mov	 ecx, DWORD PTR _actual$2[ebp]
  00086	2b 4d e0	 sub	 ecx, DWORD PTR _expected$3[ebp]
  00089	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  0008f	eb 0c		 jmp	 SHORT $LN12@do_end_blo
$LN11@do_end_blo:
  00091	8b 55 e0	 mov	 edx, DWORD PTR _expected$3[ebp]
  00094	2b 55 d4	 sub	 edx, DWORD PTR _actual$2[ebp]
  00097	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], edx
$LN12@do_end_blo:
  0009d	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  000a3	89 45 c8	 mov	 DWORD PTR _delta$1[ebp], eax

; 1929 : 							  expected - actual;
; 1930 : 			total_delta += delta;

  000a6	8b 45 ec	 mov	 eax, DWORD PTR _total_delta$4[ebp]
  000a9	03 45 c8	 add	 eax, DWORD PTR _delta$1[ebp]
  000ac	89 45 ec	 mov	 DWORD PTR _total_delta$4[ebp], eax

; 1931 : 		}

  000af	eb 94		 jmp	 SHORT $LN2@do_end_blo
$LN3@do_end_blo:

; 1932 : 
; 1933 : 		/* Ready to end the block? */
; 1934 : 		if (total_delta + (block_length / 4096) * stats->num_observations >=

  000b1	8b 45 0c	 mov	 eax, DWORD PTR _block_length$[ebp]
  000b4	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  000ba	0f af 41 54	 imul	 eax, DWORD PTR [ecx+84]
  000be	03 45 ec	 add	 eax, DWORD PTR _total_delta$4[ebp]
  000c1	8b 55 08	 mov	 edx, DWORD PTR _stats$[ebp]
  000c4	69 4a 54 c8 00
	00 00		 imul	 ecx, DWORD PTR [edx+84], 200
  000cb	3b c1		 cmp	 eax, ecx
  000cd	72 07		 jb	 SHORT $LN8@do_end_blo

; 1935 : 		    NUM_OBSERVATIONS_PER_BLOCK_CHECK * 200 / 512 * stats->num_observations)
; 1936 : 			return true;

  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	eb 65		 jmp	 SHORT $LN1@do_end_blo
$LN8@do_end_blo:

; 1937 : 	}
; 1938 : 
; 1939 : 	for (i = 0; i < NUM_OBSERVATION_TYPES; i++) {

  000d6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000dd	eb 09		 jmp	 SHORT $LN7@do_end_blo
$LN5@do_end_blo:
  000df	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@do_end_blo:
  000e8	83 7d f8 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  000ec	7d 41		 jge	 SHORT $LN6@do_end_blo

; 1940 : 		stats->num_observations += stats->new_observations[i];

  000ee	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  000f1	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000f4	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000f7	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  000fa	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  000fd	8b 55 08	 mov	 edx, DWORD PTR _stats$[ebp]
  00100	89 4a 54	 mov	 DWORD PTR [edx+84], ecx

; 1941 : 		stats->observations[i] += stats->new_observations[i];

  00103	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  00109	8b 54 81 28	 mov	 edx, DWORD PTR [ecx+eax*4+40]
  0010d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  00113	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00116	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  0011c	89 54 81 28	 mov	 DWORD PTR [ecx+eax*4+40], edx

; 1942 : 		stats->new_observations[i] = 0;

  00120	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00123	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  00126	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0

; 1943 : 	}

  0012d	eb b0		 jmp	 SHORT $LN5@do_end_blo
$LN6@do_end_blo:

; 1944 : 	stats->num_new_observations = 0;

  0012f	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  00132	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 1945 : 	return false;

  00139	33 c0		 xor	 eax, eax
$LN1@do_end_blo:

; 1946 : }

  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  00144	3b ec		 cmp	 ebp, esp
  00146	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
_do_end_block_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _observe_match
_TEXT	SEGMENT
tv66 = -196						; size = 4
_stats$ = 8						; size = 4
_length$ = 12						; size = 4
_observe_match PROC					; COMDAT

; 1909 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1910 : 	stats->new_observations[NUM_LITERAL_OBSERVATION_TYPES + (length >= 9)]++;

  00028	83 7d 0c 09	 cmp	 DWORD PTR _length$[ebp], 9
  0002c	72 0c		 jb	 SHORT $LN3@observe_ma
  0002e	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00038	eb 0a		 jmp	 SHORT $LN4@observe_ma
$LN3@observe_ma:
  0003a	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@observe_ma:
  00044	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  0004d	8b 54 81 20	 mov	 edx, DWORD PTR [ecx+eax*4+32]
  00051	83 c2 01	 add	 edx, 1
  00054	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  0005d	89 54 81 20	 mov	 DWORD PTR [ecx+eax*4+32], edx

; 1911 : 	stats->num_new_observations++;

  00061	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  00064	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00067	83 c1 01	 add	 ecx, 1
  0006a	8b 55 08	 mov	 edx, DWORD PTR _stats$[ebp]
  0006d	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 1912 : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_observe_match ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _observe_literal
_TEXT	SEGMENT
_stats$ = 8						; size = 4
_lit$ = 12						; size = 1
_observe_literal PROC					; COMDAT

; 1900 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1901 : 	stats->new_observations[((lit >> 5) & 0x6) | (lit & 1)]++;

  00028	0f b6 45 0c	 movzx	 eax, BYTE PTR _lit$[ebp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _lit$[ebp]
  00033	c1 f9 05	 sar	 ecx, 5
  00036	83 e1 06	 and	 ecx, 6
  00039	0b c8		 or	 ecx, eax
  0003b	8b 55 08	 mov	 edx, DWORD PTR _stats$[ebp]
  0003e	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00041	83 c0 01	 add	 eax, 1
  00044	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _lit$[ebp]
  00048	83 e1 01	 and	 ecx, 1
  0004b	0f b6 55 0c	 movzx	 edx, BYTE PTR _lit$[ebp]
  0004f	c1 fa 05	 sar	 edx, 5
  00052	83 e2 06	 and	 edx, 6
  00055	0b d1		 or	 edx, ecx
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  0005a	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 1902 : 	stats->num_new_observations++;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  00060	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00063	83 c1 01	 add	 ecx, 1
  00066	8b 55 08	 mov	 edx, DWORD PTR _stats$[ebp]
  00069	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 1903 : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_observe_literal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _init_block_split_stats
_TEXT	SEGMENT
_i$ = -8						; size = 4
_stats$ = 8						; size = 4
_init_block_split_stats PROC				; COMDAT

; 1885 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1886 : 	int i;
; 1887 : 
; 1888 : 	for (i = 0; i < NUM_OBSERVATION_TYPES; i++) {

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@init_block
$LN2@init_block:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@init_block:
  0003a	83 7d f8 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  0003e	7d 1d		 jge	 SHORT $LN3@init_block

; 1889 : 		stats->new_observations[i] = 0;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  00046	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0

; 1890 : 		stats->observations[i] = 0;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _stats$[ebp]
  00053	c7 44 81 28 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+40], 0

; 1891 : 	}

  0005b	eb d4		 jmp	 SHORT $LN2@init_block
$LN3@init_block:

; 1892 : 	stats->num_new_observations = 0;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  00060	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 1893 : 	stats->num_observations = 0;

  00067	8b 45 08	 mov	 eax, DWORD PTR _stats$[ebp]
  0006a	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 1894 : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_init_block_split_stats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_finish_sequence
_TEXT	SEGMENT
_seq$ = 8						; size = 4
_litrunlen$ = 12					; size = 4
_deflate_finish_sequence PROC				; COMDAT

; 1840 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1841 : 	seq->litrunlen_and_length = litrunlen; /* length = 0 */

  00028	8b 45 08	 mov	 eax, DWORD PTR _seq$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _litrunlen$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 1842 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_deflate_finish_sequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_choose_match
_TEXT	SEGMENT
_offset_slot$ = -32					; size = 4
_length_slot$ = -20					; size = 4
_seq$ = -8						; size = 4
_c$ = 8							; size = 4
_length$ = 12						; size = 4
_offset$ = 16						; size = 4
_litrunlen_p$ = 20					; size = 4
_next_seq_p$ = 24					; size = 4
_deflate_choose_match PROC				; COMDAT

; 1821 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 : 	struct deflate_sequence *seq = *next_seq_p;

  00028	8b 45 18	 mov	 eax, DWORD PTR _next_seq_p$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	89 4d f8	 mov	 DWORD PTR _seq$[ebp], ecx

; 1823 : 	unsigned length_slot = deflate_length_slot[length];

  00030	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00033	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _deflate_length_slot[eax]
  0003a	89 4d ec	 mov	 DWORD PTR _length_slot$[ebp], ecx

; 1824 : 	unsigned offset_slot = deflate_get_offset_slot(c, offset);

  0003d	8b 45 10	 mov	 eax, DWORD PTR _offset$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _deflate_get_offset_slot
  0004a	83 c4 08	 add	 esp, 8
  0004d	89 45 e0	 mov	 DWORD PTR _offset_slot$[ebp], eax

; 1825 : 
; 1826 : 	c->freqs.litlen[257 + length_slot]++;

  00050	8b 45 ec	 mov	 eax, DWORD PTR _length_slot$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00056	8b 94 81 08 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+1032]
  0005d	83 c2 01	 add	 edx, 1
  00060	8b 45 ec	 mov	 eax, DWORD PTR _length_slot$[ebp]
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00066	89 94 81 08 04
	00 00		 mov	 DWORD PTR [ecx+eax*4+1032], edx

; 1827 : 	c->freqs.offset[offset_slot]++;

  0006d	8b 45 e0	 mov	 eax, DWORD PTR _offset_slot$[ebp]
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00073	8b 94 81 84 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+1156]
  0007a	83 c2 01	 add	 edx, 1
  0007d	8b 45 e0	 mov	 eax, DWORD PTR _offset_slot$[ebp]
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00083	89 94 81 84 04
	00 00		 mov	 DWORD PTR [ecx+eax*4+1156], edx

; 1828 : 
; 1829 : 	seq->litrunlen_and_length = ((u32)length << 23) | *litrunlen_p;

  0008a	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0008d	c1 e0 17	 shl	 eax, 23			; 00000017H
  00090	8b 4d 14	 mov	 ecx, DWORD PTR _litrunlen_p$[ebp]
  00093	0b 01		 or	 eax, DWORD PTR [ecx]
  00095	8b 55 f8	 mov	 edx, DWORD PTR _seq$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax

; 1830 : 	seq->offset = offset;

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  0009d	66 8b 4d 10	 mov	 cx, WORD PTR _offset$[ebp]
  000a1	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 1831 : 	seq->length_slot = length_slot;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  000a8	8a 4d ec	 mov	 cl, BYTE PTR _length_slot$[ebp]
  000ab	88 48 07	 mov	 BYTE PTR [eax+7], cl

; 1832 : 	seq->offset_symbol = offset_slot;

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  000b1	8a 4d e0	 mov	 cl, BYTE PTR _offset_slot$[ebp]
  000b4	88 48 06	 mov	 BYTE PTR [eax+6], cl

; 1833 : 
; 1834 : 	*litrunlen_p = 0;

  000b7	8b 45 14	 mov	 eax, DWORD PTR _litrunlen_p$[ebp]
  000ba	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1835 : 	*next_seq_p = seq + 1;

  000c0	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  000c3	83 c0 08	 add	 eax, 8
  000c6	8b 4d 18	 mov	 ecx, DWORD PTR _next_seq_p$[ebp]
  000c9	89 01		 mov	 DWORD PTR [ecx], eax

; 1836 : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000d4	3b ec		 cmp	 ebp, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_deflate_choose_match ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_choose_literal
_TEXT	SEGMENT
_c$ = 8							; size = 4
_literal$ = 12						; size = 4
_litrunlen_p$ = 16					; size = 4
_deflate_choose_literal PROC				; COMDAT

; 1812 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1813 : 	c->freqs.litlen[literal]++;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _literal$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0002e	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  00032	83 c2 01	 add	 edx, 1
  00035	8b 45 0c	 mov	 eax, DWORD PTR _literal$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0003b	89 54 81 04	 mov	 DWORD PTR [ecx+eax*4+4], edx

; 1814 : 	++*litrunlen_p;

  0003f	8b 45 10	 mov	 eax, DWORD PTR _litrunlen_p$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	83 c1 01	 add	 ecx, 1
  00047	8b 55 10	 mov	 edx, DWORD PTR _litrunlen_p$[ebp]
  0004a	89 0a		 mov	 DWORD PTR [edx], ecx

; 1815 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_deflate_choose_literal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_flush_block
_TEXT	SEGMENT
tv223 = -304						; size = 4
_extra$1 = -104						; size = 4
_extra$2 = -92						; size = 4
_extra$3 = -80						; size = 4
_sym$ = -68						; size = 4
_block_type$ = -56					; size = 4
_codes$ = -44						; size = 4
_uncompressed_cost$ = -32				; size = 4
_static_cost$ = -20					; size = 4
_dynamic_cost$ = -8					; size = 4
_c$ = 8							; size = 4
_os$ = 12						; size = 4
_block_begin$ = 16					; size = 4
_block_length$ = 20					; size = 4
_is_final_block$ = 24					; size = 4
_use_item_list$ = 28					; size = 4
_deflate_flush_block PROC				; COMDAT

; 1705 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00012	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1706 : 	static const u8 deflate_extra_precode_bits[DEFLATE_NUM_PRECODE_SYMS] = {
; 1707 : 		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7,
; 1708 : 	};
; 1709 : 
; 1710 : 	/* Costs are measured in bits */
; 1711 : 	u32 dynamic_cost = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dynamic_cost$[ebp], 0

; 1712 : 	u32 static_cost = 0;

  0002f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _static_cost$[ebp], 0

; 1713 : 	u32 uncompressed_cost = 0;

  00036	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _uncompressed_cost$[ebp], 0

; 1714 : 	struct deflate_codes* codes = { 0 };

  0003d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _codes$[ebp], 0

; 1715 : 	int block_type;
; 1716 : 	unsigned sym;
; 1717 : 
; 1718 : 	/* Tally the end-of-block symbol. */
; 1719 : 	c->freqs.litlen[DEFLATE_END_OF_BLOCK]++;

  00044	b8 04 00 00 00	 mov	 eax, 4
  00049	c1 e0 08	 shl	 eax, 8
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0004f	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00053	83 c2 01	 add	 edx, 1
  00056	b8 04 00 00 00	 mov	 eax, 4
  0005b	c1 e0 08	 shl	 eax, 8
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00061	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx

; 1720 : 
; 1721 : 	/* Build dynamic Huffman codes. */
; 1722 : 	deflate_make_huffman_codes(&c->freqs, &c->codes);

  00065	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00068	05 04 05 00 00	 add	 eax, 1284		; 00000504H
  0006d	50		 push	 eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00071	83 c1 04	 add	 ecx, 4
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _deflate_make_huffman_codes
  0007a	83 c4 08	 add	 esp, 8

; 1723 : 
; 1724 : 	/* Account for the cost of sending dynamic Huffman codes. */
; 1725 : 	deflate_precompute_huffman_header(c);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _deflate_precompute_huffman_header
  00086	83 c4 04	 add	 esp, 4

; 1726 : 	dynamic_cost += 5 + 5 + 4 + (3 * c->num_explicit_lens);

  00089	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0008c	6b 88 9c 19 00
	00 03		 imul	 ecx, DWORD PTR [eax+6556], 3
  00093	8b 55 f8	 mov	 edx, DWORD PTR _dynamic_cost$[ebp]
  00096	8d 44 0a 0e	 lea	 eax, DWORD PTR [edx+ecx+14]
  0009a	89 45 f8	 mov	 DWORD PTR _dynamic_cost$[ebp], eax

; 1727 : 	for (sym = 0; sym < DEFLATE_NUM_PRECODE_SYMS; sym++) {

  0009d	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  000a4	eb 09		 jmp	 SHORT $LN4@deflate_fl
$LN2@deflate_fl:
  000a6	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  000a9	83 c0 01	 add	 eax, 1
  000ac	89 45 bc	 mov	 DWORD PTR _sym$[ebp], eax
$LN4@deflate_fl:
  000af	83 7d bc 13	 cmp	 DWORD PTR _sym$[ebp], 19 ; 00000013H
  000b3	73 33		 jae	 SHORT $LN3@deflate_fl

; 1728 : 		u32 extra = deflate_extra_precode_bits[sym];

  000b5	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  000b8	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?deflate_extra_precode_bits@?1??deflate_flush_block@@9@9[eax]
  000bf	89 4d b0	 mov	 DWORD PTR _extra$3[ebp], ecx

; 1729 : 		dynamic_cost += c->precode_freqs[sym] *

  000c2	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000c5	03 45 bc	 add	 eax, DWORD PTR _sym$[ebp]
  000c8	0f b6 88 34 14
	00 00		 movzx	 ecx, BYTE PTR [eax+5172]
  000cf	03 4d b0	 add	 ecx, DWORD PTR _extra$3[ebp]
  000d2	8b 55 bc	 mov	 edx, DWORD PTR _sym$[ebp]
  000d5	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000d8	0f af 8c 90 e8
	13 00 00	 imul	 ecx, DWORD PTR [eax+edx*4+5096]
  000e0	03 4d f8	 add	 ecx, DWORD PTR _dynamic_cost$[ebp]
  000e3	89 4d f8	 mov	 DWORD PTR _dynamic_cost$[ebp], ecx

; 1730 : 				(extra + c->precode_lens[sym]);
; 1731 : 	}

  000e6	eb be		 jmp	 SHORT $LN2@deflate_fl
$LN3@deflate_fl:

; 1732 : 
; 1733 : 	/* Account for the cost of encoding literals. */
; 1734 : 	for (sym = 0; sym < 256; sym++) {

  000e8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  000ef	eb 09		 jmp	 SHORT $LN7@deflate_fl
$LN5@deflate_fl:
  000f1	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  000f4	83 c0 01	 add	 eax, 1
  000f7	89 45 bc	 mov	 DWORD PTR _sym$[ebp], eax
$LN7@deflate_fl:
  000fa	81 7d bc 00 01
	00 00		 cmp	 DWORD PTR _sym$[ebp], 256 ; 00000100H
  00101	73 20		 jae	 SHORT $LN6@deflate_fl

; 1735 : 		dynamic_cost += c->freqs.litlen[sym] *

  00103	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00106	03 45 bc	 add	 eax, DWORD PTR _sym$[ebp]
  00109	0f b6 88 04 0a
	00 00		 movzx	 ecx, BYTE PTR [eax+2564]
  00110	8b 55 bc	 mov	 edx, DWORD PTR _sym$[ebp]
  00113	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00116	0f af 4c 90 04	 imul	 ecx, DWORD PTR [eax+edx*4+4]
  0011b	03 4d f8	 add	 ecx, DWORD PTR _dynamic_cost$[ebp]
  0011e	89 4d f8	 mov	 DWORD PTR _dynamic_cost$[ebp], ecx

; 1736 : 				c->codes.lens.litlen[sym];
; 1737 : 	}

  00121	eb ce		 jmp	 SHORT $LN5@deflate_fl
$LN6@deflate_fl:

; 1738 : 	for (sym = 0; sym < 144; sym++)

  00123	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  0012a	eb 09		 jmp	 SHORT $LN10@deflate_fl
$LN8@deflate_fl:
  0012c	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  0012f	83 c0 01	 add	 eax, 1
  00132	89 45 bc	 mov	 DWORD PTR _sym$[ebp], eax
$LN10@deflate_fl:
  00135	81 7d bc 90 00
	00 00		 cmp	 DWORD PTR _sym$[ebp], 144 ; 00000090H
  0013c	73 15		 jae	 SHORT $LN9@deflate_fl

; 1739 : 		static_cost += c->freqs.litlen[sym] * 8;

  0013e	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  00141	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00144	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  00148	8b 45 ec	 mov	 eax, DWORD PTR _static_cost$[ebp]
  0014b	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  0014e	89 4d ec	 mov	 DWORD PTR _static_cost$[ebp], ecx
  00151	eb d9		 jmp	 SHORT $LN8@deflate_fl
$LN9@deflate_fl:

; 1740 : 	for (; sym < 256; sym++)

  00153	eb 09		 jmp	 SHORT $LN13@deflate_fl
$LN11@deflate_fl:
  00155	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  00158	83 c0 01	 add	 eax, 1
  0015b	89 45 bc	 mov	 DWORD PTR _sym$[ebp], eax
$LN13@deflate_fl:
  0015e	81 7d bc 00 01
	00 00		 cmp	 DWORD PTR _sym$[ebp], 256 ; 00000100H
  00165	73 13		 jae	 SHORT $LN12@deflate_fl

; 1741 : 		static_cost += c->freqs.litlen[sym] * 9;

  00167	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  0016a	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0016d	6b 54 81 04 09	 imul	 edx, DWORD PTR [ecx+eax*4+4], 9
  00172	03 55 ec	 add	 edx, DWORD PTR _static_cost$[ebp]
  00175	89 55 ec	 mov	 DWORD PTR _static_cost$[ebp], edx
  00178	eb db		 jmp	 SHORT $LN11@deflate_fl
$LN12@deflate_fl:

; 1742 : 
; 1743 : 	/* Account for the cost of encoding the end-of-block symbol. */
; 1744 : 	dynamic_cost += c->codes.lens.litlen[256];

  0017a	b8 01 00 00 00	 mov	 eax, 1
  0017f	c1 e0 08	 shl	 eax, 8
  00182	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00185	0f b6 94 01 04
	0a 00 00	 movzx	 edx, BYTE PTR [ecx+eax+2564]
  0018d	03 55 f8	 add	 edx, DWORD PTR _dynamic_cost$[ebp]
  00190	89 55 f8	 mov	 DWORD PTR _dynamic_cost$[ebp], edx

; 1745 : 	static_cost += 7;

  00193	8b 45 ec	 mov	 eax, DWORD PTR _static_cost$[ebp]
  00196	83 c0 07	 add	 eax, 7
  00199	89 45 ec	 mov	 DWORD PTR _static_cost$[ebp], eax

; 1746 : 
; 1747 : 	/* Account for the cost of encoding lengths. */
; 1748 : 	for (sym = 257; sym < 257 + ARRAY_LEN(deflate_extra_length_bits); sym++) {

  0019c	c7 45 bc 01 01
	00 00		 mov	 DWORD PTR _sym$[ebp], 257 ; 00000101H
  001a3	eb 09		 jmp	 SHORT $LN16@deflate_fl
$LN14@deflate_fl:
  001a5	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  001a8	83 c0 01	 add	 eax, 1
  001ab	89 45 bc	 mov	 DWORD PTR _sym$[ebp], eax
$LN16@deflate_fl:
  001ae	81 7d bc 1e 01
	00 00		 cmp	 DWORD PTR _sym$[ebp], 286 ; 0000011eH
  001b5	73 51		 jae	 SHORT $LN15@deflate_fl

; 1749 : 		u32 extra = deflate_extra_length_bits[sym - 257];

  001b7	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  001ba	0f b6 88 ff fe
	ff ff		 movzx	 ecx, BYTE PTR _deflate_extra_length_bits[eax-257]
  001c1	89 4d a4	 mov	 DWORD PTR _extra$2[ebp], ecx

; 1750 : 		dynamic_cost += c->freqs.litlen[sym] *

  001c4	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001c7	03 45 bc	 add	 eax, DWORD PTR _sym$[ebp]
  001ca	0f b6 88 04 0a
	00 00		 movzx	 ecx, BYTE PTR [eax+2564]
  001d1	03 4d a4	 add	 ecx, DWORD PTR _extra$2[ebp]
  001d4	8b 55 bc	 mov	 edx, DWORD PTR _sym$[ebp]
  001d7	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001da	0f af 4c 90 04	 imul	 ecx, DWORD PTR [eax+edx*4+4]
  001df	03 4d f8	 add	 ecx, DWORD PTR _dynamic_cost$[ebp]
  001e2	89 4d f8	 mov	 DWORD PTR _dynamic_cost$[ebp], ecx

; 1751 : 				(extra + c->codes.lens.litlen[sym]);
; 1752 : 		static_cost += c->freqs.litlen[sym] *

  001e5	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001e8	03 45 bc	 add	 eax, DWORD PTR _sym$[ebp]
  001eb	0f b6 88 44 10
	00 00		 movzx	 ecx, BYTE PTR [eax+4164]
  001f2	03 4d a4	 add	 ecx, DWORD PTR _extra$2[ebp]
  001f5	8b 55 bc	 mov	 edx, DWORD PTR _sym$[ebp]
  001f8	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001fb	0f af 4c 90 04	 imul	 ecx, DWORD PTR [eax+edx*4+4]
  00200	03 4d ec	 add	 ecx, DWORD PTR _static_cost$[ebp]
  00203	89 4d ec	 mov	 DWORD PTR _static_cost$[ebp], ecx

; 1753 : 				(extra + c->static_codes.lens.litlen[sym]);
; 1754 : 	}

  00206	eb 9d		 jmp	 SHORT $LN14@deflate_fl
$LN15@deflate_fl:

; 1755 : 
; 1756 : 	/* Account for the cost of encoding offsets. */
; 1757 : 	for (sym = 0; sym < ARRAY_LEN(deflate_extra_offset_bits); sym++) {

  00208	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  0020f	eb 09		 jmp	 SHORT $LN19@deflate_fl
$LN17@deflate_fl:
  00211	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  00214	83 c0 01	 add	 eax, 1
  00217	89 45 bc	 mov	 DWORD PTR _sym$[ebp], eax
$LN19@deflate_fl:
  0021a	83 7d bc 1e	 cmp	 DWORD PTR _sym$[ebp], 30 ; 0000001eH
  0021e	73 4d		 jae	 SHORT $LN18@deflate_fl

; 1758 : 		u32 extra = deflate_extra_offset_bits[sym];

  00220	8b 45 bc	 mov	 eax, DWORD PTR _sym$[ebp]
  00223	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _deflate_extra_offset_bits[eax]
  0022a	89 4d 98	 mov	 DWORD PTR _extra$1[ebp], ecx

; 1759 : 		dynamic_cost += c->freqs.offset[sym] *

  0022d	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00230	03 45 bc	 add	 eax, DWORD PTR _sym$[ebp]
  00233	0f b6 88 24 0b
	00 00		 movzx	 ecx, BYTE PTR [eax+2852]
  0023a	03 4d 98	 add	 ecx, DWORD PTR _extra$1[ebp]
  0023d	8b 55 bc	 mov	 edx, DWORD PTR _sym$[ebp]
  00240	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00243	0f af 8c 90 84
	04 00 00	 imul	 ecx, DWORD PTR [eax+edx*4+1156]
  0024b	03 4d f8	 add	 ecx, DWORD PTR _dynamic_cost$[ebp]
  0024e	89 4d f8	 mov	 DWORD PTR _dynamic_cost$[ebp], ecx

; 1760 : 				(extra + c->codes.lens.offset[sym]);
; 1761 : 		static_cost += c->freqs.offset[sym] * (extra + 5);

  00251	8b 45 98	 mov	 eax, DWORD PTR _extra$1[ebp]
  00254	83 c0 05	 add	 eax, 5
  00257	8b 4d bc	 mov	 ecx, DWORD PTR _sym$[ebp]
  0025a	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0025d	0f af 84 8a 84
	04 00 00	 imul	 eax, DWORD PTR [edx+ecx*4+1156]
  00265	03 45 ec	 add	 eax, DWORD PTR _static_cost$[ebp]
  00268	89 45 ec	 mov	 DWORD PTR _static_cost$[ebp], eax

; 1762 : 	}

  0026b	eb a4		 jmp	 SHORT $LN17@deflate_fl
$LN18@deflate_fl:

; 1763 : 
; 1764 : 	/* Compute the cost of using uncompressed blocks. */
; 1765 : 	uncompressed_cost += (((unsigned)-((int)os->bitcount + 3)) & 7) + 32 +

  0026d	8b 45 0c	 mov	 eax, DWORD PTR _os$[ebp]
  00270	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00273	83 c1 03	 add	 ecx, 3
  00276	f7 d9		 neg	 ecx
  00278	83 e1 07	 and	 ecx, 7
  0027b	8b 45 14	 mov	 eax, DWORD PTR _block_length$[ebp]
  0027e	05 fe ff 00 00	 add	 eax, 65534		; 0000fffeH
  00283	33 d2		 xor	 edx, edx
  00285	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  0028a	f7 f6		 div	 esi
  0028c	83 e8 01	 sub	 eax, 1
  0028f	6b d0 28	 imul	 edx, eax, 40
  00292	03 4d e0	 add	 ecx, DWORD PTR _uncompressed_cost$[ebp]
  00295	8d 44 0a 20	 lea	 eax, DWORD PTR [edx+ecx+32]
  00299	8b 4d 14	 mov	 ecx, DWORD PTR _block_length$[ebp]
  0029c	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  0029f	89 55 e0	 mov	 DWORD PTR _uncompressed_cost$[ebp], edx

; 1766 : 			     (40 * (DIV_ROUND_UP(block_length,
; 1767 : 						 UINT16_MAX) - 1)) +
; 1768 : 			     (8 * block_length);
; 1769 : 
; 1770 : 	/* Choose the cheapest block type. */
; 1771 : 	if (dynamic_cost < MIN(static_cost, uncompressed_cost)) {

  002a2	8b 45 ec	 mov	 eax, DWORD PTR _static_cost$[ebp]
  002a5	3b 45 e0	 cmp	 eax, DWORD PTR _uncompressed_cost$[ebp]
  002a8	77 0b		 ja	 SHORT $LN28@deflate_fl
  002aa	8b 4d ec	 mov	 ecx, DWORD PTR _static_cost$[ebp]
  002ad	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv223[ebp], ecx
  002b3	eb 09		 jmp	 SHORT $LN29@deflate_fl
$LN28@deflate_fl:
  002b5	8b 55 e0	 mov	 edx, DWORD PTR _uncompressed_cost$[ebp]
  002b8	89 95 d0 fe ff
	ff		 mov	 DWORD PTR tv223[ebp], edx
$LN29@deflate_fl:
  002be	8b 45 f8	 mov	 eax, DWORD PTR _dynamic_cost$[ebp]
  002c1	3b 85 d0 fe ff
	ff		 cmp	 eax, DWORD PTR tv223[ebp]
  002c7	73 14		 jae	 SHORT $LN20@deflate_fl

; 1772 : 		block_type = DEFLATE_BLOCKTYPE_DYNAMIC_HUFFMAN;

  002c9	c7 45 c8 02 00
	00 00		 mov	 DWORD PTR _block_type$[ebp], 2

; 1773 : 		codes = &c->codes;

  002d0	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  002d3	05 04 05 00 00	 add	 eax, 1284		; 00000504H
  002d8	89 45 d4	 mov	 DWORD PTR _codes$[ebp], eax
  002db	eb 23		 jmp	 SHORT $LN21@deflate_fl
$LN20@deflate_fl:

; 1774 : 	} else if (static_cost < uncompressed_cost) {

  002dd	8b 45 ec	 mov	 eax, DWORD PTR _static_cost$[ebp]
  002e0	3b 45 e0	 cmp	 eax, DWORD PTR _uncompressed_cost$[ebp]
  002e3	73 14		 jae	 SHORT $LN22@deflate_fl

; 1775 : 		block_type = DEFLATE_BLOCKTYPE_STATIC_HUFFMAN;

  002e5	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _block_type$[ebp], 1

; 1776 : 		codes = &c->static_codes;

  002ec	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  002ef	05 44 0b 00 00	 add	 eax, 2884		; 00000b44H
  002f4	89 45 d4	 mov	 DWORD PTR _codes$[ebp], eax

; 1777 : 	} else {

  002f7	eb 07		 jmp	 SHORT $LN21@deflate_fl
$LN22@deflate_fl:

; 1778 : 		block_type = DEFLATE_BLOCKTYPE_UNCOMPRESSED;

  002f9	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _block_type$[ebp], 0
$LN21@deflate_fl:

; 1779 : 	}
; 1780 : 
; 1781 : 	/* Now actually output the block. */
; 1782 : 
; 1783 : 	if (block_type == DEFLATE_BLOCKTYPE_UNCOMPRESSED) {

  00300	83 7d c8 00	 cmp	 DWORD PTR _block_type$[ebp], 0
  00304	75 1a		 jne	 SHORT $LN24@deflate_fl

; 1784 : 		/* Note: the length being flushed may exceed the maximum length
; 1785 : 		 * of an uncompressed block (65535 bytes).  Therefore, more than
; 1786 : 		 * one uncompressed block might be needed. */
; 1787 : 		deflate_write_uncompressed_blocks(os, block_begin, block_length,

  00306	8b 45 18	 mov	 eax, DWORD PTR _is_final_block$[ebp]
  00309	50		 push	 eax
  0030a	8b 4d 14	 mov	 ecx, DWORD PTR _block_length$[ebp]
  0030d	51		 push	 ecx
  0030e	8b 55 10	 mov	 edx, DWORD PTR _block_begin$[ebp]
  00311	52		 push	 edx
  00312	8b 45 0c	 mov	 eax, DWORD PTR _os$[ebp]
  00315	50		 push	 eax
  00316	e8 00 00 00 00	 call	 _deflate_write_uncompressed_blocks
  0031b	83 c4 10	 add	 esp, 16			; 00000010H

; 1788 : 						  is_final_block);
; 1789 : 	} else {

  0031e	eb 58		 jmp	 SHORT $LN1@deflate_fl
$LN24@deflate_fl:

; 1790 : 		/* Output the block header. */
; 1791 : 		deflate_write_block_header(os, is_final_block, block_type);

  00320	8b 45 c8	 mov	 eax, DWORD PTR _block_type$[ebp]
  00323	50		 push	 eax
  00324	8b 4d 18	 mov	 ecx, DWORD PTR _is_final_block$[ebp]
  00327	51		 push	 ecx
  00328	8b 55 0c	 mov	 edx, DWORD PTR _os$[ebp]
  0032b	52		 push	 edx
  0032c	e8 00 00 00 00	 call	 _deflate_write_block_header
  00331	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1792 : 
; 1793 : 		/* Output the Huffman codes (dynamic Huffman blocks only). */
; 1794 : 		if (block_type == DEFLATE_BLOCKTYPE_DYNAMIC_HUFFMAN)

  00334	83 7d c8 02	 cmp	 DWORD PTR _block_type$[ebp], 2
  00338	75 10		 jne	 SHORT $LN26@deflate_fl

; 1795 : 			deflate_write_huffman_header(c, os);

  0033a	8b 45 0c	 mov	 eax, DWORD PTR _os$[ebp]
  0033d	50		 push	 eax
  0033e	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00341	51		 push	 ecx
  00342	e8 00 00 00 00	 call	 _deflate_write_huffman_header
  00347	83 c4 08	 add	 esp, 8
$LN26@deflate_fl:

; 1796 : 
; 1797 : 		/* Output the literals, matches, and end-of-block symbol. */
; 1798 : 	#if SUPPORT_NEAR_OPTIMAL_PARSING
; 1799 : 		if (use_item_list)
; 1800 : 			deflate_write_item_list(os, codes, c, block_length);
; 1801 : 		else
; 1802 : 	#endif
; 1803 : 			deflate_write_sequences(os, codes, c->p.g.sequences,

  0034a	8b 45 10	 mov	 eax, DWORD PTR _block_begin$[ebp]
  0034d	50		 push	 eax
  0034e	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00351	81 c1 a4 19 04
	00		 add	 ecx, 268708		; 000419a4H
  00357	51		 push	 ecx
  00358	8b 55 d4	 mov	 edx, DWORD PTR _codes$[ebp]
  0035b	52		 push	 edx
  0035c	8b 45 0c	 mov	 eax, DWORD PTR _os$[ebp]
  0035f	50		 push	 eax
  00360	e8 00 00 00 00	 call	 _deflate_write_sequences
  00365	83 c4 10	 add	 esp, 16			; 00000010H

; 1804 : 						block_begin);
; 1805 : 		deflate_write_end_of_block(os, codes);

  00368	8b 45 d4	 mov	 eax, DWORD PTR _codes$[ebp]
  0036b	50		 push	 eax
  0036c	8b 4d 0c	 mov	 ecx, DWORD PTR _os$[ebp]
  0036f	51		 push	 ecx
  00370	e8 00 00 00 00	 call	 _deflate_write_end_of_block
  00375	83 c4 08	 add	 esp, 8
$LN1@deflate_fl:

; 1806 : 	}
; 1807 : }

  00378	5f		 pop	 edi
  00379	5e		 pop	 esi
  0037a	5b		 pop	 ebx
  0037b	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  00381	3b ec		 cmp	 ebp, esp
  00383	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00388	8b e5		 mov	 esp, ebp
  0038a	5d		 pop	 ebp
  0038b	c3		 ret	 0
_deflate_flush_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_write_uncompressed_blocks
_TEXT	SEGMENT
tv70 = -208						; size = 4
tv65 = -208						; size = 4
_len$1 = -8						; size = 2
_os$ = 8						; size = 4
_data$ = 12						; size = 4
_data_length$ = 16					; size = 4
_is_final_block$ = 20					; size = 4
_deflate_write_uncompressed_blocks PROC			; COMDAT

; 1685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN4@deflate_wr:

; 1686 : 	do {
; 1687 : 		u16 len = MIN(data_length, UINT16_MAX);

  00028	81 7d 10 ff ff
	00 00		 cmp	 DWORD PTR _data_length$[ebp], 65535 ; 0000ffffH
  0002f	77 0b		 ja	 SHORT $LN6@deflate_wr
  00031	8b 45 10	 mov	 eax, DWORD PTR _data_length$[ebp]
  00034	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0003a	eb 0a		 jmp	 SHORT $LN7@deflate_wr
$LN6@deflate_wr:
  0003c	c7 85 30 ff ff
	ff ff ff 00 00	 mov	 DWORD PTR tv65[ebp], 65535 ; 0000ffffH
$LN7@deflate_wr:
  00046	66 8b 8d 30 ff
	ff ff		 mov	 cx, WORD PTR tv65[ebp]
  0004d	66 89 4d f8	 mov	 WORD PTR _len$1[ebp], cx

; 1688 : 
; 1689 : 		deflate_write_uncompressed_block(os, data, len,

  00051	83 7d 14 00	 cmp	 DWORD PTR _is_final_block$[ebp], 0
  00055	74 15		 je	 SHORT $LN8@deflate_wr
  00057	0f b7 45 f8	 movzx	 eax, WORD PTR _len$1[ebp]
  0005b	3b 45 10	 cmp	 eax, DWORD PTR _data_length$[ebp]
  0005e	75 0c		 jne	 SHORT $LN8@deflate_wr
  00060	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv70[ebp], 1
  0006a	eb 0a		 jmp	 SHORT $LN9@deflate_wr
$LN8@deflate_wr:
  0006c	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN9@deflate_wr:
  00076	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  0007c	51		 push	 ecx
  0007d	0f b7 55 f8	 movzx	 edx, WORD PTR _len$1[ebp]
  00081	52		 push	 edx
  00082	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00085	50		 push	 eax
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 _deflate_write_uncompressed_block
  0008f	83 c4 10	 add	 esp, 16			; 00000010H

; 1690 : 					is_final_block && len == data_length);
; 1691 : 		data += len;

  00092	0f b7 45 f8	 movzx	 eax, WORD PTR _len$1[ebp]
  00096	03 45 0c	 add	 eax, DWORD PTR _data$[ebp]
  00099	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax

; 1692 : 		data_length -= len;

  0009c	0f b7 45 f8	 movzx	 eax, WORD PTR _len$1[ebp]
  000a0	8b 4d 10	 mov	 ecx, DWORD PTR _data_length$[ebp]
  000a3	2b c8		 sub	 ecx, eax
  000a5	89 4d 10	 mov	 DWORD PTR _data_length$[ebp], ecx

; 1693 : 	} while (data_length != 0);

  000a8	0f 85 7a ff ff
	ff		 jne	 $LN4@deflate_wr

; 1694 : }

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
_deflate_write_uncompressed_blocks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_write_uncompressed_block
_TEXT	SEGMENT
_os$ = 8						; size = 4
_data$ = 12						; size = 4
_len$ = 16						; size = 2
_is_final_block$ = 20					; size = 4
_deflate_write_uncompressed_block PROC			; COMDAT

; 1663 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1664 : 	deflate_write_block_header(os, is_final_block,

  00028	6a 00		 push	 0
  0002a	8b 45 14	 mov	 eax, DWORD PTR _is_final_block$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _deflate_write_block_header
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1665 : 				   DEFLATE_BLOCKTYPE_UNCOMPRESSED);
; 1666 : 	deflate_align_bitstream(os);

  0003a	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _deflate_align_bitstream
  00043	83 c4 04	 add	 esp, 4

; 1667 : 
; 1668 : 	if (4 + (u32)len >= os->end - os->next) {

  00046	0f b7 45 10	 movzx	 eax, WORD PTR _len$[ebp]
  0004a	83 c0 04	 add	 eax, 4
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00050	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00053	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00056	2b 4a 0c	 sub	 ecx, DWORD PTR [edx+12]
  00059	3b c1		 cmp	 eax, ecx
  0005b	72 0e		 jb	 SHORT $LN2@deflate_wr

; 1669 : 		os->next = os->end;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00063	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00066	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1670 : 		return;

  00069	eb 70		 jmp	 SHORT $LN1@deflate_wr
$LN2@deflate_wr:

; 1671 : 	}
; 1672 : 
; 1673 : 	put_unaligned_le16(len, os->next);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0006e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00071	51		 push	 ecx
  00072	0f b7 55 10	 movzx	 edx, WORD PTR _len$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _put_unaligned_le16
  0007c	83 c4 08	 add	 esp, 8

; 1674 : 	os->next += 2;

  0007f	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00082	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00085	83 c1 02	 add	 ecx, 2
  00088	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0008b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1675 : 	put_unaligned_le16(~len, os->next);

  0008e	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00091	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00094	51		 push	 ecx
  00095	0f b7 55 10	 movzx	 edx, WORD PTR _len$[ebp]
  00099	f7 d2		 not	 edx
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 _put_unaligned_le16
  000a1	83 c4 08	 add	 esp, 8

; 1676 : 	os->next += 2;

  000a4	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000a7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000aa	83 c1 02	 add	 ecx, 2
  000ad	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000b0	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1677 : 	memcpy(os->next, data, len);

  000b3	0f b7 45 10	 movzx	 eax, WORD PTR _len$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000bf	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _memcpy
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1678 : 	os->next += len;

  000cb	0f b7 45 10	 movzx	 eax, WORD PTR _len$[ebp]
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  000d2	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  000d5	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000d8	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN1@deflate_wr:

; 1679 : }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000e4	3b ec		 cmp	 ebp, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_deflate_write_uncompressed_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_write_end_of_block
_TEXT	SEGMENT
_os$ = 8						; size = 4
_codes$ = 12						; size = 4
_deflate_write_end_of_block PROC			; COMDAT

; 1653 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1654 : 	deflate_add_bits(os, codes->codewords.litlen[DEFLATE_END_OF_BLOCK],

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	c1 e0 08	 shl	 eax, 8
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _codes$[ebp]
  00033	0f b6 94 01 00
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1280]
  0003b	52		 push	 edx
  0003c	b8 04 00 00 00	 mov	 eax, 4
  00041	c1 e0 08	 shl	 eax, 8
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _codes$[ebp]
  00047	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0004a	52		 push	 edx
  0004b	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _deflate_add_bits
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1655 : 			 codes->lens.litlen[DEFLATE_END_OF_BLOCK]);
; 1656 : 	deflate_flush_bits(os);

  00057	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _deflate_flush_bits
  00060	83 c4 04	 add	 esp, 4

; 1657 : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_deflate_write_end_of_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_write_sequences
_TEXT	SEGMENT
tv206 = -320						; size = 4
tv186 = -320						; size = 4
tv166 = -320						; size = 4
tv205 = -316						; size = 4
tv185 = -316						; size = 4
tv165 = -316						; size = 4
_lit3$1 = -116						; size = 4
_lit2$2 = -104						; size = 4
_lit1$3 = -92						; size = 4
_lit0$4 = -80						; size = 4
_offset_symbol$5 = -68					; size = 4
_litlen_symbol$6 = -56					; size = 4
_length_slot$7 = -44					; size = 4
_length$8 = -32						; size = 4
_litrunlen$9 = -20					; size = 4
_seq$ = -8						; size = 4
_os$ = 8						; size = 4
_codes$ = 12						; size = 4
_sequences$ = 16					; size = 4
_in_next$ = 20						; size = 4
_deflate_write_sequences PROC				; COMDAT

; 1467 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-320]
  00012	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1468 : 	const struct deflate_sequence *seq = sequences;

  00028	8b 45 10	 mov	 eax, DWORD PTR _sequences$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _seq$[ebp], eax
$LN4@deflate_wr:

; 1469 : 
; 1470 : 	for (;;) {
; 1471 : 		u32 litrunlen = seq->litrunlen_and_length & 0x7FFFFF;

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	81 e1 ff ff 7f
	00		 and	 ecx, 8388607		; 007fffffH
  00039	89 4d ec	 mov	 DWORD PTR _litrunlen$9[ebp], ecx

; 1472 : 		unsigned length = seq->litrunlen_and_length >> 23;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00044	89 4d e0	 mov	 DWORD PTR _length$8[ebp], ecx

; 1473 : 		unsigned length_slot;
; 1474 : 		unsigned litlen_symbol;
; 1475 : 		unsigned offset_symbol;
; 1476 : 
; 1477 : 		if (litrunlen) {

  00047	83 7d ec 00	 cmp	 DWORD PTR _litrunlen$9[ebp], 0
  0004b	0f 84 e4 02 00
	00		 je	 $LN7@deflate_wr
$LN5@deflate_wr:

; 1478 : 		#if 1
; 1479 : 			while (litrunlen >= 4) {

  00051	83 7d ec 04	 cmp	 DWORD PTR _litrunlen$9[ebp], 4
  00055	0f 82 39 01 00
	00		 jb	 $LN6@deflate_wr

; 1480 : 				unsigned lit0 = in_next[0];

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	6b c8 00	 imul	 ecx, eax, 0
  00063	8b 55 14	 mov	 edx, DWORD PTR _in_next$[ebp]
  00066	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0006a	89 45 b0	 mov	 DWORD PTR _lit0$4[ebp], eax

; 1481 : 				unsigned lit1 = in_next[1];

  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	c1 e0 00	 shl	 eax, 0
  00075	8b 4d 14	 mov	 ecx, DWORD PTR _in_next$[ebp]
  00078	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0007c	89 55 a4	 mov	 DWORD PTR _lit1$3[ebp], edx

; 1482 : 				unsigned lit2 = in_next[2];

  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	d1 e0		 shl	 eax, 1
  00086	8b 4d 14	 mov	 ecx, DWORD PTR _in_next$[ebp]
  00089	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0008d	89 55 98	 mov	 DWORD PTR _lit2$2[ebp], edx

; 1483 : 				unsigned lit3 = in_next[3];

  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	6b c8 03	 imul	 ecx, eax, 3
  00098	8b 55 14	 mov	 edx, DWORD PTR _in_next$[ebp]
  0009b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0009f	89 45 8c	 mov	 DWORD PTR _lit3$1[ebp], eax

; 1484 : 
; 1485 : 				deflate_add_bits(os, codes->codewords.litlen[lit0],

  000a2	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  000a5	03 45 b0	 add	 eax, DWORD PTR _lit0$4[ebp]
  000a8	0f b6 88 00 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1280]
  000af	51		 push	 ecx
  000b0	8b 55 b0	 mov	 edx, DWORD PTR _lit0$4[ebp]
  000b3	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  000b6	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000b9	51		 push	 ecx
  000ba	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _deflate_add_bits
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1486 : 						 codes->lens.litlen[lit0]);
; 1487 : 				if (!CAN_BUFFER(2 * MAX_LITLEN_CODEWORD_LEN))

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	85 c0		 test	 eax, eax
  000cd	74 0c		 je	 SHORT $LN8@deflate_wr

; 1488 : 					deflate_flush_bits(os);

  000cf	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _deflate_flush_bits
  000d8	83 c4 04	 add	 esp, 4
$LN8@deflate_wr:

; 1489 : 
; 1490 : 				deflate_add_bits(os, codes->codewords.litlen[lit1],

  000db	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  000de	03 45 a4	 add	 eax, DWORD PTR _lit1$3[ebp]
  000e1	0f b6 88 00 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1280]
  000e8	51		 push	 ecx
  000e9	8b 55 a4	 mov	 edx, DWORD PTR _lit1$3[ebp]
  000ec	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  000ef	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000f2	51		 push	 ecx
  000f3	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 _deflate_add_bits
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1491 : 						 codes->lens.litlen[lit1]);
; 1492 : 				if (!CAN_BUFFER(4 * MAX_LITLEN_CODEWORD_LEN))

  000ff	b8 01 00 00 00	 mov	 eax, 1
  00104	85 c0		 test	 eax, eax
  00106	74 0c		 je	 SHORT $LN9@deflate_wr

; 1493 : 					deflate_flush_bits(os);

  00108	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _deflate_flush_bits
  00111	83 c4 04	 add	 esp, 4
$LN9@deflate_wr:

; 1494 : 
; 1495 : 				deflate_add_bits(os, codes->codewords.litlen[lit2],

  00114	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  00117	03 45 98	 add	 eax, DWORD PTR _lit2$2[ebp]
  0011a	0f b6 88 00 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1280]
  00121	51		 push	 ecx
  00122	8b 55 98	 mov	 edx, DWORD PTR _lit2$2[ebp]
  00125	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  00128	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0012b	51		 push	 ecx
  0012c	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 _deflate_add_bits
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1496 : 						 codes->lens.litlen[lit2]);
; 1497 : 				if (!CAN_BUFFER(2 * MAX_LITLEN_CODEWORD_LEN))

  00138	b8 01 00 00 00	 mov	 eax, 1
  0013d	85 c0		 test	 eax, eax
  0013f	74 0c		 je	 SHORT $LN10@deflate_wr

; 1498 : 					deflate_flush_bits(os);

  00141	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _deflate_flush_bits
  0014a	83 c4 04	 add	 esp, 4
$LN10@deflate_wr:

; 1499 : 
; 1500 : 				deflate_add_bits(os, codes->codewords.litlen[lit3],

  0014d	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  00150	03 45 8c	 add	 eax, DWORD PTR _lit3$1[ebp]
  00153	0f b6 88 00 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1280]
  0015a	51		 push	 ecx
  0015b	8b 55 8c	 mov	 edx, DWORD PTR _lit3$1[ebp]
  0015e	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  00161	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00164	51		 push	 ecx
  00165	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00168	52		 push	 edx
  00169	e8 00 00 00 00	 call	 _deflate_add_bits
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1501 : 						 codes->lens.litlen[lit3]);
; 1502 : 				deflate_flush_bits(os);

  00171	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _deflate_flush_bits
  0017a	83 c4 04	 add	 esp, 4

; 1503 : 				in_next += 4;

  0017d	8b 45 14	 mov	 eax, DWORD PTR _in_next$[ebp]
  00180	83 c0 04	 add	 eax, 4
  00183	89 45 14	 mov	 DWORD PTR _in_next$[ebp], eax

; 1504 : 				litrunlen -= 4;

  00186	8b 45 ec	 mov	 eax, DWORD PTR _litrunlen$9[ebp]
  00189	83 e8 04	 sub	 eax, 4
  0018c	89 45 ec	 mov	 DWORD PTR _litrunlen$9[ebp], eax

; 1505 : 			}

  0018f	e9 bd fe ff ff	 jmp	 $LN5@deflate_wr
$LN6@deflate_wr:

; 1506 : 			if (litrunlen-- != 0) {

  00194	8b 45 ec	 mov	 eax, DWORD PTR _litrunlen$9[ebp]
  00197	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv165[ebp], eax
  0019d	8b 4d ec	 mov	 ecx, DWORD PTR _litrunlen$9[ebp]
  001a0	83 e9 01	 sub	 ecx, 1
  001a3	89 4d ec	 mov	 DWORD PTR _litrunlen$9[ebp], ecx
  001a6	83 bd c4 fe ff
	ff 00		 cmp	 DWORD PTR tv165[ebp], 0
  001ad	74 0c		 je	 SHORT $LN22@deflate_wr
  001af	c7 85 c0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv166[ebp], 1
  001b9	eb 0a		 jmp	 SHORT $LN23@deflate_wr
$LN22@deflate_wr:
  001bb	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv166[ebp], 0
$LN23@deflate_wr:
  001c5	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR tv166[ebp], 0
  001cc	0f 84 63 01 00
	00		 je	 $LN7@deflate_wr

; 1507 : 				deflate_add_bits(os, codes->codewords.litlen[*in_next],

  001d2	8b 45 14	 mov	 eax, DWORD PTR _in_next$[ebp]
  001d5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001d8	8b 55 0c	 mov	 edx, DWORD PTR _codes$[ebp]
  001db	0f b6 84 0a 00
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1280]
  001e3	50		 push	 eax
  001e4	8b 4d 14	 mov	 ecx, DWORD PTR _in_next$[ebp]
  001e7	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001ea	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  001ed	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  001f0	51		 push	 ecx
  001f1	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  001f4	52		 push	 edx
  001f5	e8 00 00 00 00	 call	 _deflate_add_bits
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1508 : 						 codes->lens.litlen[*in_next]);
; 1509 : 				if (!CAN_BUFFER(3 * MAX_LITLEN_CODEWORD_LEN))

  001fd	b8 01 00 00 00	 mov	 eax, 1
  00202	85 c0		 test	 eax, eax
  00204	74 0c		 je	 SHORT $LN12@deflate_wr

; 1510 : 					deflate_flush_bits(os);

  00206	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 _deflate_flush_bits
  0020f	83 c4 04	 add	 esp, 4
$LN12@deflate_wr:

; 1511 : 				in_next++;

  00212	8b 45 14	 mov	 eax, DWORD PTR _in_next$[ebp]
  00215	83 c0 01	 add	 eax, 1
  00218	89 45 14	 mov	 DWORD PTR _in_next$[ebp], eax

; 1512 : 				if (litrunlen-- != 0) {

  0021b	8b 45 ec	 mov	 eax, DWORD PTR _litrunlen$9[ebp]
  0021e	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv185[ebp], eax
  00224	8b 4d ec	 mov	 ecx, DWORD PTR _litrunlen$9[ebp]
  00227	83 e9 01	 sub	 ecx, 1
  0022a	89 4d ec	 mov	 DWORD PTR _litrunlen$9[ebp], ecx
  0022d	83 bd c4 fe ff
	ff 00		 cmp	 DWORD PTR tv185[ebp], 0
  00234	74 0c		 je	 SHORT $LN24@deflate_wr
  00236	c7 85 c0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv186[ebp], 1
  00240	eb 0a		 jmp	 SHORT $LN25@deflate_wr
$LN24@deflate_wr:
  00242	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv186[ebp], 0
$LN25@deflate_wr:
  0024c	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR tv186[ebp], 0
  00253	0f 84 cc 00 00
	00		 je	 $LN13@deflate_wr

; 1513 : 					deflate_add_bits(os, codes->codewords.litlen[*in_next],

  00259	8b 45 14	 mov	 eax, DWORD PTR _in_next$[ebp]
  0025c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0025f	8b 55 0c	 mov	 edx, DWORD PTR _codes$[ebp]
  00262	0f b6 84 0a 00
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1280]
  0026a	50		 push	 eax
  0026b	8b 4d 14	 mov	 ecx, DWORD PTR _in_next$[ebp]
  0026e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00271	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  00274	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00277	51		 push	 ecx
  00278	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0027b	52		 push	 edx
  0027c	e8 00 00 00 00	 call	 _deflate_add_bits
  00281	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1514 : 							 codes->lens.litlen[*in_next]);
; 1515 : 					if (!CAN_BUFFER(3 * MAX_LITLEN_CODEWORD_LEN))

  00284	b8 01 00 00 00	 mov	 eax, 1
  00289	85 c0		 test	 eax, eax
  0028b	74 0c		 je	 SHORT $LN14@deflate_wr

; 1516 : 						deflate_flush_bits(os);

  0028d	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 _deflate_flush_bits
  00296	83 c4 04	 add	 esp, 4
$LN14@deflate_wr:

; 1517 : 					in_next++;

  00299	8b 45 14	 mov	 eax, DWORD PTR _in_next$[ebp]
  0029c	83 c0 01	 add	 eax, 1
  0029f	89 45 14	 mov	 DWORD PTR _in_next$[ebp], eax

; 1518 : 					if (litrunlen-- != 0) {

  002a2	8b 45 ec	 mov	 eax, DWORD PTR _litrunlen$9[ebp]
  002a5	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv205[ebp], eax
  002ab	8b 4d ec	 mov	 ecx, DWORD PTR _litrunlen$9[ebp]
  002ae	83 e9 01	 sub	 ecx, 1
  002b1	89 4d ec	 mov	 DWORD PTR _litrunlen$9[ebp], ecx
  002b4	83 bd c4 fe ff
	ff 00		 cmp	 DWORD PTR tv205[ebp], 0
  002bb	74 0c		 je	 SHORT $LN26@deflate_wr
  002bd	c7 85 c0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv206[ebp], 1
  002c7	eb 0a		 jmp	 SHORT $LN27@deflate_wr
$LN26@deflate_wr:
  002c9	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv206[ebp], 0
$LN27@deflate_wr:
  002d3	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR tv206[ebp], 0
  002da	74 49		 je	 SHORT $LN13@deflate_wr

; 1519 : 						deflate_add_bits(os, codes->codewords.litlen[*in_next],

  002dc	8b 45 14	 mov	 eax, DWORD PTR _in_next$[ebp]
  002df	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002e2	8b 55 0c	 mov	 edx, DWORD PTR _codes$[ebp]
  002e5	0f b6 84 0a 00
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1280]
  002ed	50		 push	 eax
  002ee	8b 4d 14	 mov	 ecx, DWORD PTR _in_next$[ebp]
  002f1	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  002f4	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  002f7	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  002fa	51		 push	 ecx
  002fb	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  002fe	52		 push	 edx
  002ff	e8 00 00 00 00	 call	 _deflate_add_bits
  00304	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1520 : 								 codes->lens.litlen[*in_next]);
; 1521 : 						if (!CAN_BUFFER(3 * MAX_LITLEN_CODEWORD_LEN))

  00307	b8 01 00 00 00	 mov	 eax, 1
  0030c	85 c0		 test	 eax, eax
  0030e	74 0c		 je	 SHORT $LN16@deflate_wr

; 1522 : 							deflate_flush_bits(os);

  00310	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00313	50		 push	 eax
  00314	e8 00 00 00 00	 call	 _deflate_flush_bits
  00319	83 c4 04	 add	 esp, 4
$LN16@deflate_wr:

; 1523 : 						in_next++;

  0031c	8b 45 14	 mov	 eax, DWORD PTR _in_next$[ebp]
  0031f	83 c0 01	 add	 eax, 1
  00322	89 45 14	 mov	 DWORD PTR _in_next$[ebp], eax
$LN13@deflate_wr:

; 1524 : 					}
; 1525 : 				}
; 1526 : 				if (CAN_BUFFER(3 * MAX_LITLEN_CODEWORD_LEN))

  00325	33 c0		 xor	 eax, eax
  00327	74 0c		 je	 SHORT $LN7@deflate_wr

; 1527 : 					deflate_flush_bits(os);

  00329	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 _deflate_flush_bits
  00332	83 c4 04	 add	 esp, 4
$LN7@deflate_wr:

; 1528 : 			}
; 1529 : 		#else
; 1530 : 			do {
; 1531 : 				unsigned lit = *in_next++;
; 1532 : 				deflate_add_bits(os, codes->codewords.litlen[lit],
; 1533 : 						 codes->lens.litlen[lit]);
; 1534 : 				deflate_flush_bits(os);
; 1535 : 			} while (--litrunlen);
; 1536 : 		#endif
; 1537 : 		}
; 1538 : 
; 1539 : 		if (length == 0)

  00335	83 7d e0 00	 cmp	 DWORD PTR _length$8[ebp], 0
  00339	75 05		 jne	 SHORT $LN18@deflate_wr

; 1540 : 			return;

  0033b	e9 06 01 00 00	 jmp	 $LN1@deflate_wr
$LN18@deflate_wr:

; 1541 : 
; 1542 : 		in_next += length;

  00340	8b 45 14	 mov	 eax, DWORD PTR _in_next$[ebp]
  00343	03 45 e0	 add	 eax, DWORD PTR _length$8[ebp]
  00346	89 45 14	 mov	 DWORD PTR _in_next$[ebp], eax

; 1543 : 
; 1544 : 		length_slot = seq->length_slot;

  00349	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  0034c	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00350	89 4d d4	 mov	 DWORD PTR _length_slot$7[ebp], ecx

; 1545 : 		litlen_symbol = 257 + length_slot;

  00353	8b 45 d4	 mov	 eax, DWORD PTR _length_slot$7[ebp]
  00356	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0035b	89 45 c8	 mov	 DWORD PTR _litlen_symbol$6[ebp], eax

; 1546 : 
; 1547 : 		/* Litlen symbol  */
; 1548 : 		deflate_add_bits(os, codes->codewords.litlen[litlen_symbol],

  0035e	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  00361	03 45 c8	 add	 eax, DWORD PTR _litlen_symbol$6[ebp]
  00364	0f b6 88 00 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1280]
  0036b	51		 push	 ecx
  0036c	8b 55 c8	 mov	 edx, DWORD PTR _litlen_symbol$6[ebp]
  0036f	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  00372	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00375	51		 push	 ecx
  00376	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00379	52		 push	 edx
  0037a	e8 00 00 00 00	 call	 _deflate_add_bits
  0037f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1549 : 				 codes->lens.litlen[litlen_symbol]);
; 1550 : 
; 1551 : 		/* Extra length bits  */
; 1552 : 		STATIC_ASSERT(CAN_BUFFER(MAX_LITLEN_CODEWORD_LEN +
; 1553 : 					 DEFLATE_MAX_EXTRA_LENGTH_BITS));
; 1554 : 		deflate_add_bits(os, length - deflate_length_slot_base[length_slot],

  00382	8b 45 d4	 mov	 eax, DWORD PTR _length_slot$7[ebp]
  00385	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _deflate_extra_length_bits[eax]
  0038c	51		 push	 ecx
  0038d	8b 55 d4	 mov	 edx, DWORD PTR _length_slot$7[ebp]
  00390	8b 45 e0	 mov	 eax, DWORD PTR _length$8[ebp]
  00393	2b 04 95 00 00
	00 00		 sub	 eax, DWORD PTR _deflate_length_slot_base[edx*4]
  0039a	50		 push	 eax
  0039b	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0039e	51		 push	 ecx
  0039f	e8 00 00 00 00	 call	 _deflate_add_bits
  003a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1555 : 				 deflate_extra_length_bits[length_slot]);
; 1556 : 
; 1557 : 		if (!CAN_BUFFER(MAX_LITLEN_CODEWORD_LEN +

  003a7	b8 01 00 00 00	 mov	 eax, 1
  003ac	85 c0		 test	 eax, eax
  003ae	74 0c		 je	 SHORT $LN19@deflate_wr

; 1558 : 				DEFLATE_MAX_EXTRA_LENGTH_BITS +
; 1559 : 				MAX_OFFSET_CODEWORD_LEN +
; 1560 : 				DEFLATE_MAX_EXTRA_OFFSET_BITS))
; 1561 : 			deflate_flush_bits(os);

  003b0	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  003b3	50		 push	 eax
  003b4	e8 00 00 00 00	 call	 _deflate_flush_bits
  003b9	83 c4 04	 add	 esp, 4
$LN19@deflate_wr:

; 1562 : 
; 1563 : 		/* Offset symbol  */
; 1564 : 		offset_symbol = seq->offset_symbol;

  003bc	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  003bf	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  003c3	89 4d bc	 mov	 DWORD PTR _offset_symbol$5[ebp], ecx

; 1565 : 		deflate_add_bits(os, codes->codewords.offset[offset_symbol],

  003c6	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  003c9	03 45 bc	 add	 eax, DWORD PTR _offset_symbol$5[ebp]
  003cc	0f b6 88 20 06
	00 00		 movzx	 ecx, BYTE PTR [eax+1568]
  003d3	51		 push	 ecx
  003d4	8b 55 bc	 mov	 edx, DWORD PTR _offset_symbol$5[ebp]
  003d7	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  003da	8b 8c 90 80 04
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+1152]
  003e1	51		 push	 ecx
  003e2	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  003e5	52		 push	 edx
  003e6	e8 00 00 00 00	 call	 _deflate_add_bits
  003eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1566 : 				 codes->lens.offset[offset_symbol]);
; 1567 : 
; 1568 : 		if (!CAN_BUFFER(MAX_OFFSET_CODEWORD_LEN +

  003ee	b8 01 00 00 00	 mov	 eax, 1
  003f3	85 c0		 test	 eax, eax
  003f5	74 0c		 je	 SHORT $LN20@deflate_wr

; 1569 : 				DEFLATE_MAX_EXTRA_OFFSET_BITS))
; 1570 : 			deflate_flush_bits(os);

  003f7	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 _deflate_flush_bits
  00400	83 c4 04	 add	 esp, 4
$LN20@deflate_wr:

; 1571 : 
; 1572 : 		/* Extra offset bits  */
; 1573 : 		deflate_add_bits(os, seq->offset - deflate_offset_slot_base[offset_symbol],

  00403	8b 45 bc	 mov	 eax, DWORD PTR _offset_symbol$5[ebp]
  00406	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _deflate_extra_offset_bits[eax]
  0040d	51		 push	 ecx
  0040e	8b 55 f8	 mov	 edx, DWORD PTR _seq$[ebp]
  00411	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  00415	8b 4d bc	 mov	 ecx, DWORD PTR _offset_symbol$5[ebp]
  00418	2b 04 8d 00 00
	00 00		 sub	 eax, DWORD PTR _deflate_offset_slot_base[ecx*4]
  0041f	50		 push	 eax
  00420	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00423	52		 push	 edx
  00424	e8 00 00 00 00	 call	 _deflate_add_bits
  00429	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1574 : 				 deflate_extra_offset_bits[offset_symbol]);
; 1575 : 
; 1576 : 		deflate_flush_bits(os);

  0042c	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0042f	50		 push	 eax
  00430	e8 00 00 00 00	 call	 _deflate_flush_bits
  00435	83 c4 04	 add	 esp, 4

; 1577 : 
; 1578 : 		seq++;

  00438	8b 45 f8	 mov	 eax, DWORD PTR _seq$[ebp]
  0043b	83 c0 08	 add	 eax, 8
  0043e	89 45 f8	 mov	 DWORD PTR _seq$[ebp], eax

; 1579 : 	}

  00441	e9 e8 fb ff ff	 jmp	 $LN4@deflate_wr
$LN1@deflate_wr:

; 1580 : }

  00446	5f		 pop	 edi
  00447	5e		 pop	 esi
  00448	5b		 pop	 ebx
  00449	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  0044f	3b ec		 cmp	 ebp, esp
  00451	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00456	8b e5		 mov	 esp, ebp
  00458	5d		 pop	 ebp
  00459	c3		 ret	 0
_deflate_write_sequences ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_write_huffman_header
_TEXT	SEGMENT
_precode_sym$1 = -32					; size = 4
_precode_item$2 = -20					; size = 4
_i$ = -8						; size = 4
_c$ = 8							; size = 4
_os$ = 12						; size = 4
_deflate_write_huffman_header PROC			; COMDAT

; 1428 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1429 : 	unsigned i;
; 1430 : 
; 1431 : 	deflate_add_bits(os, c->num_litlen_syms - 257, 5);

  00028	6a 05		 push	 5
  0002a	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0002d	8b 88 94 19 00
	00		 mov	 ecx, DWORD PTR [eax+6548]
  00033	81 e9 01 01 00
	00		 sub	 ecx, 257		; 00000101H
  00039	51		 push	 ecx
  0003a	8b 55 0c	 mov	 edx, DWORD PTR _os$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _deflate_add_bits
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1432 : 	deflate_add_bits(os, c->num_offset_syms - 1, 5);

  00046	6a 05		 push	 5
  00048	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0004b	8b 88 98 19 00
	00		 mov	 ecx, DWORD PTR [eax+6552]
  00051	83 e9 01	 sub	 ecx, 1
  00054	51		 push	 ecx
  00055	8b 55 0c	 mov	 edx, DWORD PTR _os$[ebp]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 _deflate_add_bits
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1433 : 	deflate_add_bits(os, c->num_explicit_lens - 4, 4);

  00061	6a 04		 push	 4
  00063	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00066	8b 88 9c 19 00
	00		 mov	 ecx, DWORD PTR [eax+6556]
  0006c	83 e9 04	 sub	 ecx, 4
  0006f	51		 push	 ecx
  00070	8b 55 0c	 mov	 edx, DWORD PTR _os$[ebp]
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 _deflate_add_bits
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1434 : 	deflate_flush_bits(os);

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _os$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _deflate_flush_bits
  00085	83 c4 04	 add	 esp, 4

; 1435 : 
; 1436 : 	/* Output the lengths of the codewords in the precode.  */
; 1437 : 	for (i = 0; i < c->num_explicit_lens; i++) {

  00088	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0008f	eb 09		 jmp	 SHORT $LN4@deflate_wr
$LN2@deflate_wr:
  00091	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00094	83 c0 01	 add	 eax, 1
  00097	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@deflate_wr:
  0009a	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000a0	3b 88 9c 19 00
	00		 cmp	 ecx, DWORD PTR [eax+6556]
  000a6	73 32		 jae	 SHORT $LN3@deflate_wr

; 1438 : 		deflate_add_bits(os, c->precode_lens[

  000a8	6a 03		 push	 3
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ad	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _deflate_precode_lens_permutation[eax]
  000b4	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  000b7	0f b6 84 0a 34
	14 00 00	 movzx	 eax, BYTE PTR [edx+ecx+5172]
  000bf	50		 push	 eax
  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _os$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _deflate_add_bits
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1439 : 				       deflate_precode_lens_permutation[i]], 3);
; 1440 : 		deflate_flush_bits(os);

  000cc	8b 45 0c	 mov	 eax, DWORD PTR _os$[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _deflate_flush_bits
  000d5	83 c4 04	 add	 esp, 4

; 1441 : 	}

  000d8	eb b7		 jmp	 SHORT $LN2@deflate_wr
$LN3@deflate_wr:

; 1442 : 
; 1443 : 	/* Output the encoded lengths of the codewords in the larger code.  */
; 1444 : 	for (i = 0; i < c->num_precode_items; i++) {

  000da	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e1	eb 09		 jmp	 SHORT $LN7@deflate_wr
$LN5@deflate_wr:
  000e3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e6	83 c0 01	 add	 eax, 1
  000e9	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@deflate_wr:
  000ec	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000f2	3b 88 a0 19 00
	00		 cmp	 ecx, DWORD PTR [eax+6560]
  000f8	0f 83 a7 00 00
	00		 jae	 $LN1@deflate_wr

; 1445 : 		unsigned precode_item = c->precode_items[i];

  000fe	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00104	8b 94 81 94 14
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+5268]
  0010b	89 55 ec	 mov	 DWORD PTR _precode_item$2[ebp], edx

; 1446 : 		unsigned precode_sym = precode_item & 0x1F;

  0010e	8b 45 ec	 mov	 eax, DWORD PTR _precode_item$2[ebp]
  00111	83 e0 1f	 and	 eax, 31			; 0000001fH
  00114	89 45 e0	 mov	 DWORD PTR _precode_sym$1[ebp], eax

; 1447 : 		deflate_add_bits(os, c->precode_codewords[precode_sym],

  00117	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0011a	03 45 e0	 add	 eax, DWORD PTR _precode_sym$1[ebp]
  0011d	0f b6 88 34 14
	00 00		 movzx	 ecx, BYTE PTR [eax+5172]
  00124	51		 push	 ecx
  00125	8b 55 e0	 mov	 edx, DWORD PTR _precode_sym$1[ebp]
  00128	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0012b	8b 8c 90 48 14
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+5192]
  00132	51		 push	 ecx
  00133	8b 55 0c	 mov	 edx, DWORD PTR _os$[ebp]
  00136	52		 push	 edx
  00137	e8 00 00 00 00	 call	 _deflate_add_bits
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1448 : 				 c->precode_lens[precode_sym]);
; 1449 : 		if (precode_sym >= 16) {

  0013f	83 7d e0 10	 cmp	 DWORD PTR _precode_sym$1[ebp], 16 ; 00000010H
  00143	72 4f		 jb	 SHORT $LN8@deflate_wr

; 1450 : 			if (precode_sym == 16)

  00145	83 7d e0 10	 cmp	 DWORD PTR _precode_sym$1[ebp], 16 ; 00000010H
  00149	75 17		 jne	 SHORT $LN9@deflate_wr

; 1451 : 				deflate_add_bits(os, precode_item >> 5, 2);

  0014b	6a 02		 push	 2
  0014d	8b 45 ec	 mov	 eax, DWORD PTR _precode_item$2[ebp]
  00150	c1 e8 05	 shr	 eax, 5
  00153	50		 push	 eax
  00154	8b 4d 0c	 mov	 ecx, DWORD PTR _os$[ebp]
  00157	51		 push	 ecx
  00158	e8 00 00 00 00	 call	 _deflate_add_bits
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	eb 32		 jmp	 SHORT $LN8@deflate_wr
$LN9@deflate_wr:

; 1452 : 			else if (precode_sym == 17)

  00162	83 7d e0 11	 cmp	 DWORD PTR _precode_sym$1[ebp], 17 ; 00000011H
  00166	75 17		 jne	 SHORT $LN11@deflate_wr

; 1453 : 				deflate_add_bits(os, precode_item >> 5, 3);

  00168	6a 03		 push	 3
  0016a	8b 45 ec	 mov	 eax, DWORD PTR _precode_item$2[ebp]
  0016d	c1 e8 05	 shr	 eax, 5
  00170	50		 push	 eax
  00171	8b 4d 0c	 mov	 ecx, DWORD PTR _os$[ebp]
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 _deflate_add_bits
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017d	eb 15		 jmp	 SHORT $LN8@deflate_wr
$LN11@deflate_wr:

; 1454 : 			else
; 1455 : 				deflate_add_bits(os, precode_item >> 5, 7);

  0017f	6a 07		 push	 7
  00181	8b 45 ec	 mov	 eax, DWORD PTR _precode_item$2[ebp]
  00184	c1 e8 05	 shr	 eax, 5
  00187	50		 push	 eax
  00188	8b 4d 0c	 mov	 ecx, DWORD PTR _os$[ebp]
  0018b	51		 push	 ecx
  0018c	e8 00 00 00 00	 call	 _deflate_add_bits
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@deflate_wr:

; 1456 : 		}
; 1457 : 		STATIC_ASSERT(CAN_BUFFER(DEFLATE_MAX_PRE_CODEWORD_LEN + 7));
; 1458 : 		deflate_flush_bits(os);

  00194	8b 45 0c	 mov	 eax, DWORD PTR _os$[ebp]
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 _deflate_flush_bits
  0019d	83 c4 04	 add	 esp, 4

; 1459 : 	}

  001a0	e9 3e ff ff ff	 jmp	 $LN5@deflate_wr
$LN1@deflate_wr:

; 1460 : }

  001a5	5f		 pop	 edi
  001a6	5e		 pop	 esi
  001a7	5b		 pop	 ebx
  001a8	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  001ae	3b ec		 cmp	 ebp, esp
  001b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b5	8b e5		 mov	 esp, ebp
  001b7	5d		 pop	 ebp
  001b8	c3		 ret	 0
_deflate_write_huffman_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_precompute_huffman_header
_TEXT	SEGMENT
_c$ = 8							; size = 4
_deflate_precompute_huffman_header PROC			; COMDAT

; 1364 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1365 : 	/* Compute how many litlen and offset symbols are needed. */
; 1366 : 
; 1367 : 	for (c->num_litlen_syms = DEFLATE_NUM_LITLEN_SYMS;

  00028	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0002b	c7 80 94 19 00
	00 20 01 00 00	 mov	 DWORD PTR [eax+6548], 288 ; 00000120H
  00035	eb 15		 jmp	 SHORT $LN4@deflate_pr
$LN2@deflate_pr:

; 1369 : 	     c->num_litlen_syms--)

  00037	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0003a	8b 88 94 19 00
	00		 mov	 ecx, DWORD PTR [eax+6548]
  00040	83 e9 01	 sub	 ecx, 1
  00043	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00046	89 8a 94 19 00
	00		 mov	 DWORD PTR [edx+6548], ecx
$LN4@deflate_pr:

; 1368 : 	     c->num_litlen_syms > 257;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0004f	81 b8 94 19 00
	00 01 01 00 00	 cmp	 DWORD PTR [eax+6548], 257 ; 00000101H
  00059	76 1c		 jbe	 SHORT $LN3@deflate_pr

; 1370 : 		if (c->codes.lens.litlen[c->num_litlen_syms - 1] != 0)

  0005b	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0005e	8b 88 94 19 00
	00		 mov	 ecx, DWORD PTR [eax+6548]
  00064	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00067	0f b6 84 0a 03
	0a 00 00	 movzx	 eax, BYTE PTR [edx+ecx+2563]
  0006f	85 c0		 test	 eax, eax
  00071	74 02		 je	 SHORT $LN11@deflate_pr

; 1371 : 			break;

  00073	eb 02		 jmp	 SHORT $LN3@deflate_pr
$LN11@deflate_pr:
  00075	eb c0		 jmp	 SHORT $LN2@deflate_pr
$LN3@deflate_pr:

; 1372 : 
; 1373 : 	for (c->num_offset_syms = DEFLATE_NUM_OFFSET_SYMS;

  00077	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0007a	c7 80 98 19 00
	00 20 00 00 00	 mov	 DWORD PTR [eax+6552], 32 ; 00000020H
  00084	eb 15		 jmp	 SHORT $LN7@deflate_pr
$LN5@deflate_pr:

; 1375 : 	     c->num_offset_syms--)

  00086	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00089	8b 88 98 19 00
	00		 mov	 ecx, DWORD PTR [eax+6552]
  0008f	83 e9 01	 sub	 ecx, 1
  00092	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00095	89 8a 98 19 00
	00		 mov	 DWORD PTR [edx+6552], ecx
$LN7@deflate_pr:

; 1374 : 	     c->num_offset_syms > 1;

  0009b	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0009e	83 b8 98 19 00
	00 01		 cmp	 DWORD PTR [eax+6552], 1
  000a5	76 1c		 jbe	 SHORT $LN6@deflate_pr

; 1376 : 		if (c->codes.lens.offset[c->num_offset_syms - 1] != 0)

  000a7	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000aa	8b 88 98 19 00
	00		 mov	 ecx, DWORD PTR [eax+6552]
  000b0	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  000b3	0f b6 84 0a 23
	0b 00 00	 movzx	 eax, BYTE PTR [edx+ecx+2851]
  000bb	85 c0		 test	 eax, eax
  000bd	74 02		 je	 SHORT $LN12@deflate_pr

; 1377 : 			break;

  000bf	eb 02		 jmp	 SHORT $LN6@deflate_pr
$LN12@deflate_pr:
  000c1	eb c3		 jmp	 SHORT $LN5@deflate_pr
$LN6@deflate_pr:

; 1378 : 
; 1379 : 	/* If we're not using the full set of literal/length codeword lengths,
; 1380 : 	 * then temporarily move the offset codeword lengths over so that the
; 1381 : 	 * literal/length and offset codeword lengths are contiguous. */
; 1382 : 
; 1383 : 	STATIC_ASSERT(offsetof(struct deflate_lens, offset) ==
; 1384 : 		      DEFLATE_NUM_LITLEN_SYMS);
; 1385 : 
; 1386 : 	if (c->num_litlen_syms != DEFLATE_NUM_LITLEN_SYMS) {

  000c3	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000c6	81 b8 94 19 00
	00 20 01 00 00	 cmp	 DWORD PTR [eax+6548], 288 ; 00000120H
  000d0	74 30		 je	 SHORT $LN13@deflate_pr

; 1387 : 		memmove((u8 *)&c->codes.lens + c->num_litlen_syms,

  000d2	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000d5	8b 88 98 19 00
	00		 mov	 ecx, DWORD PTR [eax+6552]
  000db	51		 push	 ecx
  000dc	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  000df	81 c2 24 0b 00
	00		 add	 edx, 2852		; 00000b24H
  000e5	52		 push	 edx
  000e6	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000e9	8b 88 94 19 00
	00		 mov	 ecx, DWORD PTR [eax+6548]
  000ef	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  000f2	8d 84 0a 04 0a
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2564]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@deflate_pr:

; 1388 : 			(u8 *)&c->codes.lens + DEFLATE_NUM_LITLEN_SYMS,
; 1389 : 			c->num_offset_syms);
; 1390 : 	}
; 1391 : 
; 1392 : 	/* Compute the "items" (RLE / literal tokens and extra bits) with which
; 1393 : 	 * the codeword lengths in the larger code will be output. */
; 1394 : 	c->num_precode_items =

  00102	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00105	05 94 14 00 00	 add	 eax, 5268		; 00001494H
  0010a	50		 push	 eax
  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0010e	81 c1 e8 13 00
	00		 add	 ecx, 5096		; 000013e8H
  00114	51		 push	 ecx
  00115	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00118	8b 82 94 19 00
	00		 mov	 eax, DWORD PTR [edx+6548]
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00121	03 81 98 19 00
	00		 add	 eax, DWORD PTR [ecx+6552]
  00127	50		 push	 eax
  00128	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0012b	81 c2 04 0a 00
	00		 add	 edx, 2564		; 00000a04H
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 _deflate_compute_precode_items
  00137	83 c4 10	 add	 esp, 16			; 00000010H
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0013d	89 81 a0 19 00
	00		 mov	 DWORD PTR [ecx+6560], eax

; 1395 : 		deflate_compute_precode_items((u8 *)&c->codes.lens,
; 1396 : 					      c->num_litlen_syms +
; 1397 : 							c->num_offset_syms,
; 1398 : 					      c->precode_freqs,
; 1399 : 					      c->precode_items);
; 1400 : 
; 1401 : 	/* Build the precode. */
; 1402 : 	STATIC_ASSERT(MAX_PRE_CODEWORD_LEN <= DEFLATE_MAX_PRE_CODEWORD_LEN);
; 1403 : 	deflate_make_huffman_code(DEFLATE_NUM_PRECODE_SYMS,

  00143	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00146	05 48 14 00 00	 add	 eax, 5192		; 00001448H
  0014b	50		 push	 eax
  0014c	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0014f	81 c1 34 14 00
	00		 add	 ecx, 5172		; 00001434H
  00155	51		 push	 ecx
  00156	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00159	81 c2 e8 13 00
	00		 add	 edx, 5096		; 000013e8H
  0015f	52		 push	 edx
  00160	6a 07		 push	 7
  00162	6a 13		 push	 19			; 00000013H
  00164	e8 00 00 00 00	 call	 _deflate_make_huffman_code
  00169	83 c4 14	 add	 esp, 20			; 00000014H

; 1404 : 				  MAX_PRE_CODEWORD_LEN,
; 1405 : 				  c->precode_freqs, c->precode_lens,
; 1406 : 				  c->precode_codewords);
; 1407 : 
; 1408 : 	/* Count how many precode lengths we actually need to output. */
; 1409 : 	for (c->num_explicit_lens = DEFLATE_NUM_PRECODE_SYMS;

  0016c	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0016f	c7 80 9c 19 00
	00 13 00 00 00	 mov	 DWORD PTR [eax+6556], 19 ; 00000013H
  00179	eb 15		 jmp	 SHORT $LN10@deflate_pr
$LN8@deflate_pr:

; 1411 : 	     c->num_explicit_lens--)

  0017b	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0017e	8b 88 9c 19 00
	00		 mov	 ecx, DWORD PTR [eax+6556]
  00184	83 e9 01	 sub	 ecx, 1
  00187	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0018a	89 8a 9c 19 00
	00		 mov	 DWORD PTR [edx+6556], ecx
$LN10@deflate_pr:

; 1410 : 	     c->num_explicit_lens > 4;

  00190	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00193	83 b8 9c 19 00
	00 04		 cmp	 DWORD PTR [eax+6556], 4
  0019a	76 23		 jbe	 SHORT $LN9@deflate_pr

; 1412 : 		if (c->precode_lens[deflate_precode_lens_permutation[
; 1413 : 						c->num_explicit_lens - 1]] != 0)

  0019c	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0019f	8b 88 9c 19 00
	00		 mov	 ecx, DWORD PTR [eax+6556]
  001a5	0f b6 91 ff ff
	ff ff		 movzx	 edx, BYTE PTR _deflate_precode_lens_permutation[ecx-1]
  001ac	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001af	0f b6 8c 10 34
	14 00 00	 movzx	 ecx, BYTE PTR [eax+edx+5172]
  001b7	85 c9		 test	 ecx, ecx
  001b9	74 02		 je	 SHORT $LN14@deflate_pr

; 1414 : 			break;

  001bb	eb 02		 jmp	 SHORT $LN9@deflate_pr
$LN14@deflate_pr:
  001bd	eb bc		 jmp	 SHORT $LN8@deflate_pr
$LN9@deflate_pr:

; 1415 : 
; 1416 : 	/* Restore the offset codeword lengths if needed. */
; 1417 : 	if (c->num_litlen_syms != DEFLATE_NUM_LITLEN_SYMS) {

  001bf	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001c2	81 b8 94 19 00
	00 20 01 00 00	 cmp	 DWORD PTR [eax+6548], 288 ; 00000120H
  001cc	74 2f		 je	 SHORT $LN1@deflate_pr

; 1418 : 		memmove((u8 *)&c->codes.lens + DEFLATE_NUM_LITLEN_SYMS,

  001ce	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001d1	8b 88 98 19 00
	00		 mov	 ecx, DWORD PTR [eax+6552]
  001d7	51		 push	 ecx
  001d8	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  001db	8b 82 94 19 00
	00		 mov	 eax, DWORD PTR [edx+6548]
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  001e4	8d 94 01 04 0a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2564]
  001eb	52		 push	 edx
  001ec	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  001ef	05 24 0b 00 00	 add	 eax, 2852		; 00000b24H
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 _memmove
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@deflate_pr:

; 1419 : 			(u8 *)&c->codes.lens + c->num_litlen_syms,
; 1420 : 			c->num_offset_syms);
; 1421 : 	}
; 1422 : }

  001fd	5f		 pop	 edi
  001fe	5e		 pop	 esi
  001ff	5b		 pop	 ebx
  00200	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00206	3b ec		 cmp	 ebp, esp
  00208	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
_deflate_precompute_huffman_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_compute_precode_items
_TEXT	SEGMENT
tv170 = -256						; size = 4
tv137 = -256						; size = 4
tv85 = -256						; size = 4
_len$ = -53						; size = 1
_extra_bits$ = -44					; size = 4
_run_end$ = -32						; size = 4
_run_start$ = -20					; size = 4
_itemptr$ = -8						; size = 4
_lens$ = 8						; size = 4
_num_lens$ = 12						; size = 4
_precode_freqs$ = 16					; size = 4
_precode_items$ = 20					; size = 4
_deflate_compute_precode_items PROC			; COMDAT

; 1280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1281 : 	unsigned *itemptr;
; 1282 : 	unsigned run_start;
; 1283 : 	unsigned run_end;
; 1284 : 	unsigned extra_bits;
; 1285 : 	u8 len;
; 1286 : 
; 1287 : 	memset(precode_freqs, 0,

  00028	6a 4c		 push	 76			; 0000004cH
  0002a	6a 00		 push	 0
  0002c	8b 45 10	 mov	 eax, DWORD PTR _precode_freqs$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _memset
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1288 : 	       DEFLATE_NUM_PRECODE_SYMS * sizeof(precode_freqs[0]));
; 1289 : 
; 1290 : 	itemptr = precode_items;

  00038	8b 45 14	 mov	 eax, DWORD PTR _precode_items$[ebp]
  0003b	89 45 f8	 mov	 DWORD PTR _itemptr$[ebp], eax

; 1291 : 	run_start = 0;

  0003e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _run_start$[ebp], 0
$LN4@deflate_co:

; 1292 : 	do {
; 1293 : 		/* Find the next run of codeword lengths.  */
; 1294 : 
; 1295 : 		/* len = the length being repeated  */
; 1296 : 		len = lens[run_start];

  00045	8b 45 08	 mov	 eax, DWORD PTR _lens$[ebp]
  00048	03 45 ec	 add	 eax, DWORD PTR _run_start$[ebp]
  0004b	8a 08		 mov	 cl, BYTE PTR [eax]
  0004d	88 4d cb	 mov	 BYTE PTR _len$[ebp], cl

; 1297 : 
; 1298 : 		/* Extend the run.  */
; 1299 : 		run_end = run_start;

  00050	8b 45 ec	 mov	 eax, DWORD PTR _run_start$[ebp]
  00053	89 45 e0	 mov	 DWORD PTR _run_end$[ebp], eax
$LN7@deflate_co:

; 1300 : 		do {
; 1301 : 			run_end++;

  00056	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  00059	83 c0 01	 add	 eax, 1
  0005c	89 45 e0	 mov	 DWORD PTR _run_end$[ebp], eax

; 1302 : 		} while (run_end != num_lens && len == lens[run_end]);

  0005f	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  00062	3b 45 0c	 cmp	 eax, DWORD PTR _num_lens$[ebp]
  00065	74 11		 je	 SHORT $LN6@deflate_co
  00067	0f b6 45 cb	 movzx	 eax, BYTE PTR _len$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _lens$[ebp]
  0006e	03 4d e0	 add	 ecx, DWORD PTR _run_end$[ebp]
  00071	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00074	3b c2		 cmp	 eax, edx
  00076	74 de		 je	 SHORT $LN7@deflate_co
$LN6@deflate_co:

; 1303 : 
; 1304 : 		if (len == 0) {

  00078	0f b6 45 cb	 movzx	 eax, BYTE PTR _len$[ebp]
  0007c	85 c0		 test	 eax, eax
  0007e	0f 85 0a 01 00
	00		 jne	 $LN16@deflate_co
$LN8@deflate_co:

; 1305 : 			/* Run of zeroes.  */
; 1306 : 
; 1307 : 			/* Symbol 18: RLE 11 to 138 zeroes at a time.  */
; 1308 : 			while ((run_end - run_start) >= 11) {

  00084	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  00087	2b 45 ec	 sub	 eax, DWORD PTR _run_start$[ebp]
  0008a	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0008d	72 7a		 jb	 SHORT $LN9@deflate_co

; 1309 : 				extra_bits = MIN((run_end - run_start) - 11, 0x7F);

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  00092	2b 45 ec	 sub	 eax, DWORD PTR _run_start$[ebp]
  00095	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00098	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0009b	77 11		 ja	 SHORT $LN21@deflate_co
  0009d	8b 4d e0	 mov	 ecx, DWORD PTR _run_end$[ebp]
  000a0	2b 4d ec	 sub	 ecx, DWORD PTR _run_start$[ebp]
  000a3	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  000a6	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], ecx
  000ac	eb 0a		 jmp	 SHORT $LN22@deflate_co
$LN21@deflate_co:
  000ae	c7 85 00 ff ff
	ff 7f 00 00 00	 mov	 DWORD PTR tv85[ebp], 127 ; 0000007fH
$LN22@deflate_co:
  000b8	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv85[ebp]
  000be	89 55 d4	 mov	 DWORD PTR _extra_bits$[ebp], edx

; 1310 : 				precode_freqs[18]++;

  000c1	b8 04 00 00 00	 mov	 eax, 4
  000c6	6b c8 12	 imul	 ecx, eax, 18
  000c9	8b 55 10	 mov	 edx, DWORD PTR _precode_freqs$[ebp]
  000cc	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  000cf	83 c0 01	 add	 eax, 1
  000d2	b9 04 00 00 00	 mov	 ecx, 4
  000d7	6b d1 12	 imul	 edx, ecx, 18
  000da	8b 4d 10	 mov	 ecx, DWORD PTR _precode_freqs$[ebp]
  000dd	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 1311 : 				*itemptr++ = 18 | (extra_bits << 5);

  000e0	8b 45 d4	 mov	 eax, DWORD PTR _extra_bits$[ebp]
  000e3	c1 e0 05	 shl	 eax, 5
  000e6	83 c8 12	 or	 eax, 18			; 00000012H
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _itemptr$[ebp]
  000ec	89 01		 mov	 DWORD PTR [ecx], eax
  000ee	8b 55 f8	 mov	 edx, DWORD PTR _itemptr$[ebp]
  000f1	83 c2 04	 add	 edx, 4
  000f4	89 55 f8	 mov	 DWORD PTR _itemptr$[ebp], edx

; 1312 : 				run_start += 11 + extra_bits;

  000f7	8b 45 d4	 mov	 eax, DWORD PTR _extra_bits$[ebp]
  000fa	8b 4d ec	 mov	 ecx, DWORD PTR _run_start$[ebp]
  000fd	8d 54 01 0b	 lea	 edx, DWORD PTR [ecx+eax+11]
  00101	89 55 ec	 mov	 DWORD PTR _run_start$[ebp], edx

; 1313 : 			}

  00104	e9 7b ff ff ff	 jmp	 $LN8@deflate_co
$LN9@deflate_co:

; 1314 : 
; 1315 : 			/* Symbol 17: RLE 3 to 10 zeroes at a time.  */
; 1316 : 			if ((run_end - run_start) >= 3) {

  00109	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  0010c	2b 45 ec	 sub	 eax, DWORD PTR _run_start$[ebp]
  0010f	83 f8 03	 cmp	 eax, 3
  00112	72 75		 jb	 SHORT $LN18@deflate_co

; 1317 : 				extra_bits = MIN((run_end - run_start) - 3, 0x7);

  00114	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  00117	2b 45 ec	 sub	 eax, DWORD PTR _run_start$[ebp]
  0011a	83 e8 03	 sub	 eax, 3
  0011d	83 f8 07	 cmp	 eax, 7
  00120	77 11		 ja	 SHORT $LN23@deflate_co
  00122	8b 4d e0	 mov	 ecx, DWORD PTR _run_end$[ebp]
  00125	2b 4d ec	 sub	 ecx, DWORD PTR _run_start$[ebp]
  00128	83 e9 03	 sub	 ecx, 3
  0012b	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv137[ebp], ecx
  00131	eb 0a		 jmp	 SHORT $LN24@deflate_co
$LN23@deflate_co:
  00133	c7 85 00 ff ff
	ff 07 00 00 00	 mov	 DWORD PTR tv137[ebp], 7
$LN24@deflate_co:
  0013d	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv137[ebp]
  00143	89 55 d4	 mov	 DWORD PTR _extra_bits$[ebp], edx

; 1318 : 				precode_freqs[17]++;

  00146	b8 04 00 00 00	 mov	 eax, 4
  0014b	6b c8 11	 imul	 ecx, eax, 17
  0014e	8b 55 10	 mov	 edx, DWORD PTR _precode_freqs$[ebp]
  00151	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00154	83 c0 01	 add	 eax, 1
  00157	b9 04 00 00 00	 mov	 ecx, 4
  0015c	6b d1 11	 imul	 edx, ecx, 17
  0015f	8b 4d 10	 mov	 ecx, DWORD PTR _precode_freqs$[ebp]
  00162	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 1319 : 				*itemptr++ = 17 | (extra_bits << 5);

  00165	8b 45 d4	 mov	 eax, DWORD PTR _extra_bits$[ebp]
  00168	c1 e0 05	 shl	 eax, 5
  0016b	83 c8 11	 or	 eax, 17			; 00000011H
  0016e	8b 4d f8	 mov	 ecx, DWORD PTR _itemptr$[ebp]
  00171	89 01		 mov	 DWORD PTR [ecx], eax
  00173	8b 55 f8	 mov	 edx, DWORD PTR _itemptr$[ebp]
  00176	83 c2 04	 add	 edx, 4
  00179	89 55 f8	 mov	 DWORD PTR _itemptr$[ebp], edx

; 1320 : 				run_start += 3 + extra_bits;

  0017c	8b 45 d4	 mov	 eax, DWORD PTR _extra_bits$[ebp]
  0017f	8b 4d ec	 mov	 ecx, DWORD PTR _run_start$[ebp]
  00182	8d 54 01 03	 lea	 edx, DWORD PTR [ecx+eax+3]
  00186	89 55 ec	 mov	 DWORD PTR _run_start$[ebp], edx
$LN18@deflate_co:

; 1321 : 			}
; 1322 : 		} else {

  00189	e9 c1 00 00 00	 jmp	 $LN13@deflate_co
$LN16@deflate_co:

; 1323 : 
; 1324 : 			/* A run of nonzero lengths. */
; 1325 : 
; 1326 : 			/* Symbol 16: RLE 3 to 6 of the previous length.  */
; 1327 : 			if ((run_end - run_start) >= 4) {

  0018e	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  00191	2b 45 ec	 sub	 eax, DWORD PTR _run_start$[ebp]
  00194	83 f8 04	 cmp	 eax, 4
  00197	0f 82 b2 00 00
	00		 jb	 $LN13@deflate_co

; 1328 : 				precode_freqs[len]++;

  0019d	0f b6 45 cb	 movzx	 eax, BYTE PTR _len$[ebp]
  001a1	8b 4d 10	 mov	 ecx, DWORD PTR _precode_freqs$[ebp]
  001a4	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001a7	83 c2 01	 add	 edx, 1
  001aa	0f b6 45 cb	 movzx	 eax, BYTE PTR _len$[ebp]
  001ae	8b 4d 10	 mov	 ecx, DWORD PTR _precode_freqs$[ebp]
  001b1	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 1329 : 				*itemptr++ = len;

  001b4	0f b6 45 cb	 movzx	 eax, BYTE PTR _len$[ebp]
  001b8	8b 4d f8	 mov	 ecx, DWORD PTR _itemptr$[ebp]
  001bb	89 01		 mov	 DWORD PTR [ecx], eax
  001bd	8b 55 f8	 mov	 edx, DWORD PTR _itemptr$[ebp]
  001c0	83 c2 04	 add	 edx, 4
  001c3	89 55 f8	 mov	 DWORD PTR _itemptr$[ebp], edx

; 1330 : 				run_start++;

  001c6	8b 45 ec	 mov	 eax, DWORD PTR _run_start$[ebp]
  001c9	83 c0 01	 add	 eax, 1
  001cc	89 45 ec	 mov	 DWORD PTR _run_start$[ebp], eax
$LN12@deflate_co:

; 1331 : 				do {
; 1332 : 					extra_bits = MIN((run_end - run_start) - 3, 0x3);

  001cf	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  001d2	2b 45 ec	 sub	 eax, DWORD PTR _run_start$[ebp]
  001d5	83 e8 03	 sub	 eax, 3
  001d8	83 f8 03	 cmp	 eax, 3
  001db	77 11		 ja	 SHORT $LN25@deflate_co
  001dd	8b 4d e0	 mov	 ecx, DWORD PTR _run_end$[ebp]
  001e0	2b 4d ec	 sub	 ecx, DWORD PTR _run_start$[ebp]
  001e3	83 e9 03	 sub	 ecx, 3
  001e6	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv170[ebp], ecx
  001ec	eb 0a		 jmp	 SHORT $LN26@deflate_co
$LN25@deflate_co:
  001ee	c7 85 00 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR tv170[ebp], 3
$LN26@deflate_co:
  001f8	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv170[ebp]
  001fe	89 55 d4	 mov	 DWORD PTR _extra_bits$[ebp], edx

; 1333 : 					precode_freqs[16]++;

  00201	b8 04 00 00 00	 mov	 eax, 4
  00206	c1 e0 04	 shl	 eax, 4
  00209	8b 4d 10	 mov	 ecx, DWORD PTR _precode_freqs$[ebp]
  0020c	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0020f	83 c2 01	 add	 edx, 1
  00212	b8 04 00 00 00	 mov	 eax, 4
  00217	c1 e0 04	 shl	 eax, 4
  0021a	8b 4d 10	 mov	 ecx, DWORD PTR _precode_freqs$[ebp]
  0021d	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 1334 : 					*itemptr++ = 16 | (extra_bits << 5);

  00220	8b 45 d4	 mov	 eax, DWORD PTR _extra_bits$[ebp]
  00223	c1 e0 05	 shl	 eax, 5
  00226	83 c8 10	 or	 eax, 16			; 00000010H
  00229	8b 4d f8	 mov	 ecx, DWORD PTR _itemptr$[ebp]
  0022c	89 01		 mov	 DWORD PTR [ecx], eax
  0022e	8b 55 f8	 mov	 edx, DWORD PTR _itemptr$[ebp]
  00231	83 c2 04	 add	 edx, 4
  00234	89 55 f8	 mov	 DWORD PTR _itemptr$[ebp], edx

; 1335 : 					run_start += 3 + extra_bits;

  00237	8b 45 d4	 mov	 eax, DWORD PTR _extra_bits$[ebp]
  0023a	8b 4d ec	 mov	 ecx, DWORD PTR _run_start$[ebp]
  0023d	8d 54 01 03	 lea	 edx, DWORD PTR [ecx+eax+3]
  00241	89 55 ec	 mov	 DWORD PTR _run_start$[ebp], edx

; 1336 : 				} while ((run_end - run_start) >= 3);

  00244	8b 45 e0	 mov	 eax, DWORD PTR _run_end$[ebp]
  00247	2b 45 ec	 sub	 eax, DWORD PTR _run_start$[ebp]
  0024a	83 f8 03	 cmp	 eax, 3
  0024d	73 80		 jae	 SHORT $LN12@deflate_co
$LN13@deflate_co:

; 1337 : 			}
; 1338 : 		}
; 1339 : 
; 1340 : 		/* Output any remaining lengths without RLE.  */
; 1341 : 		while (run_start != run_end) {

  0024f	8b 45 ec	 mov	 eax, DWORD PTR _run_start$[ebp]
  00252	3b 45 e0	 cmp	 eax, DWORD PTR _run_end$[ebp]
  00255	74 34		 je	 SHORT $LN2@deflate_co

; 1342 : 			precode_freqs[len]++;

  00257	0f b6 45 cb	 movzx	 eax, BYTE PTR _len$[ebp]
  0025b	8b 4d 10	 mov	 ecx, DWORD PTR _precode_freqs$[ebp]
  0025e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00261	83 c2 01	 add	 edx, 1
  00264	0f b6 45 cb	 movzx	 eax, BYTE PTR _len$[ebp]
  00268	8b 4d 10	 mov	 ecx, DWORD PTR _precode_freqs$[ebp]
  0026b	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 1343 : 			*itemptr++ = len;

  0026e	0f b6 45 cb	 movzx	 eax, BYTE PTR _len$[ebp]
  00272	8b 4d f8	 mov	 ecx, DWORD PTR _itemptr$[ebp]
  00275	89 01		 mov	 DWORD PTR [ecx], eax
  00277	8b 55 f8	 mov	 edx, DWORD PTR _itemptr$[ebp]
  0027a	83 c2 04	 add	 edx, 4
  0027d	89 55 f8	 mov	 DWORD PTR _itemptr$[ebp], edx

; 1344 : 			run_start++;

  00280	8b 45 ec	 mov	 eax, DWORD PTR _run_start$[ebp]
  00283	83 c0 01	 add	 eax, 1
  00286	89 45 ec	 mov	 DWORD PTR _run_start$[ebp], eax

; 1345 : 		}

  00289	eb c4		 jmp	 SHORT $LN13@deflate_co
$LN2@deflate_co:

; 1346 : 	} while (run_start != num_lens);

  0028b	8b 45 ec	 mov	 eax, DWORD PTR _run_start$[ebp]
  0028e	3b 45 0c	 cmp	 eax, DWORD PTR _num_lens$[ebp]
  00291	0f 85 ae fd ff
	ff		 jne	 $LN4@deflate_co

; 1347 : 
; 1348 : 	return itemptr - precode_items;

  00297	8b 45 f8	 mov	 eax, DWORD PTR _itemptr$[ebp]
  0029a	2b 45 14	 sub	 eax, DWORD PTR _precode_items$[ebp]
  0029d	c1 f8 02	 sar	 eax, 2

; 1349 : }

  002a0	5f		 pop	 edi
  002a1	5e		 pop	 esi
  002a2	5b		 pop	 ebx
  002a3	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  002a9	3b ec		 cmp	 ebp, esp
  002ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b0	8b e5		 mov	 esp, ebp
  002b2	5d		 pop	 ebp
  002b3	c3		 ret	 0
_deflate_compute_precode_items ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_write_block_header
_TEXT	SEGMENT
_os$ = 8						; size = 4
_is_final_block$ = 12					; size = 4
_block_type$ = 16					; size = 4
_deflate_write_block_header PROC			; COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1270 : 	deflate_add_bits(os, is_final_block, 1);

  00028	6a 01		 push	 1
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _is_final_block$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _deflate_add_bits
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 	deflate_add_bits(os, block_type, 2);

  0003a	6a 02		 push	 2
  0003c	8b 45 10	 mov	 eax, DWORD PTR _block_type$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _deflate_add_bits
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1272 : 	deflate_flush_bits(os);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _deflate_flush_bits
  00055	83 c4 04	 add	 esp, 4

; 1273 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_deflate_write_block_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_get_offset_slot
_TEXT	SEGMENT
_c$ = 8							; size = 4
_offset$ = 12						; size = 4
_deflate_get_offset_slot PROC				; COMDAT

; 1254 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1255 : #if USE_FULL_OFFSET_SLOT_FAST
; 1256 : 	return c->offset_slot_fast[offset];
; 1257 : #else
; 1258 : 	if (offset <= 256)

  00028	81 7d 0c 00 01
	00 00		 cmp	 DWORD PTR _offset$[ebp], 256 ; 00000100H
  0002f	77 11		 ja	 SHORT $LN2@deflate_ge

; 1259 : 		return c->offset_slot_fast[offset - 1];

  00031	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00034	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  00037	0f b6 80 db 11
	00 00		 movzx	 eax, BYTE PTR [eax+4571]
  0003e	eb 16		 jmp	 SHORT $LN1@deflate_ge
  00040	eb 14		 jmp	 SHORT $LN1@deflate_ge
$LN2@deflate_ge:

; 1260 : 	else
; 1261 : 		return c->offset_slot_fast[256 + ((offset - 1) >> 7)];

  00042	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00045	83 e8 01	 sub	 eax, 1
  00048	c1 e8 07	 shr	 eax, 7
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0004e	0f b6 84 01 dc
	12 00 00	 movzx	 eax, BYTE PTR [ecx+eax+4828]
$LN1@deflate_ge:

; 1262 : #endif
; 1263 : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_deflate_get_offset_slot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_init_static_codes
_TEXT	SEGMENT
_i$ = -8						; size = 4
_c$ = 8							; size = 4
_deflate_init_static_codes PROC				; COMDAT

; 1233 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1234 : 	unsigned i;
; 1235 : 
; 1236 : 	for (i = 0; i < 144; i++)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@deflate_in
$LN2@deflate_in:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@deflate_in:
  0003a	81 7d f8 90 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 144	; 00000090H
  00041	73 10		 jae	 SHORT $LN3@deflate_in

; 1237 : 		c->freqs.litlen[i] = 1 << (9 - 8);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00049	c7 44 81 04 02
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+4], 2
  00051	eb de		 jmp	 SHORT $LN2@deflate_in
$LN3@deflate_in:

; 1238 : 	for (; i < 256; i++)

  00053	eb 09		 jmp	 SHORT $LN7@deflate_in
$LN5@deflate_in:
  00055	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@deflate_in:
  0005e	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00065	73 10		 jae	 SHORT $LN6@deflate_in

; 1239 : 		c->freqs.litlen[i] = 1 << (9 - 9);

  00067	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0006d	c7 44 81 04 01
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+4], 1
  00075	eb de		 jmp	 SHORT $LN5@deflate_in
$LN6@deflate_in:

; 1240 : 	for (; i < 280; i++)

  00077	eb 09		 jmp	 SHORT $LN10@deflate_in
$LN8@deflate_in:
  00079	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007c	83 c0 01	 add	 eax, 1
  0007f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@deflate_in:
  00082	81 7d f8 18 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 280	; 00000118H
  00089	73 10		 jae	 SHORT $LN9@deflate_in

; 1241 : 		c->freqs.litlen[i] = 1 << (9 - 7);

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00091	c7 44 81 04 04
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+4], 4
  00099	eb de		 jmp	 SHORT $LN8@deflate_in
$LN9@deflate_in:

; 1242 : 	for (; i < 288; i++)

  0009b	eb 09		 jmp	 SHORT $LN13@deflate_in
$LN11@deflate_in:
  0009d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a0	83 c0 01	 add	 eax, 1
  000a3	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN13@deflate_in:
  000a6	81 7d f8 20 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 288	; 00000120H
  000ad	73 10		 jae	 SHORT $LN12@deflate_in

; 1243 : 		c->freqs.litlen[i] = 1 << (9 - 8);

  000af	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  000b5	c7 44 81 04 02
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+4], 2
  000bd	eb de		 jmp	 SHORT $LN11@deflate_in
$LN12@deflate_in:

; 1244 : 
; 1245 : 	for (i = 0; i < 32; i++)

  000bf	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c6	eb 09		 jmp	 SHORT $LN16@deflate_in
$LN14@deflate_in:
  000c8	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000cb	83 c0 01	 add	 eax, 1
  000ce	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN16@deflate_in:
  000d1	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000d5	73 13		 jae	 SHORT $LN15@deflate_in

; 1246 : 		c->freqs.offset[i] = 1 << (5 - 5);

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  000dd	c7 84 81 84 04
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+1156], 1
  000e8	eb de		 jmp	 SHORT $LN14@deflate_in
$LN15@deflate_in:

; 1247 : 
; 1248 : 	deflate_make_huffman_codes(&c->freqs, &c->static_codes);

  000ea	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000ed	05 44 0b 00 00	 add	 eax, 2884		; 00000b44H
  000f2	50		 push	 eax
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  000f6	83 c1 04	 add	 ecx, 4
  000f9	51		 push	 ecx
  000fa	e8 00 00 00 00	 call	 _deflate_make_huffman_codes
  000ff	83 c4 08	 add	 esp, 8

; 1249 : }

  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	5b		 pop	 ebx
  00105	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0010b	3b ec		 cmp	 ebp, esp
  0010d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
_deflate_init_static_codes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_make_huffman_codes
_TEXT	SEGMENT
_freqs$ = 8						; size = 4
_codes$ = 12						; size = 4
_deflate_make_huffman_codes PROC			; COMDAT

; 1213 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1214 : 	STATIC_ASSERT(MAX_LITLEN_CODEWORD_LEN <= DEFLATE_MAX_LITLEN_CODEWORD_LEN);
; 1215 : 	STATIC_ASSERT(MAX_OFFSET_CODEWORD_LEN <= DEFLATE_MAX_OFFSET_CODEWORD_LEN);
; 1216 : 
; 1217 : 	deflate_make_huffman_code(DEFLATE_NUM_LITLEN_SYMS,

  00028	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _codes$[ebp]
  0002f	81 c1 00 05 00
	00		 add	 ecx, 1280		; 00000500H
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR _freqs$[ebp]
  00039	52		 push	 edx
  0003a	6a 0e		 push	 14			; 0000000eH
  0003c	68 20 01 00 00	 push	 288			; 00000120H
  00041	e8 00 00 00 00	 call	 _deflate_make_huffman_code
  00046	83 c4 14	 add	 esp, 20			; 00000014H

; 1218 : 				  MAX_LITLEN_CODEWORD_LEN,
; 1219 : 				  freqs->litlen,
; 1220 : 				  codes->lens.litlen,
; 1221 : 				  codes->codewords.litlen);
; 1222 : 
; 1223 : 	deflate_make_huffman_code(DEFLATE_NUM_OFFSET_SYMS,

  00049	8b 45 0c	 mov	 eax, DWORD PTR _codes$[ebp]
  0004c	05 80 04 00 00	 add	 eax, 1152		; 00000480H
  00051	50		 push	 eax
  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _codes$[ebp]
  00055	81 c1 20 06 00
	00		 add	 ecx, 1568		; 00000620H
  0005b	51		 push	 ecx
  0005c	8b 55 08	 mov	 edx, DWORD PTR _freqs$[ebp]
  0005f	81 c2 80 04 00
	00		 add	 edx, 1152		; 00000480H
  00065	52		 push	 edx
  00066	6a 0f		 push	 15			; 0000000fH
  00068	6a 20		 push	 32			; 00000020H
  0006a	e8 00 00 00 00	 call	 _deflate_make_huffman_code
  0006f	83 c4 14	 add	 esp, 20			; 00000014H

; 1224 : 				  MAX_OFFSET_CODEWORD_LEN,
; 1225 : 				  freqs->offset,
; 1226 : 				  codes->lens.offset,
; 1227 : 				  codes->codewords.offset);
; 1228 : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_deflate_make_huffman_codes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_make_huffman_code
_TEXT	SEGMENT
_sym$ = -8						; size = 4
_num_syms$ = 8						; size = 4
_max_codeword_len$ = 12					; size = 4
_freqs$ = 16						; size = 4
_lens$ = 20						; size = 4
_codewords$ = 24					; size = 4
_deflate_make_huffman_code PROC				; COMDAT

; 1194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1195 : 	unsigned sym;
; 1196 : 
; 1197 : 	make_canonical_huffman_code(num_syms, max_codeword_len,

  00028	8b 45 18	 mov	 eax, DWORD PTR _codewords$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _lens$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 10	 mov	 edx, DWORD PTR _freqs$[ebp]
  00033	52		 push	 edx
  00034	8b 45 0c	 mov	 eax, DWORD PTR _max_codeword_len$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _num_syms$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _make_canonical_huffman_code
  00041	83 c4 14	 add	 esp, 20			; 00000014H

; 1198 : 				    freqs, lens, codewords);
; 1199 : 
; 1200 : 	for (sym = 0; sym < num_syms; sym++)

  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@deflate_ma
$LN2@deflate_ma:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _sym$[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 f8	 mov	 DWORD PTR _sym$[ebp], eax
$LN4@deflate_ma:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _sym$[ebp]
  00059	3b 45 08	 cmp	 eax, DWORD PTR _num_syms$[ebp]
  0005c	73 27		 jae	 SHORT $LN1@deflate_ma

; 1201 : 		codewords[sym] = deflate_reverse_codeword(codewords[sym], lens[sym]);

  0005e	8b 45 14	 mov	 eax, DWORD PTR _lens$[ebp]
  00061	03 45 f8	 add	 eax, DWORD PTR _sym$[ebp]
  00064	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00067	51		 push	 ecx
  00068	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  0006b	8b 45 18	 mov	 eax, DWORD PTR _codewords$[ebp]
  0006e	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _deflate_reverse_codeword
  00077	83 c4 08	 add	 esp, 8
  0007a	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  0007d	8b 4d 18	 mov	 ecx, DWORD PTR _codewords$[ebp]
  00080	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  00083	eb c8		 jmp	 SHORT $LN2@deflate_ma
$LN1@deflate_ma:

; 1202 : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_deflate_make_huffman_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_reverse_codeword
_TEXT	SEGMENT
_codeword$ = 8						; size = 4
_len$ = 12						; size = 1
_deflate_reverse_codeword PROC				; COMDAT

; 1168 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1169 : 	/* The following branchless algorithm is faster than going bit by bit.
; 1170 : 	 * Note: since no codewords are longer than 16 bits, we only need to
; 1171 : 	 * reverse the low 16 bits of the 'u32'.  */
; 1172 : 	STATIC_ASSERT(DEFLATE_MAX_CODEWORD_LEN <= 16);
; 1173 : 
; 1174 : 	/* Flip adjacent 1-bit fields  */
; 1175 : 	codeword = ((codeword & 0x5555) << 1) | ((codeword & 0xAAAA) >> 1);

  00028	8b 45 08	 mov	 eax, DWORD PTR _codeword$[ebp]
  0002b	25 55 55 00 00	 and	 eax, 21845		; 00005555H
  00030	d1 e0		 shl	 eax, 1
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _codeword$[ebp]
  00035	81 e1 aa aa 00
	00		 and	 ecx, 43690		; 0000aaaaH
  0003b	d1 e9		 shr	 ecx, 1
  0003d	0b c1		 or	 eax, ecx
  0003f	89 45 08	 mov	 DWORD PTR _codeword$[ebp], eax

; 1176 : 
; 1177 : 	/* Flip adjacent 2-bit fields  */
; 1178 : 	codeword = ((codeword & 0x3333) << 2) | ((codeword & 0xCCCC) >> 2);

  00042	8b 45 08	 mov	 eax, DWORD PTR _codeword$[ebp]
  00045	25 33 33 00 00	 and	 eax, 13107		; 00003333H
  0004a	c1 e0 02	 shl	 eax, 2
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _codeword$[ebp]
  00050	81 e1 cc cc 00
	00		 and	 ecx, 52428		; 0000ccccH
  00056	c1 e9 02	 shr	 ecx, 2
  00059	0b c1		 or	 eax, ecx
  0005b	89 45 08	 mov	 DWORD PTR _codeword$[ebp], eax

; 1179 : 
; 1180 : 	/* Flip adjacent 4-bit fields  */
; 1181 : 	codeword = ((codeword & 0x0F0F) << 4) | ((codeword & 0xF0F0) >> 4);

  0005e	8b 45 08	 mov	 eax, DWORD PTR _codeword$[ebp]
  00061	25 0f 0f 00 00	 and	 eax, 3855		; 00000f0fH
  00066	c1 e0 04	 shl	 eax, 4
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _codeword$[ebp]
  0006c	81 e1 f0 f0 00
	00		 and	 ecx, 61680		; 0000f0f0H
  00072	c1 e9 04	 shr	 ecx, 4
  00075	0b c1		 or	 eax, ecx
  00077	89 45 08	 mov	 DWORD PTR _codeword$[ebp], eax

; 1182 : 
; 1183 : 	/* Flip adjacent 8-bit fields  */
; 1184 : 	codeword = ((codeword & 0x00FF) << 8) | ((codeword & 0xFF00) >> 8);

  0007a	8b 45 08	 mov	 eax, DWORD PTR _codeword$[ebp]
  0007d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00082	c1 e0 08	 shl	 eax, 8
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _codeword$[ebp]
  00088	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0008e	c1 e9 08	 shr	 ecx, 8
  00091	0b c1		 or	 eax, ecx
  00093	89 45 08	 mov	 DWORD PTR _codeword$[ebp], eax

; 1185 : 
; 1186 : 	/* Return the high 'len' bits of the bit-reversed 16 bit value.  */
; 1187 : 	return codeword >> (16 - len);

  00096	0f b6 45 0c	 movzx	 eax, BYTE PTR _len$[ebp]
  0009a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0009f	2b c8		 sub	 ecx, eax
  000a1	8b 45 08	 mov	 eax, DWORD PTR _codeword$[ebp]
  000a4	d3 e8		 shr	 eax, cl

; 1188 : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_deflate_reverse_codeword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_reset_symbol_frequencies
_TEXT	SEGMENT
_c$ = 8							; size = 4
_deflate_reset_symbol_frequencies PROC			; COMDAT

; 1161 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1162 : 	memset(&c->freqs, 0, sizeof(c->freqs));

  00028	68 00 05 00 00	 push	 1280			; 00000500H
  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00032	83 c0 04	 add	 eax, 4
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1163 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_deflate_reset_symbol_frequencies ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _make_canonical_huffman_code
_TEXT	SEGMENT
tv75 = -320						; size = 4
_len_counts$1 = -120					; size = 64
_nonzero_idx$2 = -48					; size = 4
_sym$3 = -36						; size = 4
_num_used_syms$ = -24					; size = 4
_A$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_num_syms$ = 8						; size = 4
_max_codeword_len$ = 12					; size = 4
_freqs$ = 16						; size = 4
_lens$ = 20						; size = 4
_codewords$ = 24					; size = 4
_make_canonical_huffman_code PROC			; COMDAT

; 1091 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-320]
  00012	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1092 : 	u32 *A = codewords;

  00032	8b 45 18	 mov	 eax, DWORD PTR _codewords$[ebp]
  00035	89 45 f4	 mov	 DWORD PTR _A$[ebp], eax

; 1093 : 	unsigned num_used_syms;
; 1094 : 
; 1095 : 	STATIC_ASSERT(DEFLATE_MAX_NUM_SYMS <= 1 << NUM_SYMBOL_BITS);
; 1096 : 
; 1097 : 	/* We begin by sorting the symbols primarily by frequency and
; 1098 : 	 * secondarily by symbol value.  As an optimization, the array
; 1099 : 	 * used for this purpose ('A') shares storage with the space in
; 1100 : 	 * which we will eventually return the codewords.  */
; 1101 : 
; 1102 : 	num_used_syms = sort_symbols(num_syms, freqs, lens, A);

  00038	8b 45 f4	 mov	 eax, DWORD PTR _A$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 14	 mov	 ecx, DWORD PTR _lens$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 10	 mov	 edx, DWORD PTR _freqs$[ebp]
  00043	52		 push	 edx
  00044	8b 45 08	 mov	 eax, DWORD PTR _num_syms$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _sort_symbols
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	89 45 e8	 mov	 DWORD PTR _num_used_syms$[ebp], eax

; 1103 : 
; 1104 : 	/* 'num_used_syms' is the number of symbols with nonzero
; 1105 : 	 * frequency.  This may be less than @num_syms.  'num_used_syms'
; 1106 : 	 * is also the number of entries in 'A' that are valid.  Each
; 1107 : 	 * entry consists of a distinct symbol and a nonzero frequency
; 1108 : 	 * packed into a 32-bit integer.  */
; 1109 : 
; 1110 : 	/* Handle special cases where only 0 or 1 symbols were used (had
; 1111 : 	 * nonzero frequency).  */
; 1112 : 
; 1113 : 	if (unlikely(num_used_syms == 0)) {

  00053	83 7d e8 00	 cmp	 DWORD PTR _num_used_syms$[ebp], 0
  00057	75 05		 jne	 SHORT $LN2@make_canon

; 1114 : 		/* Code is empty.  sort_symbols() already set all lengths
; 1115 : 		 * to 0, so there is nothing more to do.  */
; 1116 : 		return;

  00059	e9 bc 00 00 00	 jmp	 $LN1@make_canon
$LN2@make_canon:

; 1117 : 	}
; 1118 : 
; 1119 : 	if (unlikely(num_used_syms == 1)) {

  0005e	83 7d e8 01	 cmp	 DWORD PTR _num_used_syms$[ebp], 1
  00062	75 6f		 jne	 SHORT $LN3@make_canon

; 1120 : 		/* Only one symbol was used, so we only need one
; 1121 : 		 * codeword.  But two codewords are needed to form the
; 1122 : 		 * smallest complete Huffman code, which uses codewords 0
; 1123 : 		 * and 1.  Therefore, we choose another symbol to which
; 1124 : 		 * to assign a codeword.  We use 0 (if the used symbol is
; 1125 : 		 * not 0) or 1 (if the used symbol is 0).  In either
; 1126 : 		 * case, the lesser-valued symbol must be assigned
; 1127 : 		 * codeword 0 so that the resulting code is canonical.  */
; 1128 : 
; 1129 : 		unsigned sym = A[0] & SYMBOL_MASK;

  00064	b8 04 00 00 00	 mov	 eax, 4
  00069	6b c8 00	 imul	 ecx, eax, 0
  0006c	8b 55 f4	 mov	 edx, DWORD PTR _A$[ebp]
  0006f	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00072	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00077	89 45 dc	 mov	 DWORD PTR _sym$3[ebp], eax

; 1130 : 		unsigned nonzero_idx = sym ? sym : 1;

  0007a	74 0b		 je	 SHORT $LN5@make_canon
  0007c	8b 45 dc	 mov	 eax, DWORD PTR _sym$3[ebp]
  0007f	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00085	eb 0a		 jmp	 SHORT $LN6@make_canon
$LN5@make_canon:
  00087	c7 85 c0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv75[ebp], 1
$LN6@make_canon:
  00091	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  00097	89 4d d0	 mov	 DWORD PTR _nonzero_idx$2[ebp], ecx

; 1131 : 
; 1132 : 		codewords[0] = 0;

  0009a	b8 04 00 00 00	 mov	 eax, 4
  0009f	6b c8 00	 imul	 ecx, eax, 0
  000a2	8b 55 18	 mov	 edx, DWORD PTR _codewords$[ebp]
  000a5	c7 04 0a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx], 0

; 1133 : 		lens[0] = 1;

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	6b c8 00	 imul	 ecx, eax, 0
  000b4	8b 55 14	 mov	 edx, DWORD PTR _lens$[ebp]
  000b7	c6 04 0a 01	 mov	 BYTE PTR [edx+ecx], 1

; 1134 : 		codewords[nonzero_idx] = 1;

  000bb	8b 45 d0	 mov	 eax, DWORD PTR _nonzero_idx$2[ebp]
  000be	8b 4d 18	 mov	 ecx, DWORD PTR _codewords$[ebp]
  000c1	c7 04 81 01 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 1

; 1135 : 		lens[nonzero_idx] = 1;

  000c8	8b 45 14	 mov	 eax, DWORD PTR _lens$[ebp]
  000cb	03 45 d0	 add	 eax, DWORD PTR _nonzero_idx$2[ebp]
  000ce	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1136 : 		return;

  000d1	eb 47		 jmp	 SHORT $LN1@make_canon
$LN3@make_canon:

; 1137 : 	}
; 1138 : 
; 1139 : 	/* Build a stripped-down version of the Huffman tree, sharing the
; 1140 : 	 * array 'A' with the symbol values.  Then extract length counts
; 1141 : 	 * from the tree and use them to generate the final codewords.  */
; 1142 : 
; 1143 : 	build_tree(A, num_used_syms);

  000d3	8b 45 e8	 mov	 eax, DWORD PTR _num_used_syms$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR _A$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _build_tree
  000e0	83 c4 08	 add	 esp, 8

; 1144 : 
; 1145 : 	{
; 1146 : 		unsigned len_counts[DEFLATE_MAX_CODEWORD_LEN + 1];
; 1147 : 
; 1148 : 		compute_length_counts(A, num_used_syms - 2,

  000e3	8b 45 0c	 mov	 eax, DWORD PTR _max_codeword_len$[ebp]
  000e6	50		 push	 eax
  000e7	8d 4d 88	 lea	 ecx, DWORD PTR _len_counts$1[ebp]
  000ea	51		 push	 ecx
  000eb	8b 55 e8	 mov	 edx, DWORD PTR _num_used_syms$[ebp]
  000ee	83 ea 02	 sub	 edx, 2
  000f1	52		 push	 edx
  000f2	8b 45 f4	 mov	 eax, DWORD PTR _A$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _compute_length_counts
  000fb	83 c4 10	 add	 esp, 16			; 00000010H

; 1149 : 				      len_counts, max_codeword_len);
; 1150 : 
; 1151 : 		gen_codewords(A, lens, len_counts, max_codeword_len, num_syms);

  000fe	8b 45 08	 mov	 eax, DWORD PTR _num_syms$[ebp]
  00101	50		 push	 eax
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _max_codeword_len$[ebp]
  00105	51		 push	 ecx
  00106	8d 55 88	 lea	 edx, DWORD PTR _len_counts$1[ebp]
  00109	52		 push	 edx
  0010a	8b 45 14	 mov	 eax, DWORD PTR _lens$[ebp]
  0010d	50		 push	 eax
  0010e	8b 4d f4	 mov	 ecx, DWORD PTR _A$[ebp]
  00111	51		 push	 ecx
  00112	e8 00 00 00 00	 call	 _gen_codewords
  00117	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@make_canon:

; 1152 : 	}
; 1153 : }

  0011a	52		 push	 edx
  0011b	8b cd		 mov	 ecx, ebp
  0011d	50		 push	 eax
  0011e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@make_canon
  00124	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00129	58		 pop	 eax
  0012a	5a		 pop	 edx
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00131	33 cd		 xor	 ecx, ebp
  00133	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00138	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  0013e	3b ec		 cmp	 ebp, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
  00149	0f 1f 00	 npad	 3
$LN9@make_canon:
  0014c	01 00 00 00	 DD	 1
  00150	00 00 00 00	 DD	 $LN8@make_canon
$LN8@make_canon:
  00154	88 ff ff ff	 DD	 -120			; ffffff88H
  00158	40 00 00 00	 DD	 64			; 00000040H
  0015c	00 00 00 00	 DD	 $LN7@make_canon
$LN7@make_canon:
  00160	6c		 DB	 108			; 0000006cH
  00161	65		 DB	 101			; 00000065H
  00162	6e		 DB	 110			; 0000006eH
  00163	5f		 DB	 95			; 0000005fH
  00164	63		 DB	 99			; 00000063H
  00165	6f		 DB	 111			; 0000006fH
  00166	75		 DB	 117			; 00000075H
  00167	6e		 DB	 110			; 0000006eH
  00168	74		 DB	 116			; 00000074H
  00169	73		 DB	 115			; 00000073H
  0016a	00		 DB	 0
_make_canonical_huffman_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _gen_codewords
_TEXT	SEGMENT
tv69 = -316						; size = 4
_count$1 = -116						; size = 4
_sym$ = -104						; size = 4
_len$ = -92						; size = 4
_i$ = -80						; size = 4
_next_codewords$ = -68					; size = 64
_A$ = 8							; size = 4
_lens$ = 12						; size = 4
_len_counts$ = 16					; size = 4
_max_codeword_len$ = 20					; size = 4
_num_syms$ = 24						; size = 4
_gen_codewords PROC					; COMDAT

; 948  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-316]
  00012	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 949  : 	u32 next_codewords[DEFLATE_MAX_CODEWORD_LEN + 1];
; 950  : 	unsigned i;
; 951  : 	unsigned len;
; 952  : 	unsigned sym;
; 953  : 
; 954  : 	/* Given the number of codewords that will have each length,
; 955  : 	 * assign codeword lengths to symbols.  We do this by assigning
; 956  : 	 * the lengths in decreasing order to the symbols sorted
; 957  : 	 * primarily by increasing frequency and secondarily by
; 958  : 	 * increasing symbol value.  */
; 959  : 	for (i = 0, len = max_codeword_len; len >= 1; len--) {

  00028	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	8b 45 14	 mov	 eax, DWORD PTR _max_codeword_len$[ebp]
  00032	89 45 a4	 mov	 DWORD PTR _len$[ebp], eax
  00035	eb 09		 jmp	 SHORT $LN4@gen_codewo
$LN2@gen_codewo:
  00037	8b 45 a4	 mov	 eax, DWORD PTR _len$[ebp]
  0003a	83 e8 01	 sub	 eax, 1
  0003d	89 45 a4	 mov	 DWORD PTR _len$[ebp], eax
$LN4@gen_codewo:
  00040	83 7d a4 01	 cmp	 DWORD PTR _len$[ebp], 1
  00044	72 4c		 jb	 SHORT $LN3@gen_codewo

; 960  : 		unsigned count = len_counts[len];

  00046	8b 45 a4	 mov	 eax, DWORD PTR _len$[ebp]
  00049	8b 4d 10	 mov	 ecx, DWORD PTR _len_counts$[ebp]
  0004c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0004f	89 55 8c	 mov	 DWORD PTR _count$1[ebp], edx
$LN5@gen_codewo:

; 961  : 		while (count--)

  00052	8b 45 8c	 mov	 eax, DWORD PTR _count$1[ebp]
  00055	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0005b	8b 4d 8c	 mov	 ecx, DWORD PTR _count$1[ebp]
  0005e	83 e9 01	 sub	 ecx, 1
  00061	89 4d 8c	 mov	 DWORD PTR _count$1[ebp], ecx
  00064	83 bd c4 fe ff
	ff 00		 cmp	 DWORD PTR tv69[ebp], 0
  0006b	74 23		 je	 SHORT $LN6@gen_codewo

; 962  : 			lens[A[i++] & SYMBOL_MASK] = len;

  0006d	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00073	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00076	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0007c	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  0007f	8a 4d a4	 mov	 cl, BYTE PTR _len$[ebp]
  00082	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00085	8b 55 b0	 mov	 edx, DWORD PTR _i$[ebp]
  00088	83 c2 01	 add	 edx, 1
  0008b	89 55 b0	 mov	 DWORD PTR _i$[ebp], edx
  0008e	eb c2		 jmp	 SHORT $LN5@gen_codewo
$LN6@gen_codewo:

; 963  : 	}

  00090	eb a5		 jmp	 SHORT $LN2@gen_codewo
$LN3@gen_codewo:

; 964  : 
; 965  : 	/* Generate the codewords themselves.  We initialize the
; 966  : 	 * 'next_codewords' array to provide the lexicographically first
; 967  : 	 * codeword of each length, then assign codewords in symbol
; 968  : 	 * order.  This produces a canonical code.  */
; 969  : 	next_codewords[0] = 0;

  00092	b8 04 00 00 00	 mov	 eax, 4
  00097	6b c8 00	 imul	 ecx, eax, 0
  0009a	c7 44 0d bc 00
	00 00 00	 mov	 DWORD PTR _next_codewords$[ebp+ecx], 0

; 970  : 	next_codewords[1] = 0;

  000a2	b8 04 00 00 00	 mov	 eax, 4
  000a7	c1 e0 00	 shl	 eax, 0
  000aa	c7 44 05 bc 00
	00 00 00	 mov	 DWORD PTR _next_codewords$[ebp+eax], 0

; 971  : 	for (len = 2; len <= max_codeword_len; len++)

  000b2	c7 45 a4 02 00
	00 00		 mov	 DWORD PTR _len$[ebp], 2
  000b9	eb 09		 jmp	 SHORT $LN9@gen_codewo
$LN7@gen_codewo:
  000bb	8b 45 a4	 mov	 eax, DWORD PTR _len$[ebp]
  000be	83 c0 01	 add	 eax, 1
  000c1	89 45 a4	 mov	 DWORD PTR _len$[ebp], eax
$LN9@gen_codewo:
  000c4	8b 45 a4	 mov	 eax, DWORD PTR _len$[ebp]
  000c7	3b 45 14	 cmp	 eax, DWORD PTR _max_codeword_len$[ebp]
  000ca	77 1c		 ja	 SHORT $LN8@gen_codewo

; 972  : 		next_codewords[len] =

  000cc	8b 45 a4	 mov	 eax, DWORD PTR _len$[ebp]
  000cf	8b 4c 85 b8	 mov	 ecx, DWORD PTR _next_codewords$[ebp+eax*4-4]
  000d3	8b 55 a4	 mov	 edx, DWORD PTR _len$[ebp]
  000d6	8b 45 10	 mov	 eax, DWORD PTR _len_counts$[ebp]
  000d9	03 4c 90 fc	 add	 ecx, DWORD PTR [eax+edx*4-4]
  000dd	d1 e1		 shl	 ecx, 1
  000df	8b 55 a4	 mov	 edx, DWORD PTR _len$[ebp]
  000e2	89 4c 95 bc	 mov	 DWORD PTR _next_codewords$[ebp+edx*4], ecx
  000e6	eb d3		 jmp	 SHORT $LN7@gen_codewo
$LN8@gen_codewo:

; 973  : 			(next_codewords[len - 1] + len_counts[len - 1]) << 1;
; 974  : 
; 975  : 	for (sym = 0; sym < num_syms; sym++)

  000e8	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  000ef	eb 09		 jmp	 SHORT $LN12@gen_codewo
$LN10@gen_codewo:
  000f1	8b 45 98	 mov	 eax, DWORD PTR _sym$[ebp]
  000f4	83 c0 01	 add	 eax, 1
  000f7	89 45 98	 mov	 DWORD PTR _sym$[ebp], eax
$LN12@gen_codewo:
  000fa	8b 45 98	 mov	 eax, DWORD PTR _sym$[ebp]
  000fd	3b 45 18	 cmp	 eax, DWORD PTR _num_syms$[ebp]
  00100	73 35		 jae	 SHORT $LN1@gen_codewo

; 976  : 		A[sym] = next_codewords[lens[sym]]++;

  00102	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00105	03 45 98	 add	 eax, DWORD PTR _sym$[ebp]
  00108	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0010b	8b 55 98	 mov	 edx, DWORD PTR _sym$[ebp]
  0010e	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  00111	8b 4c 8d bc	 mov	 ecx, DWORD PTR _next_codewords$[ebp+ecx*4]
  00115	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  00118	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  0011b	03 55 98	 add	 edx, DWORD PTR _sym$[ebp]
  0011e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00121	8b 4c 85 bc	 mov	 ecx, DWORD PTR _next_codewords$[ebp+eax*4]
  00125	83 c1 01	 add	 ecx, 1
  00128	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  0012b	03 55 98	 add	 edx, DWORD PTR _sym$[ebp]
  0012e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00131	89 4c 85 bc	 mov	 DWORD PTR _next_codewords$[ebp+eax*4], ecx
  00135	eb ba		 jmp	 SHORT $LN10@gen_codewo
$LN1@gen_codewo:

; 977  : }

  00137	52		 push	 edx
  00138	8b cd		 mov	 ecx, ebp
  0013a	50		 push	 eax
  0013b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@gen_codewo
  00141	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00146	58		 pop	 eax
  00147	5a		 pop	 edx
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	5b		 pop	 ebx
  0014b	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  00151	3b ec		 cmp	 ebp, esp
  00153	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
$LN16@gen_codewo:
  0015c	01 00 00 00	 DD	 1
  00160	00 00 00 00	 DD	 $LN15@gen_codewo
$LN15@gen_codewo:
  00164	bc ff ff ff	 DD	 -68			; ffffffbcH
  00168	40 00 00 00	 DD	 64			; 00000040H
  0016c	00 00 00 00	 DD	 $LN14@gen_codewo
$LN14@gen_codewo:
  00170	6e		 DB	 110			; 0000006eH
  00171	65		 DB	 101			; 00000065H
  00172	78		 DB	 120			; 00000078H
  00173	74		 DB	 116			; 00000074H
  00174	5f		 DB	 95			; 0000005fH
  00175	63		 DB	 99			; 00000063H
  00176	6f		 DB	 111			; 0000006fH
  00177	64		 DB	 100			; 00000064H
  00178	65		 DB	 101			; 00000065H
  00179	77		 DB	 119			; 00000077H
  0017a	6f		 DB	 111			; 0000006fH
  0017b	72		 DB	 114			; 00000072H
  0017c	64		 DB	 100			; 00000064H
  0017d	73		 DB	 115			; 00000073H
  0017e	00		 DB	 0
_gen_codewords ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _compute_length_counts
_TEXT	SEGMENT
_len$1 = -68						; size = 4
_depth$2 = -56						; size = 4
_parent_depth$3 = -44					; size = 4
_parent$4 = -32						; size = 4
_node$ = -20						; size = 4
_len$ = -8						; size = 4
_A$ = 8							; size = 4
_root_idx$ = 12						; size = 4
_len_counts$ = 16					; size = 4
_max_codeword_len$ = 20					; size = 4
_compute_length_counts PROC				; COMDAT

; 856  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 857  : 	unsigned len;
; 858  : 	int node;
; 859  : 
; 860  : 	/* The key observations are:
; 861  : 	 *
; 862  : 	 * (1) We can traverse the non-leaf nodes of the tree, always
; 863  : 	 * visiting a parent before its children, by simply iterating
; 864  : 	 * through the array in reverse order.  Consequently, we can
; 865  : 	 * compute the depth of each node in one pass, overwriting the
; 866  : 	 * parent indices with depths.
; 867  : 	 *
; 868  : 	 * (2) We can initially assume that in the real Huffman tree,
; 869  : 	 * both children of the root are leaves.  This corresponds to two
; 870  : 	 * codewords of length 1.  Then, whenever we visit a (non-leaf)
; 871  : 	 * node during the traversal, we modify this assumption to
; 872  : 	 * account for the current node *not* being a leaf, but rather
; 873  : 	 * its two children being leaves.  This causes the loss of one
; 874  : 	 * codeword for the current depth and the addition of two
; 875  : 	 * codewords for the current depth plus one.
; 876  : 	 *
; 877  : 	 * (3) We can handle the length-limited constraint fairly easily
; 878  : 	 * by simply using the largest length available when a depth
; 879  : 	 * exceeds max_codeword_len.
; 880  : 	 */
; 881  : 
; 882  : 	for (len = 0; len <= max_codeword_len; len++)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@compute_le
$LN2@compute_le:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
$LN4@compute_le:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0003d	3b 45 14	 cmp	 eax, DWORD PTR _max_codeword_len$[ebp]
  00040	77 0f		 ja	 SHORT $LN3@compute_le

; 883  : 		len_counts[len] = 0;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00045	8b 4d 10	 mov	 ecx, DWORD PTR _len_counts$[ebp]
  00048	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
  0004f	eb e0		 jmp	 SHORT $LN2@compute_le
$LN3@compute_le:

; 884  : 	len_counts[1] = 2;

  00051	b8 04 00 00 00	 mov	 eax, 4
  00056	c1 e0 00	 shl	 eax, 0
  00059	8b 4d 10	 mov	 ecx, DWORD PTR _len_counts$[ebp]
  0005c	c7 04 01 02 00
	00 00		 mov	 DWORD PTR [ecx+eax], 2

; 885  : 
; 886  : 	/* Set the root node's depth to 0.  */
; 887  : 	A[root_idx] &= SYMBOL_MASK;

  00063	8b 45 0c	 mov	 eax, DWORD PTR _root_idx$[ebp]
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00069	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0006c	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00072	8b 45 0c	 mov	 eax, DWORD PTR _root_idx$[ebp]
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00078	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 888  : 
; 889  : 	for (node = root_idx - 1; node >= 0; node--) {

  0007b	8b 45 0c	 mov	 eax, DWORD PTR _root_idx$[ebp]
  0007e	83 e8 01	 sub	 eax, 1
  00081	89 45 ec	 mov	 DWORD PTR _node$[ebp], eax
  00084	eb 09		 jmp	 SHORT $LN7@compute_le
$LN5@compute_le:
  00086	8b 45 ec	 mov	 eax, DWORD PTR _node$[ebp]
  00089	83 e8 01	 sub	 eax, 1
  0008c	89 45 ec	 mov	 DWORD PTR _node$[ebp], eax
$LN7@compute_le:
  0008f	83 7d ec 00	 cmp	 DWORD PTR _node$[ebp], 0
  00093	0f 8c a1 00 00
	00		 jl	 $LN1@compute_le

; 890  : 
; 891  : 		/* Calculate the depth of this node.  */
; 892  : 
; 893  : 		unsigned parent = A[node] >> NUM_SYMBOL_BITS;

  00099	8b 45 ec	 mov	 eax, DWORD PTR _node$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0009f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000a2	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  000a5	89 55 e0	 mov	 DWORD PTR _parent$4[ebp], edx

; 894  : 		unsigned parent_depth = A[parent] >> NUM_SYMBOL_BITS;

  000a8	8b 45 e0	 mov	 eax, DWORD PTR _parent$4[ebp]
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  000ae	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000b1	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  000b4	89 55 d4	 mov	 DWORD PTR _parent_depth$3[ebp], edx

; 895  : 		unsigned depth = parent_depth + 1;

  000b7	8b 45 d4	 mov	 eax, DWORD PTR _parent_depth$3[ebp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 45 c8	 mov	 DWORD PTR _depth$2[ebp], eax

; 896  : 		unsigned len = depth;

  000c0	8b 45 c8	 mov	 eax, DWORD PTR _depth$2[ebp]
  000c3	89 45 bc	 mov	 DWORD PTR _len$1[ebp], eax

; 897  : 
; 898  : 		/* Set the depth of this node so that it is available
; 899  : 		 * when its children (if any) are processed.  */
; 900  : 
; 901  : 		A[node] = (A[node] & SYMBOL_MASK) | (depth << NUM_SYMBOL_BITS);

  000c6	8b 45 ec	 mov	 eax, DWORD PTR _node$[ebp]
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  000cc	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000cf	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  000d5	8b 45 c8	 mov	 eax, DWORD PTR _depth$2[ebp]
  000d8	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  000db	0b d0		 or	 edx, eax
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _node$[ebp]
  000e0	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  000e3	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 902  : 
; 903  : 		/* If needed, decrease the length to meet the
; 904  : 		 * length-limited constraint.  This is not the optimal
; 905  : 		 * method for generating length-limited Huffman codes!
; 906  : 		 * But it should be good enough.  */
; 907  : 		if (len >= max_codeword_len) {

  000e6	8b 45 bc	 mov	 eax, DWORD PTR _len$1[ebp]
  000e9	3b 45 14	 cmp	 eax, DWORD PTR _max_codeword_len$[ebp]
  000ec	72 1b		 jb	 SHORT $LN11@compute_le

; 908  : 			len = max_codeword_len;

  000ee	8b 45 14	 mov	 eax, DWORD PTR _max_codeword_len$[ebp]
  000f1	89 45 bc	 mov	 DWORD PTR _len$1[ebp], eax
$LN10@compute_le:

; 909  : 			do {
; 910  : 				len--;

  000f4	8b 45 bc	 mov	 eax, DWORD PTR _len$1[ebp]
  000f7	83 e8 01	 sub	 eax, 1
  000fa	89 45 bc	 mov	 DWORD PTR _len$1[ebp], eax

; 911  : 			} while (len_counts[len] == 0);

  000fd	8b 45 bc	 mov	 eax, DWORD PTR _len$1[ebp]
  00100	8b 4d 10	 mov	 ecx, DWORD PTR _len_counts$[ebp]
  00103	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00107	74 eb		 je	 SHORT $LN10@compute_le
$LN11@compute_le:

; 912  : 		}
; 913  : 
; 914  : 		/* Account for the fact that we have a non-leaf node at
; 915  : 		 * the current depth.  */
; 916  : 		len_counts[len]--;

  00109	8b 45 bc	 mov	 eax, DWORD PTR _len$1[ebp]
  0010c	8b 4d 10	 mov	 ecx, DWORD PTR _len_counts$[ebp]
  0010f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00112	83 ea 01	 sub	 edx, 1
  00115	8b 45 bc	 mov	 eax, DWORD PTR _len$1[ebp]
  00118	8b 4d 10	 mov	 ecx, DWORD PTR _len_counts$[ebp]
  0011b	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 917  : 		len_counts[len + 1] += 2;

  0011e	8b 45 bc	 mov	 eax, DWORD PTR _len$1[ebp]
  00121	8b 4d 10	 mov	 ecx, DWORD PTR _len_counts$[ebp]
  00124	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  00128	83 c2 02	 add	 edx, 2
  0012b	8b 45 bc	 mov	 eax, DWORD PTR _len$1[ebp]
  0012e	8b 4d 10	 mov	 ecx, DWORD PTR _len_counts$[ebp]
  00131	89 54 81 04	 mov	 DWORD PTR [ecx+eax*4+4], edx

; 918  : 	}

  00135	e9 4c ff ff ff	 jmp	 $LN5@compute_le
$LN1@compute_le:

; 919  : }

  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00143	3b ec		 cmp	 ebp, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
_compute_length_counts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _build_tree
_TEXT	SEGMENT
_freq_shifted$1 = -68					; size = 4
_n$2 = -56						; size = 4
_m$3 = -44						; size = 4
_e$ = -32						; size = 4
_b$ = -20						; size = 4
_i$ = -8						; size = 4
_A$ = 8							; size = 4
_sym_count$ = 12					; size = 4
_build_tree PROC					; COMDAT

; 770  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 771  : 	/* Index, in 'A', of next lowest frequency symbol that has not
; 772  : 	 * yet been processed.  */
; 773  : 	unsigned i = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 774  : 
; 775  : 	/* Index, in 'A', of next lowest frequency parentless non-leaf
; 776  : 	 * node; or, if equal to 'e', then no such node exists yet.  */
; 777  : 	unsigned b = 0;

  0002f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0

; 778  : 
; 779  : 	/* Index, in 'A', of next node to allocate as a non-leaf.  */
; 780  : 	unsigned e = 0;

  00036	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _e$[ebp], 0
$LN4@build_tree:

; 781  : 
; 782  : 	do {
; 783  : 		unsigned m, n;
; 784  : 		u32 freq_shifted;
; 785  : 
; 786  : 		/* Choose the two next lowest frequency entries.  */
; 787  : 
; 788  : 		if (i != sym_count &&

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00040	3b 45 0c	 cmp	 eax, DWORD PTR _sym_count$[ebp]
  00043	74 35		 je	 SHORT $LN5@build_tree
  00045	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp]
  00048	3b 45 e0	 cmp	 eax, DWORD PTR _e$[ebp]
  0004b	74 1c		 je	 SHORT $LN7@build_tree
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00053	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00056	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  00059	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0005f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00062	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00065	3b d0		 cmp	 edx, eax
  00067	77 11		 ja	 SHORT $LN5@build_tree
$LN7@build_tree:

; 789  : 		    (b == e || (A[i] >> NUM_SYMBOL_BITS) <= (A[b] >> NUM_SYMBOL_BITS)))
; 790  : 			m = i++;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006c	89 45 d4	 mov	 DWORD PTR _m$3[ebp], eax
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00072	83 c1 01	 add	 ecx, 1
  00075	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  00078	eb 0f		 jmp	 SHORT $LN6@build_tree
$LN5@build_tree:

; 791  : 		else
; 792  : 			m = b++;

  0007a	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp]
  0007d	89 45 d4	 mov	 DWORD PTR _m$3[ebp], eax
  00080	8b 4d ec	 mov	 ecx, DWORD PTR _b$[ebp]
  00083	83 c1 01	 add	 ecx, 1
  00086	89 4d ec	 mov	 DWORD PTR _b$[ebp], ecx
$LN6@build_tree:

; 793  : 
; 794  : 		if (i != sym_count &&

  00089	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	3b 45 0c	 cmp	 eax, DWORD PTR _sym_count$[ebp]
  0008f	74 35		 je	 SHORT $LN8@build_tree
  00091	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp]
  00094	3b 45 e0	 cmp	 eax, DWORD PTR _e$[ebp]
  00097	74 1c		 je	 SHORT $LN10@build_tree
  00099	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0009f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000a2	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  000a5	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp]
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  000ab	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000ae	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  000b1	3b d0		 cmp	 edx, eax
  000b3	77 11		 ja	 SHORT $LN8@build_tree
$LN10@build_tree:

; 795  : 		    (b == e || (A[i] >> NUM_SYMBOL_BITS) <= (A[b] >> NUM_SYMBOL_BITS)))
; 796  : 			n = i++;

  000b5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b8	89 45 c8	 mov	 DWORD PTR _n$2[ebp], eax
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000be	83 c1 01	 add	 ecx, 1
  000c1	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  000c4	eb 0f		 jmp	 SHORT $LN9@build_tree
$LN8@build_tree:

; 797  : 		else
; 798  : 			n = b++;

  000c6	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp]
  000c9	89 45 c8	 mov	 DWORD PTR _n$2[ebp], eax
  000cc	8b 4d ec	 mov	 ecx, DWORD PTR _b$[ebp]
  000cf	83 c1 01	 add	 ecx, 1
  000d2	89 4d ec	 mov	 DWORD PTR _b$[ebp], ecx
$LN9@build_tree:

; 799  : 
; 800  : 		/* Allocate a non-leaf node and link the entries to it.
; 801  : 		 *
; 802  : 		 * If we link an entry that we're visiting for the first
; 803  : 		 * time (via index 'i'), then we're actually linking a
; 804  : 		 * leaf node and it will have no effect, since the leaf
; 805  : 		 * will be overwritten with a non-leaf when index 'e'
; 806  : 		 * catches up to it.  But it's not any slower to
; 807  : 		 * unconditionally set the parent index.
; 808  : 		 *
; 809  : 		 * We also compute the frequency of the non-leaf node as
; 810  : 		 * the sum of its two children's frequencies.  */
; 811  : 
; 812  : 		freq_shifted = (A[m] & ~SYMBOL_MASK) + (A[n] & ~SYMBOL_MASK);

  000d5	8b 45 d4	 mov	 eax, DWORD PTR _m$3[ebp]
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  000db	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000de	81 e2 00 fc ff
	ff		 and	 edx, -1024		; fffffc00H
  000e4	8b 45 c8	 mov	 eax, DWORD PTR _n$2[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  000ea	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000ed	25 00 fc ff ff	 and	 eax, -1024		; fffffc00H
  000f2	03 d0		 add	 edx, eax
  000f4	89 55 bc	 mov	 DWORD PTR _freq_shifted$1[ebp], edx

; 813  : 
; 814  : 		A[m] = (A[m] & SYMBOL_MASK) | (e << NUM_SYMBOL_BITS);

  000f7	8b 45 d4	 mov	 eax, DWORD PTR _m$3[ebp]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  000fd	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00100	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00106	8b 45 e0	 mov	 eax, DWORD PTR _e$[ebp]
  00109	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0010c	0b d0		 or	 edx, eax
  0010e	8b 4d d4	 mov	 ecx, DWORD PTR _m$3[ebp]
  00111	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  00114	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 815  : 		A[n] = (A[n] & SYMBOL_MASK) | (e << NUM_SYMBOL_BITS);

  00117	8b 45 c8	 mov	 eax, DWORD PTR _n$2[ebp]
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0011d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00120	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00126	8b 45 e0	 mov	 eax, DWORD PTR _e$[ebp]
  00129	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0012c	0b d0		 or	 edx, eax
  0012e	8b 4d c8	 mov	 ecx, DWORD PTR _n$2[ebp]
  00131	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  00134	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 816  : 		A[e] = (A[e] & SYMBOL_MASK) | freq_shifted;

  00137	8b 45 e0	 mov	 eax, DWORD PTR _e$[ebp]
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0013d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00140	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00146	0b 55 bc	 or	 edx, DWORD PTR _freq_shifted$1[ebp]
  00149	8b 45 e0	 mov	 eax, DWORD PTR _e$[ebp]
  0014c	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0014f	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 817  : 		e++;

  00152	8b 45 e0	 mov	 eax, DWORD PTR _e$[ebp]
  00155	83 c0 01	 add	 eax, 1
  00158	89 45 e0	 mov	 DWORD PTR _e$[ebp], eax

; 818  : 	} while (sym_count - e > 1);

  0015b	8b 45 0c	 mov	 eax, DWORD PTR _sym_count$[ebp]
  0015e	2b 45 e0	 sub	 eax, DWORD PTR _e$[ebp]
  00161	83 f8 01	 cmp	 eax, 1
  00164	0f 87 d3 fe ff
	ff		 ja	 $LN4@build_tree

; 819  : 		/* When just one entry remains, it is a "leaf" that was
; 820  : 		 * linked to some other node.  We ignore it, since the
; 821  : 		 * rest of the array contains the non-leaves which we
; 822  : 		 * need.  (Note that we're assuming the cases with 0 or 1
; 823  : 		 * symbols were handled separately.) */
; 824  : }

  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00173	3b ec		 cmp	 ebp, esp
  00175	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
_build_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _sort_symbols
_TEXT	SEGMENT
tv134 = -1816						; size = 4
tv79 = -1816						; size = 4
_freq$1 = -1232						; size = 4
_count$2 = -1220					; size = 4
_counters$ = -1208					; size = 1152
_num_counters$ = -48					; size = 4
_num_used_syms$ = -36					; size = 4
_i$ = -24						; size = 4
_sym$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_num_syms$ = 8						; size = 4
_freqs$ = 12						; size = 4
_lens$ = 16						; size = 4
_symout$ = 20						; size = 4
_sort_symbols PROC					; COMDAT

; 669  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 07 00
	00		 sub	 esp, 1816		; 00000718H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 f8 ff
	ff		 lea	 edi, DWORD PTR [ebp-1816]
  00012	b9 c6 01 00 00	 mov	 ecx, 454		; 000001c6H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 670  : 	unsigned sym;
; 671  : 	unsigned i;
; 672  : 	unsigned num_used_syms;
; 673  : 	unsigned num_counters;
; 674  : 	unsigned counters[GET_NUM_COUNTERS(DEFLATE_MAX_NUM_SYMS)];
; 675  : 
; 676  : 	/* We rely on heapsort, but with an added optimization.  Since
; 677  : 	 * it's common for most symbol frequencies to be low, we first do
; 678  : 	 * a count sort using a limited number of counters.  High
; 679  : 	 * frequencies will be counted in the last counter, and only they
; 680  : 	 * will be sorted with heapsort.
; 681  : 	 *
; 682  : 	 * Note: with more symbols, it is generally beneficial to have more
; 683  : 	 * counters.  About 1 counter per 4 symbols seems fast.
; 684  : 	 *
; 685  : 	 * Note: I also tested radix sort, but even for large symbol
; 686  : 	 * counts (> 255) and frequencies bounded at 16 bits (enabling
; 687  : 	 * radix sort by just two base-256 digits), it didn't seem any
; 688  : 	 * faster than the method implemented here.
; 689  : 	 *
; 690  : 	 * Note: I tested the optimized quicksort implementation from
; 691  : 	 * glibc (with indirection overhead removed), but it was only
; 692  : 	 * marginally faster than the simple heapsort implemented here.
; 693  : 	 *
; 694  : 	 * Tests were done with building the codes for LZX.  Results may
; 695  : 	 * vary for different compression algorithms...!  */
; 696  : 
; 697  : 	num_counters = GET_NUM_COUNTERS(num_syms);

  00032	8b 45 08	 mov	 eax, DWORD PTR _num_syms$[ebp]
  00035	83 c0 03	 add	 eax, 3
  00038	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003b	89 45 d0	 mov	 DWORD PTR _num_counters$[ebp], eax

; 698  : 
; 699  : 	memset(counters, 0, num_counters * sizeof(counters[0]));

  0003e	8b 45 d0	 mov	 eax, DWORD PTR _num_counters$[ebp]
  00041	c1 e0 02	 shl	 eax, 2
  00044	50		 push	 eax
  00045	6a 00		 push	 0
  00047	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _counters$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _memset
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 700  : 
; 701  : 	/* Count the frequencies.  */
; 702  : 	for (sym = 0; sym < num_syms; sym++)

  00056	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  0005d	eb 09		 jmp	 SHORT $LN4@sort_symbo
$LN2@sort_symbo:
  0005f	8b 45 f4	 mov	 eax, DWORD PTR _sym$[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 f4	 mov	 DWORD PTR _sym$[ebp], eax
$LN4@sort_symbo:
  00068	8b 45 f4	 mov	 eax, DWORD PTR _sym$[ebp]
  0006b	3b 45 08	 cmp	 eax, DWORD PTR _num_syms$[ebp]
  0006e	73 4d		 jae	 SHORT $LN3@sort_symbo

; 703  : 		counters[MIN(freqs[sym], num_counters - 1)]++;

  00070	8b 45 d0	 mov	 eax, DWORD PTR _num_counters$[ebp]
  00073	83 e8 01	 sub	 eax, 1
  00076	8b 4d f4	 mov	 ecx, DWORD PTR _sym$[ebp]
  00079	8b 55 0c	 mov	 edx, DWORD PTR _freqs$[ebp]
  0007c	39 04 8a	 cmp	 DWORD PTR [edx+ecx*4], eax
  0007f	77 11		 ja	 SHORT $LN14@sort_symbo
  00081	8b 45 f4	 mov	 eax, DWORD PTR _sym$[ebp]
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _freqs$[ebp]
  00087	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0008a	89 95 e8 f8 ff
	ff		 mov	 DWORD PTR tv79[ebp], edx
  00090	eb 0c		 jmp	 SHORT $LN15@sort_symbo
$LN14@sort_symbo:
  00092	8b 45 d0	 mov	 eax, DWORD PTR _num_counters$[ebp]
  00095	83 e8 01	 sub	 eax, 1
  00098	89 85 e8 f8 ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
$LN15@sort_symbo:
  0009e	8b 8d e8 f8 ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  000a4	8b 94 8d 48 fb
	ff ff		 mov	 edx, DWORD PTR _counters$[ebp+ecx*4]
  000ab	83 c2 01	 add	 edx, 1
  000ae	8b 85 e8 f8 ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  000b4	89 94 85 48 fb
	ff ff		 mov	 DWORD PTR _counters$[ebp+eax*4], edx
  000bb	eb a2		 jmp	 SHORT $LN2@sort_symbo
$LN3@sort_symbo:

; 704  : 
; 705  : 	/* Make the counters cumulative, ignoring the zero-th, which
; 706  : 	 * counted symbols with zero frequency.  As a side effect, this
; 707  : 	 * calculates the number of symbols with nonzero frequency.  */
; 708  : 	num_used_syms = 0;

  000bd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _num_used_syms$[ebp], 0

; 709  : 	for (i = 1; i < num_counters; i++) {

  000c4	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000cb	eb 09		 jmp	 SHORT $LN7@sort_symbo
$LN5@sort_symbo:
  000cd	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000d0	83 c0 01	 add	 eax, 1
  000d3	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@sort_symbo:
  000d6	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000d9	3b 45 d0	 cmp	 eax, DWORD PTR _num_counters$[ebp]
  000dc	73 2b		 jae	 SHORT $LN6@sort_symbo

; 710  : 		unsigned count = counters[i];

  000de	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000e1	8b 8c 85 48 fb
	ff ff		 mov	 ecx, DWORD PTR _counters$[ebp+eax*4]
  000e8	89 8d 3c fb ff
	ff		 mov	 DWORD PTR _count$2[ebp], ecx

; 711  : 		counters[i] = num_used_syms;

  000ee	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000f1	8b 4d dc	 mov	 ecx, DWORD PTR _num_used_syms$[ebp]
  000f4	89 8c 85 48 fb
	ff ff		 mov	 DWORD PTR _counters$[ebp+eax*4], ecx

; 712  : 		num_used_syms += count;

  000fb	8b 45 dc	 mov	 eax, DWORD PTR _num_used_syms$[ebp]
  000fe	03 85 3c fb ff
	ff		 add	 eax, DWORD PTR _count$2[ebp]
  00104	89 45 dc	 mov	 DWORD PTR _num_used_syms$[ebp], eax

; 713  : 	}

  00107	eb c4		 jmp	 SHORT $LN5@sort_symbo
$LN6@sort_symbo:

; 714  : 
; 715  : 	/* Sort nonzero-frequency symbols using the counters.  At the
; 716  : 	 * same time, set the codeword lengths of zero-frequency symbols
; 717  : 	 * to 0.  */
; 718  : 	for (sym = 0; sym < num_syms; sym++) {

  00109	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  00110	eb 09		 jmp	 SHORT $LN10@sort_symbo
$LN8@sort_symbo:
  00112	8b 45 f4	 mov	 eax, DWORD PTR _sym$[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 f4	 mov	 DWORD PTR _sym$[ebp], eax
$LN10@sort_symbo:
  0011b	8b 45 f4	 mov	 eax, DWORD PTR _sym$[ebp]
  0011e	3b 45 08	 cmp	 eax, DWORD PTR _num_syms$[ebp]
  00121	0f 83 8c 00 00
	00		 jae	 $LN9@sort_symbo

; 719  : 		u32 freq = freqs[sym];

  00127	8b 45 f4	 mov	 eax, DWORD PTR _sym$[ebp]
  0012a	8b 4d 0c	 mov	 ecx, DWORD PTR _freqs$[ebp]
  0012d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00130	89 95 30 fb ff
	ff		 mov	 DWORD PTR _freq$1[ebp], edx

; 720  : 		if (freq != 0) {

  00136	83 bd 30 fb ff
	ff 00		 cmp	 DWORD PTR _freq$1[ebp], 0
  0013d	74 66		 je	 SHORT $LN11@sort_symbo

; 721  : 			symout[counters[MIN(freq, num_counters - 1)]++] =

  0013f	8b 45 d0	 mov	 eax, DWORD PTR _num_counters$[ebp]
  00142	83 e8 01	 sub	 eax, 1
  00145	39 85 30 fb ff
	ff		 cmp	 DWORD PTR _freq$1[ebp], eax
  0014b	77 0e		 ja	 SHORT $LN16@sort_symbo
  0014d	8b 8d 30 fb ff
	ff		 mov	 ecx, DWORD PTR _freq$1[ebp]
  00153	89 8d e8 f8 ff
	ff		 mov	 DWORD PTR tv134[ebp], ecx
  00159	eb 0c		 jmp	 SHORT $LN17@sort_symbo
$LN16@sort_symbo:
  0015b	8b 55 d0	 mov	 edx, DWORD PTR _num_counters$[ebp]
  0015e	83 ea 01	 sub	 edx, 1
  00161	89 95 e8 f8 ff
	ff		 mov	 DWORD PTR tv134[ebp], edx
$LN17@sort_symbo:
  00167	8b 85 30 fb ff
	ff		 mov	 eax, DWORD PTR _freq$1[ebp]
  0016d	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00170	0b 45 f4	 or	 eax, DWORD PTR _sym$[ebp]
  00173	8b 8d e8 f8 ff
	ff		 mov	 ecx, DWORD PTR tv134[ebp]
  00179	8b 94 8d 48 fb
	ff ff		 mov	 edx, DWORD PTR _counters$[ebp+ecx*4]
  00180	8b 4d 14	 mov	 ecx, DWORD PTR _symout$[ebp]
  00183	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  00186	8b 95 e8 f8 ff
	ff		 mov	 edx, DWORD PTR tv134[ebp]
  0018c	8b 84 95 48 fb
	ff ff		 mov	 eax, DWORD PTR _counters$[ebp+edx*4]
  00193	83 c0 01	 add	 eax, 1
  00196	8b 8d e8 f8 ff
	ff		 mov	 ecx, DWORD PTR tv134[ebp]
  0019c	89 84 8d 48 fb
	ff ff		 mov	 DWORD PTR _counters$[ebp+ecx*4], eax

; 722  : 				sym | (freq << NUM_SYMBOL_BITS);
; 723  : 		} else {

  001a3	eb 09		 jmp	 SHORT $LN12@sort_symbo
$LN11@sort_symbo:

; 724  : 			lens[sym] = 0;

  001a5	8b 45 10	 mov	 eax, DWORD PTR _lens$[ebp]
  001a8	03 45 f4	 add	 eax, DWORD PTR _sym$[ebp]
  001ab	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN12@sort_symbo:

; 725  : 		}
; 726  : 	}

  001ae	e9 5f ff ff ff	 jmp	 $LN8@sort_symbo
$LN9@sort_symbo:

; 727  : 
; 728  : 	/* Sort the symbols counted in the last counter.  */
; 729  : 	heap_sort(symout + counters[num_counters - 2],

  001b3	8b 45 d0	 mov	 eax, DWORD PTR _num_counters$[ebp]
  001b6	8b 4d d0	 mov	 ecx, DWORD PTR _num_counters$[ebp]
  001b9	8b 94 85 44 fb
	ff ff		 mov	 edx, DWORD PTR _counters$[ebp+eax*4-4]
  001c0	2b 94 8d 40 fb
	ff ff		 sub	 edx, DWORD PTR _counters$[ebp+ecx*4-8]
  001c7	52		 push	 edx
  001c8	8b 45 d0	 mov	 eax, DWORD PTR _num_counters$[ebp]
  001cb	8b 8c 85 40 fb
	ff ff		 mov	 ecx, DWORD PTR _counters$[ebp+eax*4-8]
  001d2	8b 55 14	 mov	 edx, DWORD PTR _symout$[ebp]
  001d5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  001d8	50		 push	 eax
  001d9	e8 00 00 00 00	 call	 _heap_sort
  001de	83 c4 08	 add	 esp, 8

; 730  : 		  counters[num_counters - 1] - counters[num_counters - 2]);
; 731  : 
; 732  : 	return num_used_syms;

  001e1	8b 45 dc	 mov	 eax, DWORD PTR _num_used_syms$[ebp]

; 733  : }

  001e4	52		 push	 edx
  001e5	8b cd		 mov	 ecx, ebp
  001e7	50		 push	 eax
  001e8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@sort_symbo
  001ee	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001f3	58		 pop	 eax
  001f4	5a		 pop	 edx
  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
  001f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fb	33 cd		 xor	 ecx, ebp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	81 c4 18 07 00
	00		 add	 esp, 1816		; 00000718H
  00208	3b ec		 cmp	 ebp, esp
  0020a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020f	8b e5		 mov	 esp, ebp
  00211	5d		 pop	 ebp
  00212	c3		 ret	 0
  00213	90		 npad	 1
$LN20@sort_symbo:
  00214	01 00 00 00	 DD	 1
  00218	00 00 00 00	 DD	 $LN19@sort_symbo
$LN19@sort_symbo:
  0021c	48 fb ff ff	 DD	 -1208			; fffffb48H
  00220	80 04 00 00	 DD	 1152			; 00000480H
  00224	00 00 00 00	 DD	 $LN18@sort_symbo
$LN18@sort_symbo:
  00228	63		 DB	 99			; 00000063H
  00229	6f		 DB	 111			; 0000006fH
  0022a	75		 DB	 117			; 00000075H
  0022b	6e		 DB	 110			; 0000006eH
  0022c	74		 DB	 116			; 00000074H
  0022d	65		 DB	 101			; 00000065H
  0022e	72		 DB	 114			; 00000072H
  0022f	73		 DB	 115			; 00000073H
  00230	00		 DB	 0
_sort_symbols ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _heap_sort
_TEXT	SEGMENT
_tmp$1 = -8						; size = 4
_A$ = 8							; size = 4
_length$ = 12						; size = 4
_heap_sort PROC						; COMDAT

; 622  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 623  : 	A--; /* Use 1-based indices  */

  00028	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  0002b	83 e8 04	 sub	 eax, 4
  0002e	89 45 08	 mov	 DWORD PTR _A$[ebp], eax

; 624  : 
; 625  : 	heapify_array(A, length);

  00031	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _heapify_array
  0003e	83 c4 08	 add	 esp, 8
$LN2@heap_sort:

; 626  : 
; 627  : 	while (length >= 2) {

  00041	83 7d 0c 02	 cmp	 DWORD PTR _length$[ebp], 2
  00045	72 51		 jb	 SHORT $LN1@heap_sort

; 628  : 		u32 tmp = A[length];

  00047	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0004d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00050	89 55 f8	 mov	 DWORD PTR _tmp$1[ebp], edx

; 629  : 		A[length] = A[1];

  00053	b8 04 00 00 00	 mov	 eax, 4
  00058	c1 e0 00	 shl	 eax, 0
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  00061	8b 75 08	 mov	 esi, DWORD PTR _A$[ebp]
  00064	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00067	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 630  : 		A[1] = tmp;

  0006a	b8 04 00 00 00	 mov	 eax, 4
  0006f	c1 e0 00	 shl	 eax, 0
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00075	8b 55 f8	 mov	 edx, DWORD PTR _tmp$1[ebp]
  00078	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 631  : 		length--;

  0007b	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0007e	83 e8 01	 sub	 eax, 1
  00081	89 45 0c	 mov	 DWORD PTR _length$[ebp], eax

; 632  : 		heapify_subtree(A, length, 1);

  00084	6a 01		 push	 1
  00086	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _heapify_subtree
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 633  : 	}

  00096	eb a9		 jmp	 SHORT $LN2@heap_sort
$LN1@heap_sort:

; 634  : }

  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_heap_sort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _heapify_array
_TEXT	SEGMENT
_subtree_idx$ = -8					; size = 4
_A$ = 8							; size = 4
_length$ = 12						; size = 4
_heapify_array PROC					; COMDAT

; 606  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 607  : 	unsigned subtree_idx;
; 608  : 
; 609  : 	for (subtree_idx = length / 2; subtree_idx >= 1; subtree_idx--)

  00028	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0002b	d1 e8		 shr	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _subtree_idx$[ebp], eax
  00030	eb 09		 jmp	 SHORT $LN4@heapify_ar
$LN2@heapify_ar:
  00032	8b 45 f8	 mov	 eax, DWORD PTR _subtree_idx$[ebp]
  00035	83 e8 01	 sub	 eax, 1
  00038	89 45 f8	 mov	 DWORD PTR _subtree_idx$[ebp], eax
$LN4@heapify_ar:
  0003b	83 7d f8 01	 cmp	 DWORD PTR _subtree_idx$[ebp], 1
  0003f	72 16		 jb	 SHORT $LN1@heapify_ar

; 610  : 		heapify_subtree(A, length, subtree_idx);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _subtree_idx$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00048	51		 push	 ecx
  00049	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _heapify_subtree
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	eb db		 jmp	 SHORT $LN2@heapify_ar
$LN1@heapify_ar:

; 611  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_heapify_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _heapify_subtree
_TEXT	SEGMENT
_v$ = -32						; size = 4
_child_idx$ = -20					; size = 4
_parent_idx$ = -8					; size = 4
_A$ = 8							; size = 4
_length$ = 12						; size = 4
_subtree_idx$ = 16					; size = 4
_heapify_subtree PROC					; COMDAT

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 584  : 	unsigned parent_idx;
; 585  : 	unsigned child_idx;
; 586  : 	u32 v;
; 587  : 
; 588  : 	v = A[subtree_idx];

  00028	8b 45 10	 mov	 eax, DWORD PTR _subtree_idx$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0002e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00031	89 55 e0	 mov	 DWORD PTR _v$[ebp], edx

; 589  : 	parent_idx = subtree_idx;

  00034	8b 45 10	 mov	 eax, DWORD PTR _subtree_idx$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR _parent_idx$[ebp], eax
$LN2@heapify_su:

; 590  : 	while ((child_idx = parent_idx * 2) <= length) {

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _parent_idx$[ebp]
  0003d	d1 e0		 shl	 eax, 1
  0003f	89 45 ec	 mov	 DWORD PTR _child_idx$[ebp], eax
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _child_idx$[ebp]
  00045	3b 4d 0c	 cmp	 ecx, DWORD PTR _length$[ebp]
  00048	77 50		 ja	 SHORT $LN3@heapify_su

; 591  : 		if (child_idx < length && A[child_idx + 1] > A[child_idx])

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _child_idx$[ebp]
  0004d	3b 45 0c	 cmp	 eax, DWORD PTR _length$[ebp]
  00050	73 1e		 jae	 SHORT $LN4@heapify_su
  00052	8b 45 ec	 mov	 eax, DWORD PTR _child_idx$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00058	8b 55 ec	 mov	 edx, DWORD PTR _child_idx$[ebp]
  0005b	8b 75 08	 mov	 esi, DWORD PTR _A$[ebp]
  0005e	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  00062	3b 04 96	 cmp	 eax, DWORD PTR [esi+edx*4]
  00065	76 09		 jbe	 SHORT $LN4@heapify_su

; 592  : 			child_idx++;

  00067	8b 45 ec	 mov	 eax, DWORD PTR _child_idx$[ebp]
  0006a	83 c0 01	 add	 eax, 1
  0006d	89 45 ec	 mov	 DWORD PTR _child_idx$[ebp], eax
$LN4@heapify_su:

; 593  : 		if (v >= A[child_idx])

  00070	8b 45 ec	 mov	 eax, DWORD PTR _child_idx$[ebp]
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00076	8b 55 e0	 mov	 edx, DWORD PTR _v$[ebp]
  00079	3b 14 81	 cmp	 edx, DWORD PTR [ecx+eax*4]
  0007c	72 02		 jb	 SHORT $LN5@heapify_su

; 594  : 			break;

  0007e	eb 1a		 jmp	 SHORT $LN3@heapify_su
$LN5@heapify_su:

; 595  : 		A[parent_idx] = A[child_idx];

  00080	8b 45 f8	 mov	 eax, DWORD PTR _parent_idx$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00086	8b 55 ec	 mov	 edx, DWORD PTR _child_idx$[ebp]
  00089	8b 75 08	 mov	 esi, DWORD PTR _A$[ebp]
  0008c	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  0008f	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 596  : 		parent_idx = child_idx;

  00092	8b 45 ec	 mov	 eax, DWORD PTR _child_idx$[ebp]
  00095	89 45 f8	 mov	 DWORD PTR _parent_idx$[ebp], eax

; 597  : 	}

  00098	eb a0		 jmp	 SHORT $LN2@heapify_su
$LN3@heapify_su:

; 598  : 	A[parent_idx] = v;

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _parent_idx$[ebp]
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  000a0	8b 55 e0	 mov	 edx, DWORD PTR _v$[ebp]
  000a3	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 599  : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_heapify_subtree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_flush_output
_TEXT	SEGMENT
_os$ = 8						; size = 4
_deflate_flush_output PROC				; COMDAT

; 564  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 565  : 	if (os->next == os->end) /* overflow?  */

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0002e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00031	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00034	75 04		 jne	 SHORT $LN2@deflate_fl

; 566  : 		return 0;

  00036	33 c0		 xor	 eax, eax
  00038	eb 4f		 jmp	 SHORT $LN1@deflate_fl
$LN2@deflate_fl:

; 567  : 
; 568  : 	while ((int)os->bitcount > 0) {

  0003a	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0003d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00041	7e 3a		 jle	 SHORT $LN3@deflate_fl

; 569  : 		*os->next++ = os->bitbuf;

  00043	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00046	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00049	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0004c	8a 02		 mov	 al, BYTE PTR [edx]
  0004e	88 01		 mov	 BYTE PTR [ecx], al
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00053	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00056	83 c2 01	 add	 edx, 1
  00059	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0005c	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 570  : 		os->bitcount -= 8;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	83 e9 08	 sub	 ecx, 8
  00068	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0006b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 571  : 		os->bitbuf >>= 8;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	c1 e9 08	 shr	 ecx, 8
  00076	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00079	89 0a		 mov	 DWORD PTR [edx], ecx

; 572  : 	}

  0007b	eb bd		 jmp	 SHORT $LN2@deflate_fl
$LN3@deflate_fl:

; 573  : 
; 574  : 	return os->next - os->begin;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00083	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00086	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
$LN1@deflate_fl:

; 575  : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_deflate_flush_output ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_align_bitstream
_TEXT	SEGMENT
_os$ = 8						; size = 4
_deflate_align_bitstream PROC				; COMDAT

; 553  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 554  : 	os->bitcount += ((unsigned)-((int)os->bitcount)) & 7;

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	f7 d9		 neg	 ecx
  00030	83 e1 07	 and	 ecx, 7
  00033	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00036	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00039	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0003c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 555  : 	deflate_flush_bits(os);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _deflate_flush_bits
  00048	83 c4 04	 add	 esp, 4

; 556  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_deflate_align_bitstream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_flush_bits
_TEXT	SEGMENT
tv86 = -196						; size = 4
_os$ = 8						; size = 4
_deflate_flush_bits PROC				; COMDAT

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 532  : 	if (UNALIGNED_ACCESS_IS_FAST) {

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 89 00 00
	00		 je	 $LN2@deflate_fl

; 533  : 		/* Flush a whole word (branchlessly).  */
; 534  : 		put_unaligned_leword(os->bitbuf, os->next);

  00035	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00038	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003b	51		 push	 ecx
  0003c	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _put_unaligned_leword
  00047	83 c4 08	 add	 esp, 8

; 535  : 		os->bitbuf >>= os->bitcount & ~7;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0004d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00050	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00053	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	d3 e8		 shr	 eax, cl
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0005d	89 01		 mov	 DWORD PTR [ecx], eax

; 536  : 		os->next += MIN(os->end - os->next, os->bitcount >> 3);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00065	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00068	2b 51 0c	 sub	 edx, DWORD PTR [ecx+12]
  0006b	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0006e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00071	c1 e9 03	 shr	 ecx, 3
  00074	3b d1		 cmp	 edx, ecx
  00076	77 14		 ja	 SHORT $LN8@deflate_fl
  00078	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0007b	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0007e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00081	2b 48 0c	 sub	 ecx, DWORD PTR [eax+12]
  00084	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv86[ebp], ecx
  0008a	eb 0f		 jmp	 SHORT $LN9@deflate_fl
$LN8@deflate_fl:
  0008c	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0008f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00092	c1 e8 03	 shr	 eax, 3
  00095	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv86[ebp], eax
$LN9@deflate_fl:
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0009e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a1	03 95 3c ff ff
	ff		 add	 edx, DWORD PTR tv86[ebp]
  000a7	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000aa	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 537  : 		os->bitcount &= 7;

  000ad	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b3	83 e1 07	 and	 ecx, 7
  000b6	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000b9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 538  : 	} else {

  000bc	eb 51		 jmp	 SHORT $LN1@deflate_fl
$LN2@deflate_fl:

; 539  : 		/* Flush a byte at a time.  */
; 540  : 		while (os->bitcount >= 8) {

  000be	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000c1	83 78 04 08	 cmp	 DWORD PTR [eax+4], 8
  000c5	72 48		 jb	 SHORT $LN1@deflate_fl

; 541  : 			*os->next = os->bitbuf;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000ca	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000cd	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000d0	8a 02		 mov	 al, BYTE PTR [edx]
  000d2	88 01		 mov	 BYTE PTR [ecx], al

; 542  : 			if (os->next != os->end)

  000d4	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  000da	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000dd	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000e0	74 0f		 je	 SHORT $LN6@deflate_fl

; 543  : 				os->next++;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000e5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000e8	83 c1 01	 add	 ecx, 1
  000eb	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000ee	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN6@deflate_fl:

; 544  : 			os->bitcount -= 8;

  000f1	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000f4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f7	83 e9 08	 sub	 ecx, 8
  000fa	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000fd	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 545  : 			os->bitbuf >>= 8;

  00100	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00103	8b 08		 mov	 ecx, DWORD PTR [eax]
  00105	c1 e9 08	 shr	 ecx, 8
  00108	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0010b	89 0a		 mov	 DWORD PTR [edx], ecx

; 546  : 		}

  0010d	eb af		 jmp	 SHORT $LN2@deflate_fl
$LN1@deflate_fl:

; 547  : 	}
; 548  : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00118	3b ec		 cmp	 ebp, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
_deflate_flush_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_add_bits
_TEXT	SEGMENT
_os$ = 8						; size = 4
_bits$ = 12						; size = 4
_num_bits$ = 16						; size = 4
_deflate_add_bits PROC					; COMDAT

; 523  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 524  : 	os->bitbuf |= bits << os->bitcount;

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _bits$[ebp]
  0002e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00031	d3 e2		 shl	 edx, cl
  00033	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00036	0b 10		 or	 edx, DWORD PTR [eax]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0003b	89 11		 mov	 DWORD PTR [ecx], edx

; 525  : 	os->bitcount += num_bits;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	03 4d 10	 add	 ecx, DWORD PTR _num_bits$[ebp]
  00046	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00049	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 526  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_deflate_add_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _deflate_init_output
_TEXT	SEGMENT
_os$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_deflate_init_output PROC				; COMDAT

; 510  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 511  : 	os->bitbuf = 0;

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 512  : 	os->bitcount = 0;

  00031	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00034	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 513  : 	os->begin = buffer;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00041	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 514  : 	os->next = os->begin;

  00044	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0004a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004d	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 515  : 	os->end = os->begin + size - OUTPUT_END_PADDING;

  00050	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00053	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00056	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  00059	8d 44 11 f8	 lea	 eax, DWORD PTR [ecx+edx-8]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00060	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 516  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_deflate_init_output ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\hc_matchfinder.h
;	COMDAT _hc_matchfinder_skip_positions
_TEXT	SEGMENT
_remaining$ = -44					; size = 4
_hash4$ = -32						; size = 4
_hash3$ = -20						; size = 4
_cur_pos$ = -8						; size = 4
_mf$ = 8						; size = 4
_in_base_p$ = 12					; size = 4
_in_next$ = 16						; size = 4
_in_end$ = 20						; size = 4
_count$ = 24						; size = 4
_next_hashes$ = 28					; size = 4
_hc_matchfinder_skip_positions PROC			; COMDAT

; 388  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __779A6228_hc_matchfinder@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 389  : 	u32 cur_pos;
; 390  : 	u32 hash3, hash4;
; 391  : 	
; 392  : 	u32 remaining = count;

  00028	8b 45 18	 mov	 eax, DWORD PTR _count$[ebp]
  0002b	89 45 d4	 mov	 DWORD PTR _remaining$[ebp], eax

; 393  : 
; 394  : 	if (unlikely(count + 5 > in_end - in_next))

  0002e	8b 45 18	 mov	 eax, DWORD PTR _count$[ebp]
  00031	83 c0 05	 add	 eax, 5
  00034	8b 4d 14	 mov	 ecx, DWORD PTR _in_end$[ebp]
  00037	2b 4d 10	 sub	 ecx, DWORD PTR _in_next$[ebp]
  0003a	3b c1		 cmp	 eax, ecx
  0003c	76 0b		 jbe	 SHORT $LN5@hc_matchfi

; 395  : 		return &in_next[count];

  0003e	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  00041	03 45 18	 add	 eax, DWORD PTR _count$[ebp]
  00044	e9 07 01 00 00	 jmp	 $LN1@hc_matchfi
$LN5@hc_matchfi:

; 396  : 
; 397  : 	cur_pos = in_next - *in_base_p;

  00049	8b 45 0c	 mov	 eax, DWORD PTR _in_base_p$[ebp]
  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _in_next$[ebp]
  0004f	2b 08		 sub	 ecx, DWORD PTR [eax]
  00051	89 4d f8	 mov	 DWORD PTR _cur_pos$[ebp], ecx

; 398  : 	hash3 = next_hashes[0];

  00054	b8 04 00 00 00	 mov	 eax, 4
  00059	6b c8 00	 imul	 ecx, eax, 0
  0005c	8b 55 1c	 mov	 edx, DWORD PTR _next_hashes$[ebp]
  0005f	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00062	89 45 ec	 mov	 DWORD PTR _hash3$[ebp], eax

; 399  : 	hash4 = next_hashes[1];

  00065	b8 04 00 00 00	 mov	 eax, 4
  0006a	c1 e0 00	 shl	 eax, 0
  0006d	8b 4d 1c	 mov	 ecx, DWORD PTR _next_hashes$[ebp]
  00070	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00073	89 55 e0	 mov	 DWORD PTR _hash4$[ebp], edx
$LN4@hc_matchfi:

; 400  : 	do {
; 401  : 		if (cur_pos == MATCHFINDER_WINDOW_SIZE) {

  00076	81 7d f8 00 80
	00 00		 cmp	 DWORD PTR _cur_pos$[ebp], 32768 ; 00008000H
  0007d	75 23		 jne	 SHORT $LN6@hc_matchfi

; 402  : 			hc_matchfinder_slide_window(mf);

  0007f	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _hc_matchfinder_slide_window
  00088	83 c4 04	 add	 esp, 4

; 403  : 			*in_base_p += MATCHFINDER_WINDOW_SIZE;

  0008b	8b 45 0c	 mov	 eax, DWORD PTR _in_base_p$[ebp]
  0008e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00090	81 c1 00 80 00
	00		 add	 ecx, 32768		; 00008000H
  00096	8b 55 0c	 mov	 edx, DWORD PTR _in_base_p$[ebp]
  00099	89 0a		 mov	 DWORD PTR [edx], ecx

; 404  : 			cur_pos = 0;

  0009b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cur_pos$[ebp], 0
$LN6@hc_matchfi:

; 405  : 		}
; 406  : 		mf->hash3_tab[hash3] = cur_pos;

  000a2	8b 45 ec	 mov	 eax, DWORD PTR _hash3$[ebp]
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000a8	66 8b 55 f8	 mov	 dx, WORD PTR _cur_pos$[ebp]
  000ac	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 407  : 		mf->next_tab[cur_pos] = mf->hash4_tab[hash4];

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _cur_pos$[ebp]
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000b6	8b 55 e0	 mov	 edx, DWORD PTR _hash4$[ebp]
  000b9	8b 75 08	 mov	 esi, DWORD PTR _mf$[ebp]
  000bc	66 8b 94 56 00
	00 01 00	 mov	 dx, WORD PTR [esi+edx*2+65536]
  000c4	66 89 94 41 00
	00 03 00	 mov	 WORD PTR [ecx+eax*2+196608], dx

; 408  : 		mf->hash4_tab[hash4] = cur_pos;

  000cc	8b 45 e0	 mov	 eax, DWORD PTR _hash4$[ebp]
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000d2	66 8b 55 f8	 mov	 dx, WORD PTR _cur_pos$[ebp]
  000d6	66 89 94 41 00
	00 01 00	 mov	 WORD PTR [ecx+eax*2+65536], dx

; 409  : 
; 410  : 		//
; 411  : 
; 412  : 		/*u32 next_hashseq;
; 413  : 		next_hashseq = get_unaligned_le32(++in_next);
; 414  : 		hash3 = lz_hash(next_hashseq & 0xFFFFFF, HC_MATCHFINDER_HASH3_ORDER);
; 415  : 		hash4 = lz_hash(next_hashseq, HC_MATCHFINDER_HASH4_ORDER);
; 416  : 		*/
; 417  : 		//OPTIMIZE
; 418  : 		
; 419  : 		hash3 = lz_hash(*((u32*)(++in_next)) & 0xFFFFFF, HC_MATCHFINDER_HASH3_ORDER);

  000de	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  000e1	83 c0 01	 add	 eax, 1
  000e4	89 45 10	 mov	 DWORD PTR _in_next$[ebp], eax
  000e7	6a 0f		 push	 15			; 0000000fH
  000e9	8b 4d 10	 mov	 ecx, DWORD PTR _in_next$[ebp]
  000ec	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ee	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _lz_hash
  000fa	83 c4 08	 add	 esp, 8
  000fd	89 45 ec	 mov	 DWORD PTR _hash3$[ebp], eax

; 420  : 		hash4 = lz_hash(*((u32*)(in_next)), HC_MATCHFINDER_HASH4_ORDER);

  00100	6a 10		 push	 16			; 00000010H
  00102	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  00105	8b 08		 mov	 ecx, DWORD PTR [eax]
  00107	51		 push	 ecx
  00108	e8 00 00 00 00	 call	 _lz_hash
  0010d	83 c4 08	 add	 esp, 8
  00110	89 45 e0	 mov	 DWORD PTR _hash4$[ebp], eax

; 421  : 		
; 422  : 		///
; 423  : 		
; 424  : 		cur_pos++;

  00113	8b 45 f8	 mov	 eax, DWORD PTR _cur_pos$[ebp]
  00116	83 c0 01	 add	 eax, 1
  00119	89 45 f8	 mov	 DWORD PTR _cur_pos$[ebp], eax

; 425  : 	} while (--remaining);

  0011c	8b 45 d4	 mov	 eax, DWORD PTR _remaining$[ebp]
  0011f	83 e8 01	 sub	 eax, 1
  00122	89 45 d4	 mov	 DWORD PTR _remaining$[ebp], eax
  00125	0f 85 4b ff ff
	ff		 jne	 $LN4@hc_matchfi

; 426  : 
; 427  : 	prefetchw(&mf->hash3_tab[hash3]);
; 428  : 	prefetchw(&mf->hash4_tab[hash4]);
; 429  : 	next_hashes[0] = hash3;

  0012b	b8 04 00 00 00	 mov	 eax, 4
  00130	6b c8 00	 imul	 ecx, eax, 0
  00133	8b 55 1c	 mov	 edx, DWORD PTR _next_hashes$[ebp]
  00136	8b 45 ec	 mov	 eax, DWORD PTR _hash3$[ebp]
  00139	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 430  : 	next_hashes[1] = hash4;

  0013c	b8 04 00 00 00	 mov	 eax, 4
  00141	c1 e0 00	 shl	 eax, 0
  00144	8b 4d 1c	 mov	 ecx, DWORD PTR _next_hashes$[ebp]
  00147	8b 55 e0	 mov	 edx, DWORD PTR _hash4$[ebp]
  0014a	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 431  : 	return in_next;

  0014d	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
$LN1@hc_matchfi:

; 432  : }//the most long function

  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00159	3b ec		 cmp	 ebp, esp
  0015b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
_hc_matchfinder_skip_positions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\hc_matchfinder.h
;	COMDAT _hc_matchfinder_longest_match
_TEXT	SEGMENT
_cutoff$ = -152						; size = 2
_in_base$ = -140					; size = 4
_cur_pos$ = -128					; size = 4
_len$ = -116						; size = 4
_matchptr$ = -104					; size = 4
_seq4$ = -92						; size = 4
_next_hashseq$ = -80					; size = 4
_hash4$ = -68						; size = 4
_hash3$ = -56						; size = 4
_cur_node4$ = -44					; size = 2
_cur_node3$ = -32					; size = 2
_best_matchptr$ = -20					; size = 4
_depth_remaining$ = -8					; size = 4
_mf$ = 8						; size = 4
_in_base_p$ = 12					; size = 4
_in_next$ = 16						; size = 4
_best_len$ = 20						; size = 4
_max_len$ = 24						; size = 4
_nice_len$ = 28						; size = 4
_max_search_depth$ = 32					; size = 4
_next_hashes$ = 36					; size = 4
_offset_ret$ = 40					; size = 4
_hc_matchfinder_longest_match PROC			; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-348]
  00012	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __779A6228_hc_matchfinder@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 193  : 	u32 depth_remaining = max_search_depth;

  00028	8b 45 20	 mov	 eax, DWORD PTR _max_search_depth$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _depth_remaining$[ebp], eax

; 194  : 	const u8 *best_matchptr = in_next;

  0002e	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  00031	89 45 ec	 mov	 DWORD PTR _best_matchptr$[ebp], eax

; 195  : 	mf_pos_t cur_node3, cur_node4;
; 196  : 	u32 hash3, hash4;
; 197  : 	u32 next_hashseq;
; 198  : 	u32 seq4;
; 199  : 	const u8 *matchptr;
; 200  : 	u32 len;
; 201  : 	u32 cur_pos = in_next - *in_base_p;

  00034	8b 45 0c	 mov	 eax, DWORD PTR _in_base_p$[ebp]
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _in_next$[ebp]
  0003a	2b 08		 sub	 ecx, DWORD PTR [eax]
  0003c	89 4d 80	 mov	 DWORD PTR _cur_pos$[ebp], ecx

; 202  : 	const u8 *in_base;
; 203  : 	mf_pos_t cutoff;
; 204  : 
; 205  : 	if (cur_pos == MATCHFINDER_WINDOW_SIZE) {

  0003f	81 7d 80 00 80
	00 00		 cmp	 DWORD PTR _cur_pos$[ebp], 32768 ; 00008000H
  00046	75 23		 jne	 SHORT $LN11@hc_matchfi

; 206  : 		hc_matchfinder_slide_window(mf);

  00048	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _hc_matchfinder_slide_window
  00051	83 c4 04	 add	 esp, 4

; 207  : 		*in_base_p += MATCHFINDER_WINDOW_SIZE;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _in_base_p$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	81 c1 00 80 00
	00		 add	 ecx, 32768		; 00008000H
  0005f	8b 55 0c	 mov	 edx, DWORD PTR _in_base_p$[ebp]
  00062	89 0a		 mov	 DWORD PTR [edx], ecx

; 208  : 		cur_pos = 0;

  00064	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _cur_pos$[ebp], 0
$LN11@hc_matchfi:

; 209  : 	}
; 210  : 
; 211  : 	in_base = *in_base_p;

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _in_base_p$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _in_base$[ebp], ecx

; 212  : 	cutoff = cur_pos - MATCHFINDER_WINDOW_SIZE;

  00076	8b 45 80	 mov	 eax, DWORD PTR _cur_pos$[ebp]
  00079	2d 00 80 00 00	 sub	 eax, 32768		; 00008000H
  0007e	66 89 85 68 ff
	ff ff		 mov	 WORD PTR _cutoff$[ebp], ax

; 213  : 
; 214  : 	if (unlikely(max_len < 5)) /* can we read 4 bytes from 'in_next + 1'? */

  00085	83 7d 18 05	 cmp	 DWORD PTR _max_len$[ebp], 5
  00089	73 05		 jae	 SHORT $LN12@hc_matchfi

; 215  : 		goto out;

  0008b	e9 27 03 00 00	 jmp	 $out$35
$LN12@hc_matchfi:

; 216  : 
; 217  : 	/* Get the precomputed hash codes.  */
; 218  : 	hash3 = next_hashes[0];

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	6b c8 00	 imul	 ecx, eax, 0
  00098	8b 55 24	 mov	 edx, DWORD PTR _next_hashes$[ebp]
  0009b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0009e	89 45 c8	 mov	 DWORD PTR _hash3$[ebp], eax

; 219  : 	hash4 = next_hashes[1];

  000a1	b8 04 00 00 00	 mov	 eax, 4
  000a6	c1 e0 00	 shl	 eax, 0
  000a9	8b 4d 24	 mov	 ecx, DWORD PTR _next_hashes$[ebp]
  000ac	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000af	89 55 bc	 mov	 DWORD PTR _hash4$[ebp], edx

; 220  : 
; 221  : 	/* From the hash buckets, get the first node of each linked list.  */
; 222  : 	cur_node3 = mf->hash3_tab[hash3];

  000b2	8b 45 c8	 mov	 eax, DWORD PTR _hash3$[ebp]
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000b8	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000bc	66 89 55 e0	 mov	 WORD PTR _cur_node3$[ebp], dx

; 223  : 	cur_node4 = mf->hash4_tab[hash4];

  000c0	8b 45 bc	 mov	 eax, DWORD PTR _hash4$[ebp]
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000c6	66 8b 94 41 00
	00 01 00	 mov	 dx, WORD PTR [ecx+eax*2+65536]
  000ce	66 89 55 d4	 mov	 WORD PTR _cur_node4$[ebp], dx

; 224  : 
; 225  : 	/* Update for length 3 matches.  This replaces the singleton node in the
; 226  : 	 * 'hash3' bucket with the node for the current sequence.  */
; 227  : 	mf->hash3_tab[hash3] = cur_pos;

  000d2	8b 45 c8	 mov	 eax, DWORD PTR _hash3$[ebp]
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000d8	66 8b 55 80	 mov	 dx, WORD PTR _cur_pos$[ebp]
  000dc	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 228  : 
; 229  : 	/* Update for length 4 matches.  This prepends the node for the current
; 230  : 	 * sequence to the linked list in the 'hash4' bucket.  */
; 231  : 	mf->hash4_tab[hash4] = cur_pos;

  000e0	8b 45 bc	 mov	 eax, DWORD PTR _hash4$[ebp]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000e6	66 8b 55 80	 mov	 dx, WORD PTR _cur_pos$[ebp]
  000ea	66 89 94 41 00
	00 01 00	 mov	 WORD PTR [ecx+eax*2+65536], dx

; 232  : 	mf->next_tab[cur_pos] = cur_node4;

  000f2	8b 45 80	 mov	 eax, DWORD PTR _cur_pos$[ebp]
  000f5	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000f8	66 8b 55 d4	 mov	 dx, WORD PTR _cur_node4$[ebp]
  000fc	66 89 94 41 00
	00 03 00	 mov	 WORD PTR [ecx+eax*2+196608], dx

; 233  : 
; 234  : 	/* Compute the next hash codes.  */
; 235  : 	next_hashseq = get_unaligned_le32(in_next + 1);

  00104	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  00107	83 c0 01	 add	 eax, 1
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 _get_unaligned_le32
  00110	83 c4 04	 add	 esp, 4
  00113	89 45 b0	 mov	 DWORD PTR _next_hashseq$[ebp], eax

; 236  : 	next_hashes[0] = lz_hash(next_hashseq & 0xFFFFFF, HC_MATCHFINDER_HASH3_ORDER);

  00116	6a 0f		 push	 15			; 0000000fH
  00118	8b 45 b0	 mov	 eax, DWORD PTR _next_hashseq$[ebp]
  0011b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _lz_hash
  00126	83 c4 08	 add	 esp, 8
  00129	b9 04 00 00 00	 mov	 ecx, 4
  0012e	6b d1 00	 imul	 edx, ecx, 0
  00131	8b 4d 24	 mov	 ecx, DWORD PTR _next_hashes$[ebp]
  00134	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 237  : 	next_hashes[1] = lz_hash(next_hashseq, HC_MATCHFINDER_HASH4_ORDER);

  00137	6a 10		 push	 16			; 00000010H
  00139	8b 45 b0	 mov	 eax, DWORD PTR _next_hashseq$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _lz_hash
  00142	83 c4 08	 add	 esp, 8
  00145	b9 04 00 00 00	 mov	 ecx, 4
  0014a	c1 e1 00	 shl	 ecx, 0
  0014d	8b 55 24	 mov	 edx, DWORD PTR _next_hashes$[ebp]
  00150	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 238  : 	prefetchw(&mf->hash3_tab[next_hashes[0]]);
; 239  : 	prefetchw(&mf->hash4_tab[next_hashes[1]]);
; 240  : 
; 241  : 	if (best_len < 4) {  /* No match of length >= 4 found yet?  */

  00153	83 7d 14 04	 cmp	 DWORD PTR _best_len$[ebp], 4
  00157	0f 83 33 01 00
	00		 jae	 $LN13@hc_matchfi

; 242  : 
; 243  : 		/* Check for a length 3 match if needed.  */
; 244  : 
; 245  : 		if (cur_node3 <= cutoff)

  0015d	0f bf 45 e0	 movsx	 eax, WORD PTR _cur_node3$[ebp]
  00161	0f bf 8d 68 ff
	ff ff		 movsx	 ecx, WORD PTR _cutoff$[ebp]
  00168	3b c1		 cmp	 eax, ecx
  0016a	7f 05		 jg	 SHORT $LN15@hc_matchfi

; 246  : 			goto out;

  0016c	e9 46 02 00 00	 jmp	 $out$35
$LN15@hc_matchfi:

; 247  : 
; 248  : 		seq4 = load_u32_unaligned(in_next);

  00171	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _load_u32_unaligned
  0017a	83 c4 04	 add	 esp, 4
  0017d	89 45 a4	 mov	 DWORD PTR _seq4$[ebp], eax

; 249  : 
; 250  : 		if (best_len < 3) {

  00180	83 7d 14 03	 cmp	 DWORD PTR _best_len$[ebp], 3
  00184	73 38		 jae	 SHORT $LN16@hc_matchfi

; 251  : 			matchptr = &in_base[cur_node3];

  00186	0f bf 45 e0	 movsx	 eax, WORD PTR _cur_node3$[ebp]
  0018a	03 85 74 ff ff
	ff		 add	 eax, DWORD PTR _in_base$[ebp]
  00190	89 45 98	 mov	 DWORD PTR _matchptr$[ebp], eax

; 252  : 			if (load_u24_unaligned(matchptr) == loaded_u32_to_u24(seq4)) {

  00193	8b 45 98	 mov	 eax, DWORD PTR _matchptr$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _load_u24_unaligned
  0019c	83 c4 04	 add	 esp, 4
  0019f	8b f0		 mov	 esi, eax
  001a1	8b 4d a4	 mov	 ecx, DWORD PTR _seq4$[ebp]
  001a4	51		 push	 ecx
  001a5	e8 00 00 00 00	 call	 _loaded_u32_to_u24
  001aa	83 c4 04	 add	 esp, 4
  001ad	3b f0		 cmp	 esi, eax
  001af	75 0d		 jne	 SHORT $LN16@hc_matchfi

; 253  : 				best_len = 3;

  001b1	c7 45 14 03 00
	00 00		 mov	 DWORD PTR _best_len$[ebp], 3

; 254  : 				best_matchptr = matchptr;

  001b8	8b 45 98	 mov	 eax, DWORD PTR _matchptr$[ebp]
  001bb	89 45 ec	 mov	 DWORD PTR _best_matchptr$[ebp], eax
$LN16@hc_matchfi:

; 255  : 			}
; 256  : 		}
; 257  : 
; 258  : 		/* Check for a length 4 match.  */
; 259  : 
; 260  : 		if (cur_node4 <= cutoff)

  001be	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  001c2	0f bf 8d 68 ff
	ff ff		 movsx	 ecx, WORD PTR _cutoff$[ebp]
  001c9	3b c1		 cmp	 eax, ecx
  001cb	7f 05		 jg	 SHORT $LN4@hc_matchfi

; 261  : 			goto out;

  001cd	e9 e5 01 00 00	 jmp	 $out$35
$LN4@hc_matchfi:

; 262  : 
; 263  : 		for (;;) {
; 264  : 			/* No length 4 match found yet.  Check the first 4 bytes.  */
; 265  : 			matchptr = &in_base[cur_node4];

  001d2	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  001d6	03 85 74 ff ff
	ff		 add	 eax, DWORD PTR _in_base$[ebp]
  001dc	89 45 98	 mov	 DWORD PTR _matchptr$[ebp], eax

; 266  : 
; 267  : 			if (load_u32_unaligned(matchptr) == seq4)

  001df	8b 45 98	 mov	 eax, DWORD PTR _matchptr$[ebp]
  001e2	50		 push	 eax
  001e3	e8 00 00 00 00	 call	 _load_u32_unaligned
  001e8	83 c4 04	 add	 esp, 4
  001eb	3b 45 a4	 cmp	 eax, DWORD PTR _seq4$[ebp]
  001ee	75 02		 jne	 SHORT $LN19@hc_matchfi

; 268  : 				break;

  001f0	eb 39		 jmp	 SHORT $LN3@hc_matchfi
$LN19@hc_matchfi:

; 269  : 
; 270  : 			/* The first 4 bytes did not match.  Keep trying.  */
; 271  : 			cur_node4 = mf->next_tab[cur_node4 & (MATCHFINDER_WINDOW_SIZE - 1)];

  001f2	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  001f6	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  001fb	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001fe	66 8b 94 41 00
	00 03 00	 mov	 dx, WORD PTR [ecx+eax*2+196608]
  00206	66 89 55 d4	 mov	 WORD PTR _cur_node4$[ebp], dx

; 272  : 			if (cur_node4 <= cutoff || !--depth_remaining)

  0020a	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  0020e	0f bf 8d 68 ff
	ff ff		 movsx	 ecx, WORD PTR _cutoff$[ebp]
  00215	3b c1		 cmp	 eax, ecx
  00217	7e 0b		 jle	 SHORT $LN21@hc_matchfi
  00219	8b 45 f8	 mov	 eax, DWORD PTR _depth_remaining$[ebp]
  0021c	83 e8 01	 sub	 eax, 1
  0021f	89 45 f8	 mov	 DWORD PTR _depth_remaining$[ebp], eax
  00222	75 05		 jne	 SHORT $LN20@hc_matchfi
$LN21@hc_matchfi:

; 273  : 				goto out;

  00224	e9 8e 01 00 00	 jmp	 $out$35
$LN20@hc_matchfi:

; 274  : 		}

  00229	eb a7		 jmp	 SHORT $LN4@hc_matchfi
$LN3@hc_matchfi:

; 275  : 
; 276  : 		/* Found a match of length >= 4.  Extend it to its full length.  */
; 277  : 		best_matchptr = matchptr;

  0022b	8b 45 98	 mov	 eax, DWORD PTR _matchptr$[ebp]
  0022e	89 45 ec	 mov	 DWORD PTR _best_matchptr$[ebp], eax

; 278  : 		best_len = lz_extend(in_next, best_matchptr, 4, max_len);

  00231	8b 45 18	 mov	 eax, DWORD PTR _max_len$[ebp]
  00234	50		 push	 eax
  00235	6a 04		 push	 4
  00237	8b 4d ec	 mov	 ecx, DWORD PTR _best_matchptr$[ebp]
  0023a	51		 push	 ecx
  0023b	8b 55 10	 mov	 edx, DWORD PTR _in_next$[ebp]
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 _lz_extend
  00244	83 c4 10	 add	 esp, 16			; 00000010H
  00247	89 45 14	 mov	 DWORD PTR _best_len$[ebp], eax

; 279  : 		if (best_len >= nice_len)

  0024a	8b 45 14	 mov	 eax, DWORD PTR _best_len$[ebp]
  0024d	3b 45 1c	 cmp	 eax, DWORD PTR _nice_len$[ebp]
  00250	72 05		 jb	 SHORT $LN22@hc_matchfi

; 280  : 			goto out;

  00252	e9 60 01 00 00	 jmp	 $out$35
$LN22@hc_matchfi:

; 281  : 		cur_node4 = mf->next_tab[cur_node4 & (MATCHFINDER_WINDOW_SIZE - 1)];

  00257	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  0025b	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00260	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00263	66 8b 94 41 00
	00 03 00	 mov	 dx, WORD PTR [ecx+eax*2+196608]
  0026b	66 89 55 d4	 mov	 WORD PTR _cur_node4$[ebp], dx

; 282  : 		if (cur_node4 <= cutoff || !--depth_remaining)

  0026f	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  00273	0f bf 8d 68 ff
	ff ff		 movsx	 ecx, WORD PTR _cutoff$[ebp]
  0027a	3b c1		 cmp	 eax, ecx
  0027c	7e 0b		 jle	 SHORT $LN24@hc_matchfi
  0027e	8b 45 f8	 mov	 eax, DWORD PTR _depth_remaining$[ebp]
  00281	83 e8 01	 sub	 eax, 1
  00284	89 45 f8	 mov	 DWORD PTR _depth_remaining$[ebp], eax
  00287	75 05		 jne	 SHORT $LN23@hc_matchfi
$LN24@hc_matchfi:

; 283  : 			goto out;

  00289	e9 29 01 00 00	 jmp	 $out$35
$LN23@hc_matchfi:

; 284  : 	} else {

  0028e	eb 1c		 jmp	 SHORT $LN10@hc_matchfi
$LN13@hc_matchfi:

; 285  : 		if (cur_node4 <= cutoff || best_len >= nice_len)

  00290	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  00294	0f bf 8d 68 ff
	ff ff		 movsx	 ecx, WORD PTR _cutoff$[ebp]
  0029b	3b c1		 cmp	 eax, ecx
  0029d	7e 08		 jle	 SHORT $LN26@hc_matchfi
  0029f	8b 45 14	 mov	 eax, DWORD PTR _best_len$[ebp]
  002a2	3b 45 1c	 cmp	 eax, DWORD PTR _nice_len$[ebp]
  002a5	72 05		 jb	 SHORT $LN10@hc_matchfi
$LN26@hc_matchfi:

; 286  : 			goto out;

  002a7	e9 0b 01 00 00	 jmp	 $out$35
$LN10@hc_matchfi:

; 287  : 	}
; 288  : 
; 289  : 	/* Check for matches of length >= 5.  */
; 290  : 
; 291  : 	for (;;) {
; 292  : 		for (;;) {
; 293  : 			matchptr = &in_base[cur_node4];

  002ac	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  002b0	03 85 74 ff ff
	ff		 add	 eax, DWORD PTR _in_base$[ebp]
  002b6	89 45 98	 mov	 DWORD PTR _matchptr$[ebp], eax

; 294  : 
; 295  : 			/* Already found a length 4 match.  Try for a longer
; 296  : 			 * match; start by checking either the last 4 bytes and
; 297  : 			 * the first 4 bytes, or the last byte.  (The last byte,
; 298  : 			 * the one which would extend the match length by 1, is
; 299  : 			 * the most important.)  */
; 300  : 		#if UNALIGNED_ACCESS_IS_FAST
; 301  : 			if ((load_u32_unaligned(matchptr + best_len - 3) ==
; 302  : 			     load_u32_unaligned(in_next + best_len - 3)) &&

  002b9	8b 45 14	 mov	 eax, DWORD PTR _best_len$[ebp]
  002bc	8b 4d 98	 mov	 ecx, DWORD PTR _matchptr$[ebp]
  002bf	8d 54 01 fd	 lea	 edx, DWORD PTR [ecx+eax-3]
  002c3	52		 push	 edx
  002c4	e8 00 00 00 00	 call	 _load_u32_unaligned
  002c9	83 c4 04	 add	 esp, 4
  002cc	8b f0		 mov	 esi, eax
  002ce	8b 45 14	 mov	 eax, DWORD PTR _best_len$[ebp]
  002d1	8b 4d 10	 mov	 ecx, DWORD PTR _in_next$[ebp]
  002d4	8d 54 01 fd	 lea	 edx, DWORD PTR [ecx+eax-3]
  002d8	52		 push	 edx
  002d9	e8 00 00 00 00	 call	 _load_u32_unaligned
  002de	83 c4 04	 add	 esp, 4
  002e1	3b f0		 cmp	 esi, eax
  002e3	75 20		 jne	 SHORT $LN27@hc_matchfi
  002e5	8b 45 98	 mov	 eax, DWORD PTR _matchptr$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _load_u32_unaligned
  002ee	83 c4 04	 add	 esp, 4
  002f1	8b f0		 mov	 esi, eax
  002f3	8b 4d 10	 mov	 ecx, DWORD PTR _in_next$[ebp]
  002f6	51		 push	 ecx
  002f7	e8 00 00 00 00	 call	 _load_u32_unaligned
  002fc	83 c4 04	 add	 esp, 4
  002ff	3b f0		 cmp	 esi, eax
  00301	75 02		 jne	 SHORT $LN27@hc_matchfi

; 303  : 			    (load_u32_unaligned(matchptr) ==
; 304  : 			     load_u32_unaligned(in_next)))
; 305  : 		#else
; 306  : 			if (matchptr[best_len] == in_next[best_len])
; 307  : 		#endif
; 308  : 				break;

  00303	eb 39		 jmp	 SHORT $LN9@hc_matchfi
$LN27@hc_matchfi:

; 309  : 
; 310  : 			/* Continue to the next node in the list.  */
; 311  : 			cur_node4 = mf->next_tab[cur_node4 & (MATCHFINDER_WINDOW_SIZE - 1)];

  00305	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  00309	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  0030e	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00311	66 8b 94 41 00
	00 03 00	 mov	 dx, WORD PTR [ecx+eax*2+196608]
  00319	66 89 55 d4	 mov	 WORD PTR _cur_node4$[ebp], dx

; 312  : 			if (cur_node4 <= cutoff || !--depth_remaining)

  0031d	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  00321	0f bf 8d 68 ff
	ff ff		 movsx	 ecx, WORD PTR _cutoff$[ebp]
  00328	3b c1		 cmp	 eax, ecx
  0032a	7e 0b		 jle	 SHORT $LN29@hc_matchfi
  0032c	8b 45 f8	 mov	 eax, DWORD PTR _depth_remaining$[ebp]
  0032f	83 e8 01	 sub	 eax, 1
  00332	89 45 f8	 mov	 DWORD PTR _depth_remaining$[ebp], eax
  00335	75 02		 jne	 SHORT $LN28@hc_matchfi
$LN29@hc_matchfi:

; 313  : 				goto out;

  00337	eb 7e		 jmp	 SHORT $out$35
$LN28@hc_matchfi:

; 314  : 		}

  00339	e9 6e ff ff ff	 jmp	 $LN10@hc_matchfi
$LN9@hc_matchfi:

; 315  : 
; 316  : 	#if UNALIGNED_ACCESS_IS_FAST
; 317  : 		len = 4;

  0033e	c7 45 8c 04 00
	00 00		 mov	 DWORD PTR _len$[ebp], 4

; 318  : 	#else
; 319  : 		len = 0;
; 320  : 	#endif
; 321  : 		len = lz_extend(in_next, matchptr, len, max_len);

  00345	8b 45 18	 mov	 eax, DWORD PTR _max_len$[ebp]
  00348	50		 push	 eax
  00349	8b 4d 8c	 mov	 ecx, DWORD PTR _len$[ebp]
  0034c	51		 push	 ecx
  0034d	8b 55 98	 mov	 edx, DWORD PTR _matchptr$[ebp]
  00350	52		 push	 edx
  00351	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  00354	50		 push	 eax
  00355	e8 00 00 00 00	 call	 _lz_extend
  0035a	83 c4 10	 add	 esp, 16			; 00000010H
  0035d	89 45 8c	 mov	 DWORD PTR _len$[ebp], eax

; 322  : 		if (len > best_len) {

  00360	8b 45 8c	 mov	 eax, DWORD PTR _len$[ebp]
  00363	3b 45 14	 cmp	 eax, DWORD PTR _best_len$[ebp]
  00366	76 16		 jbe	 SHORT $LN30@hc_matchfi

; 323  : 			/* This is the new longest match.  */
; 324  : 			best_len = len;

  00368	8b 45 8c	 mov	 eax, DWORD PTR _len$[ebp]
  0036b	89 45 14	 mov	 DWORD PTR _best_len$[ebp], eax

; 325  : 			best_matchptr = matchptr;

  0036e	8b 45 98	 mov	 eax, DWORD PTR _matchptr$[ebp]
  00371	89 45 ec	 mov	 DWORD PTR _best_matchptr$[ebp], eax

; 326  : 			if (best_len >= nice_len)

  00374	8b 45 14	 mov	 eax, DWORD PTR _best_len$[ebp]
  00377	3b 45 1c	 cmp	 eax, DWORD PTR _nice_len$[ebp]
  0037a	72 02		 jb	 SHORT $LN30@hc_matchfi

; 327  : 				goto out;

  0037c	eb 39		 jmp	 SHORT $out$35
$LN30@hc_matchfi:

; 328  : 		}
; 329  : 
; 330  : 		/* Continue to the next node in the list.  */
; 331  : 		cur_node4 = mf->next_tab[cur_node4 & (MATCHFINDER_WINDOW_SIZE - 1)];

  0037e	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  00382	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00387	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0038a	66 8b 94 41 00
	00 03 00	 mov	 dx, WORD PTR [ecx+eax*2+196608]
  00392	66 89 55 d4	 mov	 WORD PTR _cur_node4$[ebp], dx

; 332  : 		if (cur_node4 <= cutoff || !--depth_remaining)

  00396	0f bf 45 d4	 movsx	 eax, WORD PTR _cur_node4$[ebp]
  0039a	0f bf 8d 68 ff
	ff ff		 movsx	 ecx, WORD PTR _cutoff$[ebp]
  003a1	3b c1		 cmp	 eax, ecx
  003a3	7e 0b		 jle	 SHORT $LN33@hc_matchfi
  003a5	8b 45 f8	 mov	 eax, DWORD PTR _depth_remaining$[ebp]
  003a8	83 e8 01	 sub	 eax, 1
  003ab	89 45 f8	 mov	 DWORD PTR _depth_remaining$[ebp], eax
  003ae	75 02		 jne	 SHORT $LN32@hc_matchfi
$LN33@hc_matchfi:

; 333  : 			goto out;

  003b0	eb 05		 jmp	 SHORT $out$35
$LN32@hc_matchfi:

; 334  : 	}

  003b2	e9 f5 fe ff ff	 jmp	 $LN10@hc_matchfi
$out$35:

; 335  : out:
; 336  : 	*offset_ret = in_next - best_matchptr;

  003b7	8b 45 10	 mov	 eax, DWORD PTR _in_next$[ebp]
  003ba	2b 45 ec	 sub	 eax, DWORD PTR _best_matchptr$[ebp]
  003bd	8b 4d 28	 mov	 ecx, DWORD PTR _offset_ret$[ebp]
  003c0	89 01		 mov	 DWORD PTR [ecx], eax

; 337  : 	return best_len;

  003c2	8b 45 14	 mov	 eax, DWORD PTR _best_len$[ebp]

; 338  : }//second long

  003c5	5f		 pop	 edi
  003c6	5e		 pop	 esi
  003c7	5b		 pop	 ebx
  003c8	81 c4 5c 01 00
	00		 add	 esp, 348		; 0000015cH
  003ce	3b ec		 cmp	 ebp, esp
  003d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d5	8b e5		 mov	 esp, ebp
  003d7	5d		 pop	 ebp
  003d8	c3		 ret	 0
_hc_matchfinder_longest_match ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\hc_matchfinder.h
;	COMDAT _hc_matchfinder_slide_window
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_hc_matchfinder_slide_window PROC			; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __779A6228_hc_matchfinder@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 147  : 	matchfinder_rebase((mf_pos_t *)mf,

  00028	68 00 00 02 00	 push	 131072			; 00020000H
  0002d	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _matchfinder_rebase
  00036	83 c4 08	 add	 esp, 8

; 148  : 			   sizeof(struct hc_matchfinder) / sizeof(mf_pos_t));
; 149  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_hc_matchfinder_slide_window ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\hc_matchfinder.h
;	COMDAT _hc_matchfinder_init
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_hc_matchfinder_init PROC				; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __779A6228_hc_matchfinder@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 141  : 	matchfinder_init((mf_pos_t *)mf, HC_MATCHFINDER_TOTAL_HASH_LENGTH);

  00028	68 00 80 01 00	 push	 98304			; 00018000H
  0002d	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _matchfinder_init
  00036	83 c4 08	 add	 esp, 8

; 142  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_hc_matchfinder_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\matchfinder_common.h
;	COMDAT _lz_extend
_TEXT	SEGMENT
_v_word$ = -20						; size = 4
_len$ = -8						; size = 4
_strptr$ = 8						; size = 4
_matchptr$ = 12						; size = 4
_start_len$ = 16					; size = 4
_max_len$ = 20						; size = 4
_lz_extend PROC						; COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09230FC3_matchfinder_common@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 133  : 	unsigned len = start_len;

  00028	8b 45 10	 mov	 eax, DWORD PTR _start_len$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 134  : 	machine_word_t v_word;
; 135  : 
; 136  : 	if (UNALIGNED_ACCESS_IS_FAST) {

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	0f 84 1f 01 00
	00		 je	 $LN4@lz_extend

; 137  : 
; 138  : 		if (likely(max_len - len >= 4 * WORDBYTES)) {

  0003b	8b 45 14	 mov	 eax, DWORD PTR _max_len$[ebp]
  0003e	2b 45 f8	 sub	 eax, DWORD PTR _len$[ebp]
  00041	83 f8 10	 cmp	 eax, 16			; 00000010H
  00044	0f 82 d1 00 00
	00		 jb	 $LN2@lz_extend

; 139  : 
; 140  : 		#define COMPARE_WORD_STEP				\
; 141  : 			v_word = load_word_unaligned(&matchptr[len]) ^	\
; 142  : 				 load_word_unaligned(&strptr[len]);	\
; 143  : 			if (v_word != 0)				\
; 144  : 				goto word_differs;			\
; 145  : 			len += WORDBYTES;				\
; 146  : 
; 147  : 			COMPARE_WORD_STEP

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _matchptr$[ebp]
  0004d	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  00056	83 c4 04	 add	 esp, 4
  00059	8b f0		 mov	 esi, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _strptr$[ebp]
  0005e	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  00067	83 c4 04	 add	 esp, 4
  0006a	33 f0		 xor	 esi, eax
  0006c	89 75 ec	 mov	 DWORD PTR _v_word$[ebp], esi
  0006f	74 05		 je	 SHORT $LN8@lz_extend
  00071	e9 12 01 00 00	 jmp	 $word_differs$16
$LN8@lz_extend:
  00076	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00079	83 c0 04	 add	 eax, 4
  0007c	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 148  : 			COMPARE_WORD_STEP

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _matchptr$[ebp]
  00082	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  0008b	83 c4 04	 add	 esp, 4
  0008e	8b f0		 mov	 esi, eax
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _strptr$[ebp]
  00093	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  0009c	83 c4 04	 add	 esp, 4
  0009f	33 f0		 xor	 esi, eax
  000a1	89 75 ec	 mov	 DWORD PTR _v_word$[ebp], esi
  000a4	74 05		 je	 SHORT $LN9@lz_extend
  000a6	e9 dd 00 00 00	 jmp	 $word_differs$16
$LN9@lz_extend:
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000ae	83 c0 04	 add	 eax, 4
  000b1	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 149  : 			COMPARE_WORD_STEP

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _matchptr$[ebp]
  000b7	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  000c0	83 c4 04	 add	 esp, 4
  000c3	8b f0		 mov	 esi, eax
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _strptr$[ebp]
  000c8	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  000d1	83 c4 04	 add	 esp, 4
  000d4	33 f0		 xor	 esi, eax
  000d6	89 75 ec	 mov	 DWORD PTR _v_word$[ebp], esi
  000d9	74 05		 je	 SHORT $LN10@lz_extend
  000db	e9 a8 00 00 00	 jmp	 $word_differs$16
$LN10@lz_extend:
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000e3	83 c0 04	 add	 eax, 4
  000e6	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 150  : 			COMPARE_WORD_STEP

  000e9	8b 45 0c	 mov	 eax, DWORD PTR _matchptr$[ebp]
  000ec	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  000f5	83 c4 04	 add	 esp, 4
  000f8	8b f0		 mov	 esi, eax
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _strptr$[ebp]
  000fd	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00100	51		 push	 ecx
  00101	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  00106	83 c4 04	 add	 esp, 4
  00109	33 f0		 xor	 esi, eax
  0010b	89 75 ec	 mov	 DWORD PTR _v_word$[ebp], esi
  0010e	74 02		 je	 SHORT $LN11@lz_extend
  00110	eb 76		 jmp	 SHORT $word_differs$16
$LN11@lz_extend:
  00112	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00115	83 c0 04	 add	 eax, 4
  00118	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
$LN2@lz_extend:

; 151  : 		#undef COMPARE_WORD_STEP
; 152  : 		}
; 153  : 
; 154  : 		while (len + WORDBYTES <= max_len) {

  0011b	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0011e	83 c0 04	 add	 eax, 4
  00121	3b 45 14	 cmp	 eax, DWORD PTR _max_len$[ebp]
  00124	77 34		 ja	 SHORT $LN4@lz_extend

; 155  : 			v_word = load_word_unaligned(&matchptr[len]) ^

  00126	8b 45 0c	 mov	 eax, DWORD PTR _matchptr$[ebp]
  00129	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  00132	83 c4 04	 add	 esp, 4
  00135	8b f0		 mov	 esi, eax
  00137	8b 4d 08	 mov	 ecx, DWORD PTR _strptr$[ebp]
  0013a	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  0013d	51		 push	 ecx
  0013e	e8 00 00 00 00	 call	 _load_machine_word_t_unaligned
  00143	83 c4 04	 add	 esp, 4
  00146	33 f0		 xor	 esi, eax
  00148	89 75 ec	 mov	 DWORD PTR _v_word$[ebp], esi

; 156  : 				 load_word_unaligned(&strptr[len]);
; 157  : 			if (v_word != 0)

  0014b	74 02		 je	 SHORT $LN12@lz_extend

; 158  : 				goto word_differs;

  0014d	eb 39		 jmp	 SHORT $word_differs$16
$LN12@lz_extend:

; 159  : 			len += WORDBYTES;

  0014f	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00152	83 c0 04	 add	 eax, 4
  00155	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 160  : 		}

  00158	eb c1		 jmp	 SHORT $LN2@lz_extend
$LN4@lz_extend:

; 161  : 	}
; 162  : 
; 163  : 	while (len < max_len && matchptr[len] == strptr[len])

  0015a	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0015d	3b 45 14	 cmp	 eax, DWORD PTR _max_len$[ebp]
  00160	73 21		 jae	 SHORT $LN5@lz_extend
  00162	8b 45 0c	 mov	 eax, DWORD PTR _matchptr$[ebp]
  00165	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  00168	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0016b	8b 55 08	 mov	 edx, DWORD PTR _strptr$[ebp]
  0016e	03 55 f8	 add	 edx, DWORD PTR _len$[ebp]
  00171	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00174	3b c8		 cmp	 ecx, eax
  00176	75 0b		 jne	 SHORT $LN5@lz_extend

; 164  : 		len++;

  00178	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0017b	83 c0 01	 add	 eax, 1
  0017e	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
  00181	eb d7		 jmp	 SHORT $LN4@lz_extend
$LN5@lz_extend:

; 165  : 	return len;

  00183	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00186	eb 3f		 jmp	 SHORT $LN1@lz_extend
$word_differs$16:

; 166  : 
; 167  : word_differs:
; 168  : 	if (CPU_IS_LITTLE_ENDIAN())

  00188	b8 01 00 00 00	 mov	 eax, 1
  0018d	85 c0		 test	 eax, eax
  0018f	74 17		 je	 SHORT $LN13@lz_extend

; 169  : 		len += (bsfw(v_word) >> 3);

  00191	8b 45 ec	 mov	 eax, DWORD PTR _v_word$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _bsfw
  0019a	83 c4 04	 add	 esp, 4
  0019d	c1 e8 03	 shr	 eax, 3
  001a0	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  001a3	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
  001a6	eb 1c		 jmp	 SHORT $LN14@lz_extend
$LN13@lz_extend:

; 170  : 	else
; 171  : 		len += (WORDBITS - 1 - bsrw(v_word)) >> 3;

  001a8	8b 45 ec	 mov	 eax, DWORD PTR _v_word$[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _bsrw
  001b1	83 c4 04	 add	 esp, 4
  001b4	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  001b9	2b c8		 sub	 ecx, eax
  001bb	c1 e9 03	 shr	 ecx, 3
  001be	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  001c1	89 4d f8	 mov	 DWORD PTR _len$[ebp], ecx
$LN14@lz_extend:

; 172  : 	return len;

  001c4	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
$LN1@lz_extend:

; 173  : }

  001c7	5f		 pop	 edi
  001c8	5e		 pop	 esi
  001c9	5b		 pop	 ebx
  001ca	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  001d0	3b ec		 cmp	 ebp, esp
  001d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c3		 ret	 0
_lz_extend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\matchfinder_common.h
;	COMDAT _lz_hash
_TEXT	SEGMENT
_seq$ = 8						; size = 4
_num_bits$ = 12						; size = 4
_lz_hash PROC						; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09230FC3_matchfinder_common@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 122  : 	return (u32)(seq * 0x1E35A7BD) >> (32 - num_bits);

  00028	69 45 08 bd a7
	35 1e		 imul	 eax, DWORD PTR _seq$[ebp], 506832829
  0002f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00034	2b 4d 0c	 sub	 ecx, DWORD PTR _num_bits$[ebp]
  00037	d3 e8		 shr	 eax, cl

; 123  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_lz_hash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\matchfinder_common.h
;	COMDAT _matchfinder_rebase
_TEXT	SEGMENT
tv78 = -208						; size = 4
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_num_entries$ = 12					; size = 4
_matchfinder_rebase PROC				; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09230FC3_matchfinder_common@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 77   : 	size_t i;
; 78   : 
; 79   : 	if (arch_matchfinder_rebase(data, num_entries * sizeof(data[0])))

  00028	33 c0		 xor	 eax, eax
  0002a	74 05		 je	 SHORT $LN8@matchfinde

; 80   : 		return;

  0002c	e9 bd 00 00 00	 jmp	 $LN1@matchfinde
$LN8@matchfinde:

; 81   : 
; 82   : 	if (MATCHFINDER_WINDOW_SIZE == 32768) {

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	74 5f		 je	 SHORT $LN9@matchfinde

; 83   : 		/* Branchless version for 32768 byte windows.  If the value was
; 84   : 		 * already negative, clear all bits except the sign bit; this
; 85   : 		 * changes the value to -32768.  Otherwise, set the sign bit;
; 86   : 		 * this is equivalent to subtracting 32768.  */
; 87   : 		for (i = 0; i < num_entries; i++) {

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00041	eb 09		 jmp	 SHORT $LN4@matchfinde
$LN2@matchfinde:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00046	83 c0 01	 add	 eax, 1
  00049	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@matchfinde:
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004f	3b 45 0c	 cmp	 eax, DWORD PTR _num_entries$[ebp]
  00052	73 43		 jae	 SHORT $LN3@matchfinde

; 88   : 			
; 89   : 			///
; 90   : 			//u16 v = data[i];
; 91   : 			//u16 sign_bit = v & 0x8000;
; 92   : 			//v &= sign_bit - ((sign_bit >> 15) ^ 1);
; 93   : 			//v |= 0x8000;
; 94   : 			//data[i] = v;
; 95   : 			//////OPTIMIZE
; 96   : 
; 97   : 			data[i] = data[i] < 0 ? 0x8000 : data[i] | 0x8000;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0005a	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  0005e	85 d2		 test	 edx, edx
  00060	7d 0c		 jge	 SHORT $LN13@matchfinde
  00062	c7 85 30 ff ff
	ff 00 80 00 00	 mov	 DWORD PTR tv78[ebp], 32768 ; 00008000H
  0006c	eb 16		 jmp	 SHORT $LN14@matchfinde
$LN13@matchfinde:
  0006e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00074	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00078	81 ca 00 80 00
	00		 or	 edx, 32768		; 00008000H
  0007e	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], edx
$LN14@matchfinde:
  00084	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0008a	66 8b 95 30 ff
	ff ff		 mov	 dx, WORD PTR tv78[ebp]
  00091	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 98   : 
; 99   : 			///
; 100  : 		}

  00095	eb ac		 jmp	 SHORT $LN2@matchfinde
$LN3@matchfinde:

; 101  : 		return;

  00097	eb 55		 jmp	 SHORT $LN1@matchfinde
$LN9@matchfinde:

; 102  : 	}
; 103  : 
; 104  : 	for (i = 0; i < num_entries; i++) {

  00099	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a0	eb 09		 jmp	 SHORT $LN7@matchfinde
$LN5@matchfinde:
  000a2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a5	83 c0 01	 add	 eax, 1
  000a8	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@matchfinde:
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ae	3b 45 0c	 cmp	 eax, DWORD PTR _num_entries$[ebp]
  000b1	73 3b		 jae	 SHORT $LN1@matchfinde

; 105  : 		if (data[i] >= 0)

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000b9	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  000bd	85 d2		 test	 edx, edx
  000bf	7c 1c		 jl	 SHORT $LN10@matchfinde

; 106  : 			data[i] -= -((mf_pos_t)MATCHFINDER_WINDOW_SIZE);

  000c1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000c7	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  000cb	81 ea 00 80 00
	00		 sub	 edx, 32768		; 00008000H
  000d1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000d7	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  000db	eb 0f		 jmp	 SHORT $LN11@matchfinde
$LN10@matchfinde:

; 107  : 		else
; 108  : 			data[i] = -((mf_pos_t)MATCHFINDER_WINDOW_SIZE);

  000dd	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  000e2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000e5	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  000e8	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$LN11@matchfinde:

; 109  : 	}

  000ec	eb b4		 jmp	 SHORT $LN5@matchfinde
$LN1@matchfinde:

; 110  : }

  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx
  000f1	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000f7	3b ec		 cmp	 ebp, esp
  000f9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
_matchfinder_rebase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\matchfinder_common.h
;	COMDAT _matchfinder_init
_TEXT	SEGMENT
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_num_entries$ = 12					; size = 4
_matchfinder_init PROC					; COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09230FC3_matchfinder_common@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 44   : 	size_t i;
; 45   : 
; 46   : 	if (arch_matchfinder_init(data, num_entries * sizeof(data[0])))

  00028	33 c0		 xor	 eax, eax
  0002a	74 02		 je	 SHORT $LN5@matchfinde

; 47   : 		return;

  0002c	eb 2b		 jmp	 SHORT $LN1@matchfinde
$LN5@matchfinde:

; 48   : 
; 49   : 	for (i = 0; i < num_entries; i++)

  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00035	eb 09		 jmp	 SHORT $LN4@matchfinde
$LN2@matchfinde:
  00037	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	83 c0 01	 add	 eax, 1
  0003d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@matchfinde:
  00040	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00043	3b 45 0c	 cmp	 eax, DWORD PTR _num_entries$[ebp]
  00046	73 11		 jae	 SHORT $LN1@matchfinde

; 50   : 		data[i] = (int16_t)MATCHFINDER_INITVAL;

  00048	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00050	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00053	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00057	eb de		 jmp	 SHORT $LN2@matchfinde
$LN1@matchfinde:

; 51   : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_matchfinder_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _libdeflate_free_compressor@4
_TEXT	SEGMENT
_c$ = 8							; size = 4
_libdeflate_free_compressor@4 PROC			; COMDAT

; 2354 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2355 : 	aligned_free(c);

  00028	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 __libdeflate_aligned_free
  00031	83 c4 04	 add	 esp, 4

; 2356 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
_libdeflate_free_compressor@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _libdeflate_deflate_compress_bound@8
_TEXT	SEGMENT
tv71 = -208						; size = 4
_max_num_blocks$ = -8					; size = 4
_c$ = 8							; size = 4
_in_nbytes$ = 12					; size = 4
_libdeflate_deflate_compress_bound@8 PROC		; COMDAT

; 2367 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2368 : 	/*
; 2369 : 	 * The worst case is all uncompressed blocks where one block has length
; 2370 : 	 * <= MIN_BLOCK_LENGTH and the others have length MIN_BLOCK_LENGTH.
; 2371 : 	 * Each uncompressed block has 5 bytes of overhead: 1 for BFINAL, BTYPE,
; 2372 : 	 * and alignment to a byte boundary; 2 for LEN; and 2 for NLEN.
; 2373 : 	 */
; 2374 : 	size_t max_num_blocks = MAX(DIV_ROUND_UP(in_nbytes, MIN_BLOCK_LENGTH), 1);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _in_nbytes$[ebp]
  0002b	05 0f 27 00 00	 add	 eax, 9999		; 0000270fH
  00030	33 d2		 xor	 edx, edx
  00032	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00037	f7 f1		 div	 ecx
  00039	83 f8 01	 cmp	 eax, 1
  0003c	72 19		 jb	 SHORT $LN3@libdeflate
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _in_nbytes$[ebp]
  00041	05 0f 27 00 00	 add	 eax, 9999		; 0000270fH
  00046	33 d2		 xor	 edx, edx
  00048	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0004d	f7 f1		 div	 ecx
  0004f	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00055	eb 0a		 jmp	 SHORT $LN4@libdeflate
$LN3@libdeflate:
  00057	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
$LN4@libdeflate:
  00061	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  00067	89 55 f8	 mov	 DWORD PTR _max_num_blocks$[ebp], edx

; 2375 : 	return (5 * max_num_blocks) + in_nbytes + 1 + OUTPUT_END_PADDING;

  0006a	6b 45 f8 05	 imul	 eax, DWORD PTR _max_num_blocks$[ebp], 5
  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _in_nbytes$[ebp]
  00071	8d 44 08 09	 lea	 eax, DWORD PTR [eax+ecx+9]

; 2376 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_libdeflate_deflate_compress_bound@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _libdeflate_deflate_compress@20
_TEXT	SEGMENT
_os$1 = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_in$ = 12						; size = 4
_in_nbytes$ = 16					; size = 4
_out$ = 20						; size = 4
_out_nbytes_avail$ = 24					; size = 4
_libdeflate_deflate_compress@20 PROC			; COMDAT

; 2335 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2336 : 	if (unlikely(out_nbytes_avail < OUTPUT_END_PADDING))

  00032	83 7d 18 08	 cmp	 DWORD PTR _out_nbytes_avail$[ebp], 8
  00036	73 04		 jae	 SHORT $LN2@libdeflate

; 2337 : 		return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 72		 jmp	 SHORT $LN1@libdeflate
$LN2@libdeflate:

; 2338 : 
; 2339 : 	/* For extremely small inputs just use a single uncompressed block. */
; 2340 : 	if (unlikely(in_nbytes < 16)) {

  0003c	83 7d 10 10	 cmp	 DWORD PTR _in_nbytes$[ebp], 16 ; 00000010H
  00040	73 45		 jae	 SHORT $LN3@libdeflate

; 2341 : 		struct deflate_output_bitstream os;
; 2342 : 		deflate_init_output(&os, out, out_nbytes_avail);

  00042	8b 45 18	 mov	 eax, DWORD PTR _out_nbytes_avail$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  00049	51		 push	 ecx
  0004a	8d 55 e4	 lea	 edx, DWORD PTR _os$1[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _deflate_init_output
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2343 : 		if (in_nbytes == 0)

  00056	83 7d 10 00	 cmp	 DWORD PTR _in_nbytes$[ebp], 0
  0005a	75 06		 jne	 SHORT $LN4@libdeflate

; 2344 : 			in = &os; /* Avoid passing NULL to memcpy() */

  0005c	8d 45 e4	 lea	 eax, DWORD PTR _os$1[ebp]
  0005f	89 45 0c	 mov	 DWORD PTR _in$[ebp], eax
$LN4@libdeflate:

; 2345 : 		deflate_write_uncompressed_block(&os, in, in_nbytes, true);

  00062	6a 01		 push	 1
  00064	0f b7 45 10	 movzx	 eax, WORD PTR _in_nbytes$[ebp]
  00068	50		 push	 eax
  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  0006c	51		 push	 ecx
  0006d	8d 55 e4	 lea	 edx, DWORD PTR _os$1[ebp]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _deflate_write_uncompressed_block
  00076	83 c4 10	 add	 esp, 16			; 00000010H

; 2346 : 		return deflate_flush_output(&os);

  00079	8d 45 e4	 lea	 eax, DWORD PTR _os$1[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _deflate_flush_output
  00082	83 c4 04	 add	 esp, 4
  00085	eb 27		 jmp	 SHORT $LN1@libdeflate
$LN3@libdeflate:

; 2347 : 	}
; 2348 : 
; 2349 : 	return (*(c->impl))(c, in, in_nbytes, out, out_nbytes_avail);

  00087	8b f4		 mov	 esi, esp
  00089	8b 45 18	 mov	 eax, DWORD PTR _out_nbytes_avail$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 10	 mov	 edx, DWORD PTR _in_nbytes$[ebp]
  00094	52		 push	 edx
  00095	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  000a0	8b 02		 mov	 eax, DWORD PTR [edx]
  000a2	ff d0		 call	 eax
  000a4	83 c4 14	 add	 esp, 20			; 00000014H
  000a7	3b f4		 cmp	 esi, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@libdeflate:

; 2350 : }

  000ae	52		 push	 edx
  000af	8b cd		 mov	 ecx, ebp
  000b1	50		 push	 eax
  000b2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@libdeflate
  000b8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000bd	58		 pop	 eax
  000be	5a		 pop	 edx
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	33 cd		 xor	 ecx, ebp
  000c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cc	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 14 00	 ret	 20			; 00000014H
  000df	90		 npad	 1
$LN8@libdeflate:
  000e0	01 00 00 00	 DD	 1
  000e4	00 00 00 00	 DD	 $LN7@libdeflate
$LN7@libdeflate:
  000e8	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000ec	14 00 00 00	 DD	 20			; 00000014H
  000f0	00 00 00 00	 DD	 $LN6@libdeflate
$LN6@libdeflate:
  000f4	6f		 DB	 111			; 0000006fH
  000f5	73		 DB	 115			; 00000073H
  000f6	00		 DB	 0
_libdeflate_deflate_compress@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT _libdeflate_alloc_compressor@4
_TEXT	SEGMENT
tv68 = -220						; size = 4
_size$ = -20						; size = 4
_c$ = -8						; size = 4
_compression_level$ = 8					; size = 4
_libdeflate_alloc_compressor@4 PROC			; COMDAT

; 2224 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2225 : 	struct libdeflate_compressor *c;
; 2226 : 	size_t size;
; 2227 : 
; 2228 : #if SUPPORT_NEAR_OPTIMAL_PARSING
; 2229 : 	if (compression_level >= 8)
; 2230 : 		size = offsetof(struct libdeflate_compressor, p) + sizeof(c->p.n);
; 2231 : 	else
; 2232 : #endif
; 2233 : 		size = offsetof(struct libdeflate_compressor, p) + sizeof(c->p.g);

  00028	c7 45 ec ac 4e
	10 00		 mov	 DWORD PTR _size$[ebp], 1068716 ; 00104eacH

; 2234 : 
; 2235 : 	c = aligned_malloc(MATCHFINDER_ALIGNMENT, size);

  0002f	8b 45 ec	 mov	 eax, DWORD PTR _size$[ebp]
  00032	50		 push	 eax
  00033	6a 08		 push	 8
  00035	e8 00 00 00 00	 call	 __libdeflate_aligned_malloc
  0003a	83 c4 08	 add	 esp, 8
  0003d	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 2236 : 	if (!c)

  00040	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  00044	75 07		 jne	 SHORT $LN4@libdeflate

; 2237 : 		return NULL;

  00046	33 c0		 xor	 eax, eax
  00048	e9 c5 01 00 00	 jmp	 $LN1@libdeflate
$LN4@libdeflate:

; 2238 : 
; 2239 : 	switch (compression_level) {

  0004d	8b 45 08	 mov	 eax, DWORD PTR _compression_level$[ebp]
  00050	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  00056	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv68[ebp]
  0005c	83 e9 01	 sub	 ecx, 1
  0005f	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], ecx
  00065	83 bd 24 ff ff
	ff 08		 cmp	 DWORD PTR tv68[ebp], 8
  0006c	0f 87 69 01 00
	00		 ja	 $LN14@libdeflate
  00072	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv68[ebp]
  00078	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN16@libdeflate[edx*4]
$LN5@libdeflate:

; 2240 : 	case 1:
; 2241 : 		c->impl = deflate_compress_greedy;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00082	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_greedy

; 2242 : 		c->max_search_depth = 2;

  00088	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0008b	c7 80 e0 13 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+5088], 2

; 2243 : 		c->nice_match_length = 8;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00098	c7 80 dc 13 00
	00 08 00 00 00	 mov	 DWORD PTR [eax+5084], 8

; 2244 : 		break;

  000a2	e9 44 01 00 00	 jmp	 $LN2@libdeflate
$LN6@libdeflate:

; 2245 : 	case 2:
; 2246 : 		c->impl = deflate_compress_greedy;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000aa	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_greedy

; 2247 : 		c->max_search_depth = 6;

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000b3	c7 80 e0 13 00
	00 06 00 00 00	 mov	 DWORD PTR [eax+5088], 6

; 2248 : 		c->nice_match_length = 10;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000c0	c7 80 dc 13 00
	00 0a 00 00 00	 mov	 DWORD PTR [eax+5084], 10 ; 0000000aH

; 2249 : 		break;

  000ca	e9 1c 01 00 00	 jmp	 $LN2@libdeflate
$LN7@libdeflate:

; 2250 : 	case 3:
; 2251 : 		c->impl = deflate_compress_greedy;

  000cf	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000d2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_greedy

; 2252 : 		c->max_search_depth = 12;

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000db	c7 80 e0 13 00
	00 0c 00 00 00	 mov	 DWORD PTR [eax+5088], 12 ; 0000000cH

; 2253 : 		c->nice_match_length = 14;

  000e5	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000e8	c7 80 dc 13 00
	00 0e 00 00 00	 mov	 DWORD PTR [eax+5084], 14 ; 0000000eH

; 2254 : 		break;

  000f2	e9 f4 00 00 00	 jmp	 $LN2@libdeflate
$LN8@libdeflate:

; 2255 : 	case 4:
; 2256 : 		c->impl = deflate_compress_greedy;

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000fa	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_greedy

; 2257 : 		c->max_search_depth = 24;

  00100	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00103	c7 80 e0 13 00
	00 18 00 00 00	 mov	 DWORD PTR [eax+5088], 24 ; 00000018H

; 2258 : 		c->nice_match_length = 24;

  0010d	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00110	c7 80 dc 13 00
	00 18 00 00 00	 mov	 DWORD PTR [eax+5084], 24 ; 00000018H

; 2259 : 		break;

  0011a	e9 cc 00 00 00	 jmp	 $LN2@libdeflate
$LN9@libdeflate:

; 2260 : 	case 5:
; 2261 : 		c->impl = deflate_compress_lazy;

  0011f	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00122	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_lazy

; 2262 : 		c->max_search_depth = 20;

  00128	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0012b	c7 80 e0 13 00
	00 14 00 00 00	 mov	 DWORD PTR [eax+5088], 20 ; 00000014H

; 2263 : 		c->nice_match_length = 30;

  00135	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00138	c7 80 dc 13 00
	00 1e 00 00 00	 mov	 DWORD PTR [eax+5084], 30 ; 0000001eH

; 2264 : 		break;

  00142	e9 a4 00 00 00	 jmp	 $LN2@libdeflate
$LN10@libdeflate:

; 2265 : 	case 6:
; 2266 : 		c->impl = deflate_compress_lazy;

  00147	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0014a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_lazy

; 2267 : 		c->max_search_depth = 40;

  00150	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00153	c7 80 e0 13 00
	00 28 00 00 00	 mov	 DWORD PTR [eax+5088], 40 ; 00000028H

; 2268 : 		c->nice_match_length = 65;

  0015d	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00160	c7 80 dc 13 00
	00 41 00 00 00	 mov	 DWORD PTR [eax+5084], 65 ; 00000041H

; 2269 : 		break;

  0016a	eb 7f		 jmp	 SHORT $LN2@libdeflate
$LN11@libdeflate:

; 2270 : 	case 7:
; 2271 : 		c->impl = deflate_compress_lazy;

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0016f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_lazy

; 2272 : 		c->max_search_depth = 100;

  00175	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00178	c7 80 e0 13 00
	00 64 00 00 00	 mov	 DWORD PTR [eax+5088], 100 ; 00000064H

; 2273 : 		c->nice_match_length = 130;

  00182	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00185	c7 80 dc 13 00
	00 82 00 00 00	 mov	 DWORD PTR [eax+5084], 130 ; 00000082H

; 2274 : 		break;

  0018f	eb 5a		 jmp	 SHORT $LN2@libdeflate
$LN12@libdeflate:

; 2275 : #if SUPPORT_NEAR_OPTIMAL_PARSING
; 2276 : 	case 8:
; 2277 : 		c->impl = deflate_compress_near_optimal;
; 2278 : 		c->max_search_depth = 12;
; 2279 : 		c->nice_match_length = 20;
; 2280 : 		c->p.n.num_optim_passes = 1;
; 2281 : 		break;
; 2282 : 	case 9:
; 2283 : 		c->impl = deflate_compress_near_optimal;
; 2284 : 		c->max_search_depth = 16;
; 2285 : 		c->nice_match_length = 26;
; 2286 : 		c->p.n.num_optim_passes = 2;
; 2287 : 		break;
; 2288 : 	case 10:
; 2289 : 		c->impl = deflate_compress_near_optimal;
; 2290 : 		c->max_search_depth = 30;
; 2291 : 		c->nice_match_length = 50;
; 2292 : 		c->p.n.num_optim_passes = 2;
; 2293 : 		break;
; 2294 : 	case 11:
; 2295 : 		c->impl = deflate_compress_near_optimal;
; 2296 : 		c->max_search_depth = 60;
; 2297 : 		c->nice_match_length = 80;
; 2298 : 		c->p.n.num_optim_passes = 3;
; 2299 : 		break;
; 2300 : 	case 12:
; 2301 : 		c->impl = deflate_compress_near_optimal;
; 2302 : 		c->max_search_depth = 100;
; 2303 : 		c->nice_match_length = 133;
; 2304 : 		c->p.n.num_optim_passes = 4;
; 2305 : 		break;
; 2306 : #else
; 2307 : 	case 8:
; 2308 : 		c->impl = deflate_compress_lazy;

  00191	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00194	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_lazy

; 2309 : 		c->max_search_depth = 150;

  0019a	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0019d	c7 80 e0 13 00
	00 96 00 00 00	 mov	 DWORD PTR [eax+5088], 150 ; 00000096H

; 2310 : 		c->nice_match_length = 200;

  001a7	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001aa	c7 80 dc 13 00
	00 c8 00 00 00	 mov	 DWORD PTR [eax+5084], 200 ; 000000c8H

; 2311 : 		break;

  001b4	eb 35		 jmp	 SHORT $LN2@libdeflate
$LN13@libdeflate:

; 2312 : 	case 9:
; 2313 : 		c->impl = deflate_compress_lazy;

  001b6	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001b9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _deflate_compress_lazy

; 2314 : 		c->max_search_depth = 200;

  001bf	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001c2	c7 80 e0 13 00
	00 c8 00 00 00	 mov	 DWORD PTR [eax+5088], 200 ; 000000c8H

; 2315 : 		c->nice_match_length = DEFLATE_MAX_MATCH_LEN;

  001cc	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001cf	c7 80 dc 13 00
	00 02 01 00 00	 mov	 DWORD PTR [eax+5084], 258 ; 00000102H

; 2316 : 		break;

  001d9	eb 10		 jmp	 SHORT $LN2@libdeflate
$LN14@libdeflate:

; 2317 : #endif
; 2318 : 	default:
; 2319 : 		aligned_free(c);

  001db	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 __libdeflate_aligned_free
  001e4	83 c4 04	 add	 esp, 4

; 2320 : 		return NULL;

  001e7	33 c0		 xor	 eax, eax
  001e9	eb 27		 jmp	 SHORT $LN1@libdeflate
$LN2@libdeflate:

; 2321 : 	}
; 2322 : 
; 2323 : 	c->compression_level = compression_level;

  001eb	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001ee	8b 4d 08	 mov	 ecx, DWORD PTR _compression_level$[ebp]
  001f1	89 88 e4 13 00
	00		 mov	 DWORD PTR [eax+5092], ecx

; 2324 : 
; 2325 : 	deflate_init_offset_slot_fast(c);

  001f7	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 _deflate_init_offset_slot_fast
  00200	83 c4 04	 add	 esp, 4

; 2326 : 	deflate_init_static_codes(c);

  00203	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 _deflate_init_static_codes
  0020c	83 c4 04	 add	 esp, 4

; 2327 : 
; 2328 : 	return c;

  0020f	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
$LN1@libdeflate:

; 2329 : }

  00212	5f		 pop	 edi
  00213	5e		 pop	 esi
  00214	5b		 pop	 ebx
  00215	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0021b	3b ec		 cmp	 ebp, esp
  0021d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c2 04 00	 ret	 4
$LN16@libdeflate:
  00228	00 00 00 00	 DD	 $LN5@libdeflate
  0022c	00 00 00 00	 DD	 $LN6@libdeflate
  00230	00 00 00 00	 DD	 $LN7@libdeflate
  00234	00 00 00 00	 DD	 $LN8@libdeflate
  00238	00 00 00 00	 DD	 $LN9@libdeflate
  0023c	00 00 00 00	 DD	 $LN10@libdeflate
  00240	00 00 00 00	 DD	 $LN11@libdeflate
  00244	00 00 00 00	 DD	 $LN12@libdeflate
  00248	00 00 00 00	 DD	 $LN13@libdeflate
_libdeflate_alloc_compressor@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _load_u24_unaligned
_TEXT	SEGMENT
_p$ = 8							; size = 4
_load_u24_unaligned PROC				; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 190  : #if UNALIGNED_ACCESS_IS_FAST
; 191  : #  define LOAD_U24_REQUIRED_NBYTES 4
; 192  : 	return loaded_u32_to_u24(load_u32_unaligned(p));

  00028	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _load_u32_unaligned
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _loaded_u32_to_u24
  0003a	83 c4 04	 add	 esp, 4

; 193  : #else
; 194  : #  define LOAD_U24_REQUIRED_NBYTES 3
; 195  : 	if (CPU_IS_LITTLE_ENDIAN())
; 196  : 		return ((u32)p[0] << 0) | ((u32)p[1] << 8) | ((u32)p[2] << 16);
; 197  : 	else
; 198  : 		return ((u32)p[2] << 0) | ((u32)p[1] << 8) | ((u32)p[0] << 16);
; 199  : #endif
; 200  : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_load_u24_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _loaded_u32_to_u24
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loaded_u32_to_u24 PROC					; COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 175  : 	if (CPU_IS_LITTLE_ENDIAN())

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 0c		 je	 SHORT $LN2@loaded_u32

; 176  : 		return v & 0xFFFFFF;

  00031	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00034	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00039	eb 08		 jmp	 SHORT $LN1@loaded_u32
  0003b	eb 06		 jmp	 SHORT $LN1@loaded_u32
$LN2@loaded_u32:

; 177  : 	else
; 178  : 		return v >> 8;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00040	c1 e8 08	 shr	 eax, 8
$LN1@loaded_u32:

; 179  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_loaded_u32_to_u24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _put_unaligned_leword
_TEXT	SEGMENT
_v$ = 8							; size = 4
_p$ = 12						; size = 4
_put_unaligned_leword PROC				; COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 157  : 	STATIC_ASSERT(WORDBITS == 32 || WORDBITS == 64);
; 158  : 	if (WORDBITS == 32)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 12		 je	 SHORT $LN2@put_unalig

; 159  : 		put_unaligned_le32(v, p);

  00031	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _put_unaligned_le32
  0003e	83 c4 08	 add	 esp, 8
  00041	eb 13		 jmp	 SHORT $LN1@put_unalig
$LN2@put_unalig:

; 160  : 	else
; 161  : 		put_unaligned_le64(v, p);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0004a	33 d2		 xor	 edx, edx
  0004c	52		 push	 edx
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _put_unaligned_le64
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@put_unalig:

; 162  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_put_unaligned_leword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _put_unaligned_le64
_TEXT	SEGMENT
_v$ = 8							; size = 8
_p$ = 16						; size = 4
_put_unaligned_le64 PROC				; COMDAT

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  : 	if (UNALIGNED_ACCESS_IS_FAST) {

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 19		 je	 SHORT $LN2@put_unalig

; 141  : 		store_u64_unaligned(le64_bswap(v), p);

  00031	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp+4]
  00038	51		 push	 ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _store_u64_unaligned
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 142  : 	} else {

  00045	e9 cd 00 00 00	 jmp	 $LN1@put_unalig
$LN2@put_unalig:

; 143  : 		p[0] = (u8)(v >> 0);

  0004a	8a 45 08	 mov	 al, BYTE PTR _v$[ebp]
  0004d	b9 01 00 00 00	 mov	 ecx, 1
  00052	6b d1 00	 imul	 edx, ecx, 0
  00055	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  00058	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 144  : 		p[1] = (u8)(v >> 8);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp+4]
  00061	b1 08		 mov	 cl, 8
  00063	e8 00 00 00 00	 call	 __aullshr
  00068	b9 01 00 00 00	 mov	 ecx, 1
  0006d	c1 e1 00	 shl	 ecx, 0
  00070	8b 55 10	 mov	 edx, DWORD PTR _p$[ebp]
  00073	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 145  : 		p[2] = (u8)(v >> 16);

  00076	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00079	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp+4]
  0007c	b1 10		 mov	 cl, 16			; 00000010H
  0007e	e8 00 00 00 00	 call	 __aullshr
  00083	b9 01 00 00 00	 mov	 ecx, 1
  00088	d1 e1		 shl	 ecx, 1
  0008a	8b 55 10	 mov	 edx, DWORD PTR _p$[ebp]
  0008d	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 146  : 		p[3] = (u8)(v >> 24);

  00090	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00093	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp+4]
  00096	b1 18		 mov	 cl, 24			; 00000018H
  00098	e8 00 00 00 00	 call	 __aullshr
  0009d	b9 01 00 00 00	 mov	 ecx, 1
  000a2	6b d1 03	 imul	 edx, ecx, 3
  000a5	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  000a8	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 147  : 		p[4] = (u8)(v >> 32);

  000ab	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000ae	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp+4]
  000b1	b1 20		 mov	 cl, 32			; 00000020H
  000b3	e8 00 00 00 00	 call	 __aullshr
  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	c1 e1 02	 shl	 ecx, 2
  000c0	8b 55 10	 mov	 edx, DWORD PTR _p$[ebp]
  000c3	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 148  : 		p[5] = (u8)(v >> 40);

  000c6	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000c9	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp+4]
  000cc	b1 28		 mov	 cl, 40			; 00000028H
  000ce	e8 00 00 00 00	 call	 __aullshr
  000d3	b9 01 00 00 00	 mov	 ecx, 1
  000d8	6b d1 05	 imul	 edx, ecx, 5
  000db	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  000de	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 149  : 		p[6] = (u8)(v >> 48);

  000e1	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000e4	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp+4]
  000e7	b1 30		 mov	 cl, 48			; 00000030H
  000e9	e8 00 00 00 00	 call	 __aullshr
  000ee	b9 01 00 00 00	 mov	 ecx, 1
  000f3	6b d1 06	 imul	 edx, ecx, 6
  000f6	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  000f9	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 150  : 		p[7] = (u8)(v >> 56);

  000fc	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000ff	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp+4]
  00102	b1 38		 mov	 cl, 56			; 00000038H
  00104	e8 00 00 00 00	 call	 __aullshr
  00109	b9 01 00 00 00	 mov	 ecx, 1
  0010e	6b d1 07	 imul	 edx, ecx, 7
  00111	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  00114	88 04 11	 mov	 BYTE PTR [ecx+edx], al
$LN1@put_unalig:

; 151  : 	}
; 152  : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00120	3b ec		 cmp	 ebp, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
_put_unaligned_le64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _put_unaligned_le32
_TEXT	SEGMENT
_v$ = 8							; size = 4
_p$ = 12						; size = 4
_put_unaligned_le32 PROC				; COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 114  : 	if (UNALIGNED_ACCESS_IS_FAST) {

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 12		 je	 SHORT $LN2@put_unalig

; 115  : 		store_u32_unaligned(le32_bswap(v), p);

  00031	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _store_u32_unaligned
  0003e	83 c4 08	 add	 esp, 8

; 116  : 	} else {

  00041	eb 4c		 jmp	 SHORT $LN1@put_unalig
$LN2@put_unalig:

; 117  : 		p[0] = (u8)(v >> 0);

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	6b c8 00	 imul	 ecx, eax, 0
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0004e	8a 45 08	 mov	 al, BYTE PTR _v$[ebp]
  00051	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 118  : 		p[1] = (u8)(v >> 8);

  00054	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00057	c1 e8 08	 shr	 eax, 8
  0005a	b9 01 00 00 00	 mov	 ecx, 1
  0005f	c1 e1 00	 shl	 ecx, 0
  00062	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00065	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 119  : 		p[2] = (u8)(v >> 16);

  00068	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0006b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0006e	b9 01 00 00 00	 mov	 ecx, 1
  00073	d1 e1		 shl	 ecx, 1
  00075	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00078	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 120  : 		p[3] = (u8)(v >> 24);

  0007b	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0007e	c1 e8 18	 shr	 eax, 24			; 00000018H
  00081	b9 01 00 00 00	 mov	 ecx, 1
  00086	6b d1 03	 imul	 edx, ecx, 3
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  0008c	88 04 11	 mov	 BYTE PTR [ecx+edx], al
$LN1@put_unalig:

; 121  : 	}
; 122  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
_put_unaligned_le32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _put_unaligned_le16
_TEXT	SEGMENT
_v$ = 8							; size = 2
_p$ = 12						; size = 4
_put_unaligned_le16 PROC				; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 92   : 	if (UNALIGNED_ACCESS_IS_FAST) {

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@put_unalig

; 93   : 		store_u16_unaligned(le16_bswap(v), p);

  00031	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	0f b7 4d 08	 movzx	 ecx, WORD PTR _v$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _store_u16_unaligned
  0003f	83 c4 08	 add	 esp, 8

; 94   : 	} else {

  00042	eb 26		 jmp	 SHORT $LN1@put_unalig
$LN2@put_unalig:

; 95   : 		p[0] = (u8)(v >> 0);

  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	6b c8 00	 imul	 ecx, eax, 0
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0004f	8a 45 08	 mov	 al, BYTE PTR _v$[ebp]
  00052	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 96   : 		p[1] = (u8)(v >> 8);

  00055	0f b7 45 08	 movzx	 eax, WORD PTR _v$[ebp]
  00059	c1 f8 08	 sar	 eax, 8
  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	c1 e1 00	 shl	 ecx, 0
  00064	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00067	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$LN1@put_unalig:

; 97   : 	}
; 98   : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_put_unaligned_le16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _get_unaligned_le32
_TEXT	SEGMENT
_p$ = 8							; size = 4
_get_unaligned_le32 PROC				; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 48   : 	if (UNALIGNED_ACCESS_IS_FAST)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 10		 je	 SHORT $LN2@get_unalig

; 49   : 		return le32_bswap(load_u32_unaligned(p));

  00031	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _load_u32_unaligned
  0003a	83 c4 04	 add	 esp, 4
  0003d	eb 4c		 jmp	 SHORT $LN1@get_unalig
  0003f	eb 4a		 jmp	 SHORT $LN1@get_unalig
$LN2@get_unalig:

; 50   : 	else
; 51   : 		return ((u32)p[3] << 24) | ((u32)p[2] << 16) |

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 03	 imul	 ecx, eax, 3
  00049	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0004c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00050	c1 e0 18	 shl	 eax, 24			; 00000018H
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	d1 e1		 shl	 ecx, 1
  0005a	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0005d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00061	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00064	0b c1		 or	 eax, ecx
  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	c1 e2 00	 shl	 edx, 0
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00071	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00075	c1 e2 08	 shl	 edx, 8
  00078	0b c2		 or	 eax, edx
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	6b d1 00	 imul	 edx, ecx, 0
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00085	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00089	0b c2		 or	 eax, edx
$LN1@get_unalig:

; 52   : 			((u32)p[1] << 8) | p[0];
; 53   : }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_get_unaligned_le32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _load_machine_word_t_unaligned
_TEXT	SEGMENT
_v$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_load_machine_word_t_unaligned PROC			; COMDAT

; 20   : DEFINE_UNALIGNED_TYPE(machine_word_t)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	6a 04		 push	 4
  00034	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00037	50		 push	 eax
  00038	8d 4d f4	 lea	 ecx, DWORD PTR _v$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _memcpy
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  00047	52		 push	 edx
  00048	8b cd		 mov	 ecx, ebp
  0004a	50		 push	 eax
  0004b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@load_machi
  00051	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00056	58		 pop	 eax
  00057	5a		 pop	 edx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	33 cd		 xor	 ecx, ebp
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
  00076	66 90		 npad	 2
$LN5@load_machi:
  00078	01 00 00 00	 DD	 1
  0007c	00 00 00 00	 DD	 $LN4@load_machi
$LN4@load_machi:
  00080	f4 ff ff ff	 DD	 -12			; fffffff4H
  00084	04 00 00 00	 DD	 4
  00088	00 00 00 00	 DD	 $LN3@load_machi
$LN3@load_machi:
  0008c	76		 DB	 118			; 00000076H
  0008d	00		 DB	 0
_load_machine_word_t_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _store_u64_unaligned
_TEXT	SEGMENT
_v$ = 8							; size = 8
_p$ = 16						; size = 4
_store_u64_unaligned PROC				; COMDAT

; 19   : DEFINE_UNALIGNED_TYPE(u64)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	6a 08		 push	 8
  0002a	8d 45 08	 lea	 eax, DWORD PTR _v$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_store_u64_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _store_u32_unaligned
_TEXT	SEGMENT
_v$ = 8							; size = 4
_p$ = 12						; size = 4
_store_u32_unaligned PROC				; COMDAT

; 18   : DEFINE_UNALIGNED_TYPE(u32)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	6a 04		 push	 4
  0002a	8d 45 08	 lea	 eax, DWORD PTR _v$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_store_u32_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _load_u32_unaligned
_TEXT	SEGMENT
_v$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_load_u32_unaligned PROC				; COMDAT

; 18   : DEFINE_UNALIGNED_TYPE(u32)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	6a 04		 push	 4
  00034	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00037	50		 push	 eax
  00038	8d 4d f4	 lea	 ecx, DWORD PTR _v$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _memcpy
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  00047	52		 push	 edx
  00048	8b cd		 mov	 ecx, ebp
  0004a	50		 push	 eax
  0004b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@load_u32_u
  00051	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00056	58		 pop	 eax
  00057	5a		 pop	 edx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	33 cd		 xor	 ecx, ebp
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
  00076	66 90		 npad	 2
$LN5@load_u32_u:
  00078	01 00 00 00	 DD	 1
  0007c	00 00 00 00	 DD	 $LN4@load_u32_u
$LN4@load_u32_u:
  00080	f4 ff ff ff	 DD	 -12			; fffffff4H
  00084	04 00 00 00	 DD	 4
  00088	00 00 00 00	 DD	 $LN3@load_u32_u
$LN3@load_u32_u:
  0008c	76		 DB	 118			; 00000076H
  0008d	00		 DB	 0
_load_u32_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _store_u16_unaligned
_TEXT	SEGMENT
_v$ = 8							; size = 2
_p$ = 12						; size = 4
_store_u16_unaligned PROC				; COMDAT

; 17   : DEFINE_UNALIGNED_TYPE(u16)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	6a 02		 push	 2
  0002a	8d 45 08	 lea	 eax, DWORD PTR _v$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_store_u16_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\deflate_compress.c
;	COMDAT __libdeflate_deflate_get_compression_level
_TEXT	SEGMENT
_c$ = 8							; size = 4
__libdeflate_deflate_get_compression_level PROC		; COMDAT

; 2360 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C4EAA8D_deflate_compress@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2361 : 	return c->compression_level;

  00028	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0002b	8b 80 e4 13 00
	00		 mov	 eax, DWORD PTR [eax+5092]

; 2362 : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
__libdeflate_deflate_get_compression_level ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\common_defs.h
;	COMDAT _bsfw
_TEXT	SEGMENT
_n$ = 8							; size = 4
_bsfw	PROC						; COMDAT

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7CC618A3_common_defs@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 359  : 	STATIC_ASSERT(WORDBITS == 32 || WORDBITS == 64);
; 360  : 	if (WORDBITS == 32)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 10		 je	 SHORT $LN2@bsfw

; 361  : 		return bsf32(n);

  00031	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _bsf32
  0003a	83 c4 04	 add	 esp, 4
  0003d	eb 11		 jmp	 SHORT $LN1@bsfw
  0003f	eb 0f		 jmp	 SHORT $LN1@bsfw
$LN2@bsfw:

; 362  : 	else
; 363  : 		return bsf64(n);

  00041	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00044	33 c9		 xor	 ecx, ecx
  00046	51		 push	 ecx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _bsf64
  0004d	83 c4 08	 add	 esp, 8
$LN1@bsfw:

; 364  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_bsfw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\common_defs.h
;	COMDAT _bsf64
_TEXT	SEGMENT
tv73 = -212						; size = 8
_i$ = -8						; size = 4
_n$ = 8							; size = 8
_bsf64	PROC						; COMDAT

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7CC618A3_common_defs@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 347  : 	unsigned i = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@bsf64:

; 348  : 	while ((n & 1) == 0) {

  0002f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00032	83 e0 01	 and	 eax, 1
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp+4]
  00038	83 e1 00	 and	 ecx, 0
  0003b	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  00041	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp+4], ecx
  00047	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  0004d	0b 95 30 ff ff
	ff		 or	 edx, DWORD PTR tv73[ebp+4]
  00053	75 1e		 jne	 SHORT $LN3@bsf64

; 349  : 		i++;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 350  : 		n >>= 1;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00061	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp+4]
  00064	b1 01		 mov	 cl, 1
  00066	e8 00 00 00 00	 call	 __aullshr
  0006b	89 45 08	 mov	 DWORD PTR _n$[ebp], eax
  0006e	89 55 0c	 mov	 DWORD PTR _n$[ebp+4], edx

; 351  : 	}

  00071	eb bc		 jmp	 SHORT $LN2@bsf64
$LN3@bsf64:

; 352  : 	return i;

  00073	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 353  : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_bsf64	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\common_defs.h
;	COMDAT _bsrw
_TEXT	SEGMENT
_n$ = 8							; size = 4
_bsrw	PROC						; COMDAT

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7CC618A3_common_defs@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 317  : 	STATIC_ASSERT(WORDBITS == 32 || WORDBITS == 64);
; 318  : 	if (WORDBITS == 32)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 10		 je	 SHORT $LN2@bsrw

; 319  : 		return bsr32(n);

  00031	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _bsr32
  0003a	83 c4 04	 add	 esp, 4
  0003d	eb 11		 jmp	 SHORT $LN1@bsrw
  0003f	eb 0f		 jmp	 SHORT $LN1@bsrw
$LN2@bsrw:

; 320  : 	else
; 321  : 		return bsr64(n);

  00041	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00044	33 c9		 xor	 ecx, ecx
  00046	51		 push	 ecx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _bsr64
  0004d	83 c4 08	 add	 esp, 8
$LN1@bsrw:

; 322  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_bsrw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\common_defs.h
;	COMDAT _bsr64
_TEXT	SEGMENT
_i$ = -8						; size = 4
_n$ = 8							; size = 8
_bsr64	PROC						; COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7CC618A3_common_defs@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 307  : 	unsigned i = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@bsr64:

; 308  : 	while ((n >>= 1) != 0)

  0002f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00032	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp+4]
  00035	b1 01		 mov	 cl, 1
  00037	e8 00 00 00 00	 call	 __aullshr
  0003c	89 45 08	 mov	 DWORD PTR _n$[ebp], eax
  0003f	89 55 0c	 mov	 DWORD PTR _n$[ebp+4], edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00045	0b 45 0c	 or	 eax, DWORD PTR _n$[ebp+4]
  00048	74 0b		 je	 SHORT $LN3@bsr64

; 309  : 		i++;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004d	83 c0 01	 add	 eax, 1
  00050	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00053	eb da		 jmp	 SHORT $LN2@bsr64
$LN3@bsr64:

; 310  : 	return i;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 311  : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_bsr64	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\compiler_msc.h
;	COMDAT _bsf32
_TEXT	SEGMENT
_n$ = 8							; size = 4
_bsf32	PROC						; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __561309A6_compiler_msc@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 73   : 	_BitScanForward(&n, n);

  00028	0f bc 45 08	 bsf	 eax, DWORD PTR _n$[ebp]
  0002c	89 45 08	 mov	 DWORD PTR _n$[ebp], eax

; 74   : 	return n;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]

; 75   : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_bsf32	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\compiler_msc.h
;	COMDAT _bsr32
_TEXT	SEGMENT
_n$ = 8							; size = 4
_bsr32	PROC						; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __561309A6_compiler_msc@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 65   : 	_BitScanReverse(&n, n);

  00028	0f bd 45 08	 bsr	 eax, DWORD PTR _n$[ebp]
  0002c	89 45 08	 mov	 DWORD PTR _n$[ebp], eax

; 66   : 	return n;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]

; 67   : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_bsr32	ENDP
_TEXT	ENDS
END
