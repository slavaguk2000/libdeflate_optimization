; Listing generated by Microsoft (R) Optimizing Compiler Version 19.25.28612.0 

	TITLE	C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__367CC694_corecrt_memcpy_s@h DB 01H
__DC9673E3_corecrt_wstring@h DB 01H
__A29A7DFB_string@h DB 01H
__7242C389_ctype@h DB 01H
__90A1F774_basetsd@h DB 01H
__AF541008_winnt@h DB 01H
__0D001789_processthreadsapi@h DB 01H
__F972325D_memoryapi@h DB 01H
__76CD430D_winerror@h DB 01H
__737D49DB_winbase@h DB 01H
__376EBCA0_winioctl@h DB 01H
__0396F1A5_stralign@h DB 01H
__561309A6_compiler_msc@h DB 01H
__7CC618A3_common_defs@h DB 01H
__7DFAB971_unaligned@h DB 01H
__E33D8984_compressor@c DB 01H
msvcjmc	ENDS
PUBLIC	_compress_slava
PUBLIC	_deflate_add_bits_slava
PUBLIC	__JustMyCode_Default
EXTRN	_memcpy:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _deflate_write_uncompressed_block_slava
_TEXT	SEGMENT
_os$ = 8						; size = 4
_data$ = 12						; size = 4
_len$ = 16						; size = 2
_is_final_block$ = 20					; size = 4
_deflate_write_uncompressed_block_slava PROC		; COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 157  : 	
; 158  : 	deflate_write_block_header_slava(os, is_final_block,

  00028	6a 00		 push	 0
  0002a	8b 45 14	 mov	 eax, DWORD PTR _is_final_block$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _deflate_write_block_header_slava
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 		DEFLATE_BLOCKTYPE_UNCOMPRESSED);
; 160  : 	deflate_align_bitstream_slava(os);

  0003a	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _deflate_align_bitstream_slava
  00043	83 c4 04	 add	 esp, 4

; 161  : 
; 162  : 	if (4 + (u32)len >= os->end - os->next) {

  00046	0f b7 45 10	 movzx	 eax, WORD PTR _len$[ebp]
  0004a	83 c0 04	 add	 eax, 4
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00050	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00053	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00056	2b 4a 0c	 sub	 ecx, DWORD PTR [edx+12]
  00059	3b c1		 cmp	 eax, ecx
  0005b	72 0e		 jb	 SHORT $LN2@deflate_wr

; 163  : 		os->next = os->end;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00063	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00066	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 164  : 		return;

  00069	eb 70		 jmp	 SHORT $LN1@deflate_wr
$LN2@deflate_wr:

; 165  : 	}
; 166  : 
; 167  : 	put_unaligned_le16(len, os->next);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0006e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00071	51		 push	 ecx
  00072	0f b7 55 10	 movzx	 edx, WORD PTR _len$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _put_unaligned_le16
  0007c	83 c4 08	 add	 esp, 8

; 168  : 	os->next += 2;

  0007f	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00082	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00085	83 c1 02	 add	 ecx, 2
  00088	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0008b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 169  : 	put_unaligned_le16(~len, os->next);

  0008e	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00091	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00094	51		 push	 ecx
  00095	0f b7 55 10	 movzx	 edx, WORD PTR _len$[ebp]
  00099	f7 d2		 not	 edx
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 _put_unaligned_le16
  000a1	83 c4 08	 add	 esp, 8

; 170  : 	os->next += 2;

  000a4	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000a7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000aa	83 c1 02	 add	 ecx, 2
  000ad	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000b0	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 171  : 	memcpy(os->next, data, len);

  000b3	0f b7 45 10	 movzx	 eax, WORD PTR _len$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000bf	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _memcpy
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : 	os->next += len;

  000cb	0f b7 45 10	 movzx	 eax, WORD PTR _len$[ebp]
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  000d2	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  000d5	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000d8	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN1@deflate_wr:

; 173  : }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000e4	3b ec		 cmp	 ebp, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_deflate_write_uncompressed_block_slava ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _deflate_align_bitstream_slava
_TEXT	SEGMENT
_os$ = 8						; size = 4
_deflate_align_bitstream_slava PROC			; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 148  : 	os->bitcount += ((unsigned)-((int)os->bitcount)) & 7;

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	f7 d9		 neg	 ecx
  00030	83 e1 07	 and	 ecx, 7
  00033	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00036	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00039	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0003c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 149  : 	deflate_flush_bits_slava(os);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _deflate_flush_bits_slava
  00048	83 c4 04	 add	 esp, 4

; 150  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_deflate_align_bitstream_slava ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _deflate_write_block_header_slava
_TEXT	SEGMENT
_start$ = -8						; size = 4
_os$ = 8						; size = 4
_is_final_block$ = 12					; size = 4
_block_type$ = 16					; size = 4
_deflate_write_block_header_slava PROC			; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 136  : 	DWORD start = GetTickCount();

  00028	8b f4		 mov	 esi, esp
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	89 45 f8	 mov	 DWORD PTR _start$[ebp], eax
$LN2@deflate_wr:

; 137  : 	while (start + 1000 > GetTickCount());

  0003a	8b 75 f8	 mov	 esi, DWORD PTR _start$[ebp]
  0003d	81 c6 e8 03 00
	00		 add	 esi, 1000		; 000003e8H
  00043	8b fc		 mov	 edi, esp
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004b	3b fc		 cmp	 edi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	3b f0		 cmp	 esi, eax
  00054	76 02		 jbe	 SHORT $LN3@deflate_wr
  00056	eb e2		 jmp	 SHORT $LN2@deflate_wr
$LN3@deflate_wr:

; 138  : 
; 139  : 	deflate_add_bits_slava(os, is_final_block, 1);

  00058	6a 01		 push	 1
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _is_final_block$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _deflate_add_bits_slava
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 140  : 	deflate_add_bits_slava(os, block_type, 2);

  0006a	6a 02		 push	 2
  0006c	8b 45 10	 mov	 eax, DWORD PTR _block_type$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 _deflate_add_bits_slava
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 141  : 	deflate_flush_bits_slava(os);

  0007c	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _deflate_flush_bits_slava
  00085	83 c4 04	 add	 esp, 4

; 142  : }

  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00091	3b ec		 cmp	 ebp, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_deflate_write_block_header_slava ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _deflate_flush_bits_slava
_TEXT	SEGMENT
tv85 = -196						; size = 4
_os$ = 8						; size = 4
_deflate_flush_bits_slava PROC				; COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 124  : 	/* Flush a whole word (branchlessly).  */
; 125  : 	put_unaligned_leword_slava(os->bitbuf, os->next);

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _put_unaligned_leword_slava
  0003a	83 c4 08	 add	 esp, 8

; 126  : 	os->bitbuf >>= os->bitcount & ~7;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00046	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00049	8b 02		 mov	 eax, DWORD PTR [edx]
  0004b	d3 e8		 shr	 eax, cl
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00050	89 01		 mov	 DWORD PTR [ecx], eax

; 127  : 	os->next += MIN(os->end - os->next, os->bitcount >> 3);

  00052	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00058	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0005b	2b 51 0c	 sub	 edx, DWORD PTR [ecx+12]
  0005e	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00061	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00064	c1 e9 03	 shr	 ecx, 3
  00067	3b d1		 cmp	 edx, ecx
  00069	77 14		 ja	 SHORT $LN3@deflate_fl
  0006b	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0006e	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00071	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00074	2b 48 0c	 sub	 ecx, DWORD PTR [eax+12]
  00077	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv85[ebp], ecx
  0007d	eb 0f		 jmp	 SHORT $LN4@deflate_fl
$LN3@deflate_fl:
  0007f	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00082	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00085	c1 e8 03	 shr	 eax, 3
  00088	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$LN4@deflate_fl:
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00091	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00094	03 95 3c ff ff
	ff		 add	 edx, DWORD PTR tv85[ebp]
  0009a	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0009d	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 128  : 	os->bitcount &= 7;

  000a0	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  000a3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a6	83 e1 07	 and	 ecx, 7
  000a9	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  000ac	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 129  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_deflate_flush_bits_slava ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _put_unaligned_leword_slava
_TEXT	SEGMENT
_v$ = 8							; size = 4
_p$ = 12						; size = 4
_put_unaligned_leword_slava PROC			; COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 113  : 	STATIC_ASSERT(WORDBITS == 32 || WORDBITS == 64);
; 114  : 	//if (WORDBITS == 32)
; 115  : 	//	put_unaligned_le32(v, p);
; 116  : 	//else
; 117  : 	//	put_unaligned_le64(v, p);
; 118  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_put_unaligned_leword_slava ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _deflate_add_bits_slava
_TEXT	SEGMENT
_os$ = 8						; size = 4
_bits$ = 12						; size = 4
_num_bits$ = 16						; size = 4
_deflate_add_bits_slava PROC				; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 106  : 	os->bitbuf |= bits << os->bitcount;

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _bits$[ebp]
  0002e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00031	d3 e2		 shl	 edx, cl
  00033	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00036	0b 10		 or	 edx, DWORD PTR [eax]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0003b	89 11		 mov	 DWORD PTR [ecx], edx

; 107  : 	os->bitcount += num_bits;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	03 4d 10	 add	 ecx, DWORD PTR _num_bits$[ebp]
  00046	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00049	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 108  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_deflate_add_bits_slava ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _deflate_init_output_slava
_TEXT	SEGMENT
_os$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_deflate_init_output_slava PROC				; COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 96   : 	os->bitbuf = 0;

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 97   : 	os->bitcount = 0;

  00031	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00034	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 98   : 	os->begin = buffer;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00041	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 99   : 	os->next = os->begin;

  00044	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0004a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004d	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 100  : 	os->end = os->begin + size - OUTPUT_END_PADDING;

  00050	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00053	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00056	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  00059	8d 44 11 f8	 lea	 eax, DWORD PTR [ecx+edx-8]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00060	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 101  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_deflate_init_output_slava ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _deflate_flush_output_slava
_TEXT	SEGMENT
_os$ = 8						; size = 4
_deflate_flush_output_slava PROC			; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 78   : 	if (os->next == os->end) /* overflow?  */

  00028	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  0002e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00031	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00034	75 04		 jne	 SHORT $LN2@deflate_fl

; 79   : 		return 0;

  00036	33 c0		 xor	 eax, eax
  00038	eb 4f		 jmp	 SHORT $LN1@deflate_fl
$LN2@deflate_fl:

; 80   : 
; 81   : 	while ((int)os->bitcount > 0) {

  0003a	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0003d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00041	7e 3a		 jle	 SHORT $LN3@deflate_fl

; 82   : 		*os->next++ = os->bitbuf;

  00043	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00046	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00049	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0004c	8a 02		 mov	 al, BYTE PTR [edx]
  0004e	88 01		 mov	 BYTE PTR [ecx], al
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00053	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00056	83 c2 01	 add	 edx, 1
  00059	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  0005c	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 83   : 		os->bitcount -= 8;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	83 e9 08	 sub	 ecx, 8
  00068	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  0006b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 84   : 		os->bitbuf >>= 8;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	c1 e9 08	 shr	 ecx, 8
  00076	8b 55 08	 mov	 edx, DWORD PTR _os$[ebp]
  00079	89 0a		 mov	 DWORD PTR [edx], ecx

; 85   : 	}

  0007b	eb bd		 jmp	 SHORT $LN2@deflate_fl
$LN3@deflate_fl:

; 86   : 
; 87   : 	return os->next - os->begin;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _os$[ebp]
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _os$[ebp]
  00083	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00086	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
$LN1@deflate_fl:

; 88   : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_deflate_flush_output_slava ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _put_unaligned_le16
_TEXT	SEGMENT
_v$ = 8							; size = 2
_p$ = 12						; size = 4
_put_unaligned_le16 PROC				; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 92   : 	if (UNALIGNED_ACCESS_IS_FAST) {

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN2@put_unalig

; 93   : 		store_u16_unaligned(le16_bswap(v), p);

  00031	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00034	50		 push	 eax
  00035	0f b7 4d 08	 movzx	 ecx, WORD PTR _v$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _store_u16_unaligned
  0003f	83 c4 08	 add	 esp, 8

; 94   : 	} else {

  00042	eb 26		 jmp	 SHORT $LN1@put_unalig
$LN2@put_unalig:

; 95   : 		p[0] = (u8)(v >> 0);

  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	6b c8 00	 imul	 ecx, eax, 0
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0004f	8a 45 08	 mov	 al, BYTE PTR _v$[ebp]
  00052	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 96   : 		p[1] = (u8)(v >> 8);

  00055	0f b7 45 08	 movzx	 eax, WORD PTR _v$[ebp]
  00059	c1 f8 08	 sar	 eax, 8
  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	c1 e1 00	 shl	 ecx, 0
  00064	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00067	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$LN1@put_unalig:

; 97   : 	}
; 98   : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_put_unaligned_le16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\libdeflate2\lib\unaligned.h
;	COMDAT _store_u16_unaligned
_TEXT	SEGMENT
_v$ = 8							; size = 2
_p$ = 12						; size = 4
_store_u16_unaligned PROC				; COMDAT

; 17   : DEFINE_UNALIGNED_TYPE(u16)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __7DFAB971_unaligned@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	6a 02		 push	 2
  0002a	8d 45 08	 lea	 eax, DWORD PTR _v$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_store_u16_unaligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\user\source\repos\libdeflate_optimize\libdeflate_optimize\compressor.c
;	COMDAT _compress_slava
_TEXT	SEGMENT
_os$1 = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_in$ = 12						; size = 4
_in_nbytes$ = 16					; size = 4
_out$ = 20						; size = 4
_out_nbytes_avail$ = 24					; size = 4
_compress_slava PROC					; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __E33D8984_compressor@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 177  : 	if (unlikely(out_nbytes_avail < OUTPUT_END_PADDING))

  00032	83 7d 18 08	 cmp	 DWORD PTR _out_nbytes_avail$[ebp], 8
  00036	73 04		 jae	 SHORT $LN2@compress_s

; 178  : 		return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 4d		 jmp	 SHORT $LN1@compress_s
$LN2@compress_s:

; 179  : 
; 180  : 	/* For extremely small inputs just use a single uncompressed block. */
; 181  : 	if (unlikely(in_nbytes < 16)) {

  0003c	83 7d 10 10	 cmp	 DWORD PTR _in_nbytes$[ebp], 16 ; 00000010H
  00040	73 45		 jae	 SHORT $LN3@compress_s

; 182  : 		struct deflate_output_bitstream os;
; 183  : 		deflate_init_output_slava(&os, out, out_nbytes_avail);

  00042	8b 45 18	 mov	 eax, DWORD PTR _out_nbytes_avail$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  00049	51		 push	 ecx
  0004a	8d 55 e4	 lea	 edx, DWORD PTR _os$1[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _deflate_init_output_slava
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 		if (in_nbytes == 0)

  00056	83 7d 10 00	 cmp	 DWORD PTR _in_nbytes$[ebp], 0
  0005a	75 06		 jne	 SHORT $LN4@compress_s

; 185  : 			in = &os; /* Avoid passing NULL to memcpy() */

  0005c	8d 45 e4	 lea	 eax, DWORD PTR _os$1[ebp]
  0005f	89 45 0c	 mov	 DWORD PTR _in$[ebp], eax
$LN4@compress_s:

; 186  : 		deflate_write_uncompressed_block_slava(&os, in, in_nbytes, true);

  00062	6a 01		 push	 1
  00064	0f b7 45 10	 movzx	 eax, WORD PTR _in_nbytes$[ebp]
  00068	50		 push	 eax
  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  0006c	51		 push	 ecx
  0006d	8d 55 e4	 lea	 edx, DWORD PTR _os$1[ebp]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _deflate_write_uncompressed_block_slava
  00076	83 c4 10	 add	 esp, 16			; 00000010H

; 187  : 		return deflate_flush_output_slava(&os);

  00079	8d 45 e4	 lea	 eax, DWORD PTR _os$1[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _deflate_flush_output_slava
  00082	83 c4 04	 add	 esp, 4
  00085	eb 02		 jmp	 SHORT $LN1@compress_s
$LN3@compress_s:

; 188  : 	}
; 189  : 
; 190  : 	return 0;

  00087	33 c0		 xor	 eax, eax
$LN1@compress_s:

; 191  : 	//return (*(c->impl))(c, in, in_nbytes, out, out_nbytes_avail);
; 192  : }

  00089	52		 push	 edx
  0008a	8b cd		 mov	 ecx, ebp
  0008c	50		 push	 eax
  0008d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@compress_s
  00093	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00098	58		 pop	 eax
  00099	5a		 pop	 edx
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	33 cd		 xor	 ecx, ebp
  000a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a7	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000ad	3b ec		 cmp	 ebp, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
$LN8@compress_s:
  000b8	01 00 00 00	 DD	 1
  000bc	00 00 00 00	 DD	 $LN7@compress_s
$LN7@compress_s:
  000c0	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000c4	14 00 00 00	 DD	 20			; 00000014H
  000c8	00 00 00 00	 DD	 $LN6@compress_s
$LN6@compress_s:
  000cc	6f		 DB	 111			; 0000006fH
  000cd	73		 DB	 115			; 00000073H
  000ce	00		 DB	 0
_compress_slava ENDP
_TEXT	ENDS
END
